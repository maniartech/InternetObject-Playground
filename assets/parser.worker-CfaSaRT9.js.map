{"version":3,"file":"parser.worker-CfaSaRT9.js","sources":["../../io-js2/dist/esm/core/document.js","../../io-js2/dist/esm/errors/general-error-codes.js","../../io-js2/dist/esm/errors/tokenization-error-codes.js","../../io-js2/dist/esm/errors/parsing-error-codes.js","../../io-js2/dist/esm/errors/validation-error-codes.js","../../io-js2/dist/esm/errors/io-error-codes.js","../../io-js2/dist/esm/errors/io-error.js","../../io-js2/dist/esm/errors/io-validation-error.js","../../io-js2/dist/esm/parser/tokenizer/token-types.js","../../io-js2/dist/esm/parser/tokenizer/tokens.js","../../io-js2/dist/esm/parser/nodes/tokens.js","../../io-js2/dist/esm/schema/schema.js","../../io-js2/dist/esm/core/definitions.js","../../io-js2/dist/esm/core/header.js","../../io-js2/dist/esm/errors/asserts/asserts.js","../../io-js2/dist/esm/core/internet-object.js","../../io-js2/dist/esm/core/collection.js","../../io-js2/dist/esm/core/decimal-utils.js","../../io-js2/dist/esm/core/decimal.js","../../io-js2/dist/esm/core/section.js","../../io-js2/dist/esm/core/section-collection.js","../../io-js2/dist/esm/errors/io-syntax-error.js","../../io-js2/dist/esm/parser/nodes/containers.js","../../io-js2/dist/esm/parser/nodes/array.js","../../io-js2/dist/esm/parser/nodes/members.js","../../io-js2/dist/esm/parser/nodes/objects.js","../../io-js2/dist/esm/schema/typedef-registry.js","../../io-js2/dist/esm/schema/processing/member-processor.js","../../io-js2/dist/esm/schema/object-processor.js","../../io-js2/dist/esm/parser/nodes/error.js","../../io-js2/dist/esm/schema/utils/schema-resolver.js","../../io-js2/dist/esm/schema/processing/collection-processor.js","../../io-js2/dist/esm/parser/nodes/collections.js","../../io-js2/dist/esm/schema/utils/validation-utils.js","../../io-js2/dist/esm/schema/processor.js","../../io-js2/dist/esm/schema/types/common-type.js","../../io-js2/dist/esm/schema/types/any.js","../../io-js2/dist/esm/schema/types/array.js","../../io-js2/dist/esm/schema/types/boolean.js","../../io-js2/dist/esm/utils/datetime.js","../../io-js2/dist/esm/schema/types/datetime.js","../../io-js2/dist/esm/schema/types/common-number.js","../../io-js2/dist/esm/schema/types/bigint.js","../../io-js2/dist/esm/schema/types/decimal.js","../../io-js2/dist/esm/schema/types/number.js","../../io-js2/dist/esm/schema/types/object.js","../../io-js2/dist/esm/utils/strings.js","../../io-js2/dist/esm/schema/types/string.js","../../io-js2/dist/esm/schema/types/index.js","../../io-js2/dist/esm/schema/types/memberdef-factory.js","../../io-js2/dist/esm/schema/utils/additional-props-canonicalizer.js","../../io-js2/dist/esm/schema/utils/member-utils.js","../../io-js2/dist/esm/schema/compile-object.js","../../io-js2/dist/esm/errors/error-range-utils.js","../../io-js2/dist/esm/parser/tokenizer/symbols.js","../../io-js2/dist/esm/parser/tokenizer/is.js","../../io-js2/dist/esm/parser/tokenizer/literals.js","../../io-js2/dist/esm/parser/tokenizer/index.js","../../io-js2/dist/esm/parser/nodes/document.js","../../io-js2/dist/esm/parser/nodes/section.js","../../io-js2/dist/esm/parser/ast-parser.js","../../io-js2/dist/esm/parser/index.js","../../io-js2/dist/esm/parser/parse-defs.js","../src/types/errors.ts","../src/workers/parser.worker.ts"],"sourcesContent":["class IODocument {\n    constructor(header, sections, errors = []) {\n        this._errors = []; // Accumulated errors during parsing\n        this._header = header;\n        this._sections = sections;\n        this._errors = errors;\n    }\n    get header() {\n        return this._header;\n    }\n    get sections() {\n        return this._sections;\n    }\n    /**\n     * Returns all errors accumulated during parsing and validation.\n     * This enables IDEs and tools to show all diagnostics in one pass.\n     *\n     * @returns A defensive copy of the errors array to prevent external mutation\n     */\n    getErrors() {\n        return [...this._errors];\n    }\n    /**\n     * Adds validation errors to the document.\n     * This method is package-private and should only be called by the parser.\n     *\n     * @internal\n     * @param errors - Array of validation errors to append\n     */\n    addErrors(errors) {\n        if (errors.length > 0) {\n            this._errors.push(...errors);\n        }\n    }\n    /**\n     * Converts the data sections into a JavaScript object.\n     * @param options Optional configuration for JSON conversion\n     * @param options.skipErrors If true, excludes error objects from collections (default: false)\n     */\n    toJSON(options) {\n        const sectionsLen = this._sections?.length || 0;\n        let data = null;\n        if (sectionsLen === 1) {\n            const section = this._sections?.get(0);\n            data = section.toJSON(options);\n        }\n        else if (sectionsLen > 1) {\n            data = {};\n            for (let i = 0; i < sectionsLen; i++) {\n                const section = this._sections?.get(i);\n                data[section.name] = section.toJSON(options);\n            }\n        }\n        // Only return header+data if header has non-empty definitions\n        const headerObject = this.header.toJSON();\n        if (headerObject && Object.keys(headerObject).length > 0) {\n            return {\n                header: headerObject,\n                data,\n            };\n        }\n        return data;\n    }\n    /**\n     * Alias for toJSON() method for backward compatibility\n     * @param options Optional configuration for JSON conversion\n     */\n    toObject(options) {\n        return this.toJSON(options);\n    }\n}\nexport default IODocument;\n","/**\n * General error codes that apply across different phases\n */\nvar GeneralErrorCodes;\n(function (GeneralErrorCodes) {\n    GeneralErrorCodes[\"invalidType\"] = \"invalid-type\";\n    GeneralErrorCodes[\"invalidValue\"] = \"invalid-value\";\n    GeneralErrorCodes[\"valueRequired\"] = \"value-required\";\n    GeneralErrorCodes[\"nullNotAllowed\"] = \"null-not-allowed\";\n})(GeneralErrorCodes || (GeneralErrorCodes = {}));\nexport default GeneralErrorCodes;\n","/**\n * Error codes specific to tokenization phase\n */\nvar TokenizationErrorCodes;\n(function (TokenizationErrorCodes) {\n    // String tokenization\n    TokenizationErrorCodes[\"stringNotClosed\"] = \"string-not-closed\";\n    TokenizationErrorCodes[\"invalidEscapeSequence\"] = \"invalid-escape-sequence\";\n    TokenizationErrorCodes[\"unsupportedAnnotation\"] = \"unsupported-annotation\";\n    // DateTime tokenization\n    TokenizationErrorCodes[\"invalidDateTime\"] = \"invalid-datetime\";\n})(TokenizationErrorCodes || (TokenizationErrorCodes = {}));\nexport default TokenizationErrorCodes;\n","/**\n * Error codes specific to parsing phase (AST construction)\n */\nvar ParsingErrorCodes;\n(function (ParsingErrorCodes) {\n    // General parsing\n    ParsingErrorCodes[\"unexpectedToken\"] = \"unexpected-token\";\n    ParsingErrorCodes[\"expectingBracket\"] = \"expecting-bracket\";\n    ParsingErrorCodes[\"unexpectedPositionalMember\"] = \"unexpected-positional-member\";\n    ParsingErrorCodes[\"invalidKey\"] = \"invalid-key\";\n    // Schema parsing\n    ParsingErrorCodes[\"invalidSchema\"] = \"invalid-schema\";\n    ParsingErrorCodes[\"schemaNotFound\"] = \"schema-not-found\";\n    ParsingErrorCodes[\"schemaMissing\"] = \"schema-missing\";\n    ParsingErrorCodes[\"emptyMemberDef\"] = \"empty-memberdef\";\n    ParsingErrorCodes[\"invalidDefinition\"] = \"invalid-definition\";\n    ParsingErrorCodes[\"invalidMemberDef\"] = \"invalid-memberdef\";\n    ParsingErrorCodes[\"invalidSchemaName\"] = \"invalid-schema-name\";\n    // Variables and definitions\n    ParsingErrorCodes[\"variableNotDefined\"] = \"variable-not-defined\";\n    ParsingErrorCodes[\"schemaNotDefined\"] = \"schema-not-defined\";\n})(ParsingErrorCodes || (ParsingErrorCodes = {}));\nexport default ParsingErrorCodes;\n","/**\n * Error codes specific to validation phase (schema validation)\n */\nvar ValidationErrorCodes;\n(function (ValidationErrorCodes) {\n    // Object validation\n    ValidationErrorCodes[\"invalidObject\"] = \"invalid-object\";\n    ValidationErrorCodes[\"unknownMember\"] = \"unknown-member\";\n    ValidationErrorCodes[\"duplicateMember\"] = \"duplicate-member\";\n    ValidationErrorCodes[\"additionalValuesNotAllowed\"] = \"additional-values-not-allowed\";\n    // Array validation\n    ValidationErrorCodes[\"invalidArray\"] = \"invalid-array\";\n    ValidationErrorCodes[\"notAnArray\"] = \"not-an-array\";\n    // String validation\n    ValidationErrorCodes[\"notAString\"] = \"not-a-string\";\n    ValidationErrorCodes[\"invalidEmail\"] = \"invalid-email\";\n    ValidationErrorCodes[\"invalidUrl\"] = \"invalid-url\";\n    ValidationErrorCodes[\"invalidLength\"] = \"invalid-length\";\n    ValidationErrorCodes[\"invalidMinLength\"] = \"invalid-min-length\";\n    ValidationErrorCodes[\"invalidMaxLength\"] = \"invalid-max-length\";\n    ValidationErrorCodes[\"invalidPattern\"] = \"invalid-pattern\";\n    // Number validation\n    ValidationErrorCodes[\"unsupportedNumberType\"] = \"unsupported-number-type\";\n    ValidationErrorCodes[\"notANumber\"] = \"not-a-number\";\n    ValidationErrorCodes[\"notAnInteger\"] = \"not-an-integer\";\n    ValidationErrorCodes[\"outOfRange\"] = \"out-of-range\";\n    ValidationErrorCodes[\"invalidRange\"] = \"invalid-range\";\n    ValidationErrorCodes[\"invalidScale\"] = \"invalid-scale\";\n    ValidationErrorCodes[\"invalidPrecision\"] = \"invalid-precision\";\n    // Boolean validation\n    ValidationErrorCodes[\"notABool\"] = \"not-a-bool\";\n    // Choice validation\n    ValidationErrorCodes[\"invalidChoice\"] = \"invalid-choice\";\n})(ValidationErrorCodes || (ValidationErrorCodes = {}));\nexport default ValidationErrorCodes;\n","import GeneralErrorCodes from './general-error-codes';\nimport TokenizationErrorCodes from './tokenization-error-codes';\nimport ParsingErrorCodes from './parsing-error-codes';\nimport ValidationErrorCodes from './validation-error-codes';\n/**\n * Consolidated error codes from all categories\n */\nconst ErrorCodes = {\n    ...GeneralErrorCodes,\n    ...TokenizationErrorCodes,\n    ...ParsingErrorCodes,\n    ...ValidationErrorCodes\n};\n// Export individual categories for specific use cases\nexport { GeneralErrorCodes, TokenizationErrorCodes, ParsingErrorCodes, ValidationErrorCodes };\nexport default ErrorCodes;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _IOError_positionRange;\n/**\n * Represents the base error class in InternetObject.\n */\nclass IOError extends Error {\n    get positionRange() { return __classPrivateFieldGet(this, _IOError_positionRange, \"f\"); }\n    set positionRange(value) {\n        __classPrivateFieldSet(this, _IOError_positionRange, value, \"f\");\n        this.updateMessage();\n    }\n    /**\n     * Backward-compat: some tests and callers expect `code` instead of `errorCode`.\n     */\n    get code() { return this.errorCode; }\n    /**\n     * Backward-compat: expose `position` alias for `positionRange` used by older tests.\n     */\n    get position() { return __classPrivateFieldGet(this, _IOError_positionRange, \"f\"); }\n    /**\n     * Initialize the new instance of `IOError`.\n     *\n     * @param errorCode {string} An error-code associated with this error\n     * @param fact {string} The  reason for the error\n     * @param pos {Position} The position object, for tracking line and columns. Optional\n     * @param isEof {boolean} Indicates whether the error is caused by EOF. Optional\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     */\n    constructor(errorCode, fact, positionRange, isEof = false, ssf) {\n        super();\n        /**\n         * A position object, for tracking line and columns.\n         */\n        _IOError_positionRange.set(this, void 0);\n        this.errorCode = errorCode;\n        this.fact = fact;\n        __classPrivateFieldSet(this, _IOError_positionRange, positionRange, \"f\");\n        this.isEof = isEof;\n        this.name = 'IOError';\n        // Format the error message\n        this.updateMessage();\n        // TODO: After stability, change the SSF class\n        // Error.captureStackTrace(this, IOError)\n        // Error.captureStackTrace(this, ssf || InternetObject)\n        this.__proto__ = new.target.prototype;\n    }\n    updateMessage() {\n        let errorMsg = `\"${this.errorCode}\" `;\n        if (this.fact) {\n            errorMsg += `\"${this.fact}\" `;\n        }\n        if (this.isEof) {\n            errorMsg += `at EOF`;\n        }\n        else if (__classPrivateFieldGet(this, _IOError_positionRange, \"f\")) {\n            // Handle both PositionRange (with getStartPos) and plain Position-like objects\n            const pr = __classPrivateFieldGet(this, _IOError_positionRange, \"f\");\n            if (typeof pr.getStartPos === 'function') {\n                const startPos = pr.getStartPos();\n                errorMsg += `at ${startPos.row}:${startPos.col}`;\n            }\n            else if (typeof pr.row === 'number' && typeof pr.col === 'number') {\n                errorMsg += `at ${pr.row}:${pr.col}`;\n            }\n        }\n        this.message = errorMsg;\n    }\n}\n_IOError_positionRange = new WeakMap();\nexport default IOError;\n","import InternetObjectError from \"./io-error\";\n/**\n * Represents the validation error in InternetObject. This error is thrown when a validation\n * issue is found while validating the internet-object data against the associated schema.\n */\nclass IOValidationError extends InternetObjectError {\n    /**\n     * Creates a new `IOValidationError` error.\n     *\n     * @param errorCode {string} An error-code associated with this error\n     * @param fact {string} The  reason for the error\n     * @param pos {Position} The position object, for tracking line and columns. Optional\n     * @param isEof {boolean} Indicates whether the error is caused by EOF. Optional\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     * @internal\n     */\n    constructor(errorCode, fact, posRange, isEof = false, ssf) {\n        super(errorCode, fact, posRange, isEof, ssf);\n        this.name = 'InternetObject(ValidationError)';\n    }\n}\nexport default IOValidationError;\n","/**\n* Enumeration representing types of tokens.\n*/\nvar TokenType;\n(function (TokenType) {\n    TokenType[\"CURLY_OPEN\"] = \"CURLEY_OPEN\";\n    TokenType[\"CURLY_CLOSE\"] = \"CURLY_CLOSE\";\n    TokenType[\"BRACKET_OPEN\"] = \"BRACKET_OPEN\";\n    TokenType[\"BRACKET_CLOSE\"] = \"BRACKET_CLOSE\";\n    TokenType[\"COLON\"] = \"COLON\";\n    TokenType[\"COMMA\"] = \"COMMA\";\n    TokenType[\"STRING\"] = \"STRING\";\n    TokenType[\"BINARY\"] = \"BINARY\";\n    TokenType[\"NUMBER\"] = \"NUMBER\";\n    TokenType[\"BIGINT\"] = \"BIGINT\";\n    TokenType[\"DECIMAL\"] = \"DECIMAL\";\n    TokenType[\"BOOLEAN\"] = \"BOOLEAN\";\n    TokenType[\"NULL\"] = \"NULL\";\n    TokenType[\"UNDEFINED\"] = \"UNDEFINED\";\n    TokenType[\"DATETIME\"] = \"DATETIME\";\n    TokenType[\"DATE\"] = \"DATE\";\n    TokenType[\"TIME\"] = \"TIME\";\n    TokenType[\"WHITESPACE\"] = \"WHITESPACE\";\n    TokenType[\"SECTION_SEP\"] = \"SECTION_SEP\";\n    TokenType[\"SECTION_SCHEMA\"] = \"SECTION_SCHEMA\";\n    TokenType[\"SECTION_NAME\"] = \"SECTION_NAME\";\n    TokenType[\"COLLECTION_START\"] = \"COLLECTION_START\";\n    TokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n    TokenType[\"ERROR\"] = \"ERROR\";\n})(TokenType || (TokenType = {}));\nexport default TokenType;\n","/**\n* Represents a parsed token.\n*/\nclass Token {\n    constructor() {\n        this.pos = -1;\n        this.row = -1;\n        this.col = -1;\n        this.token = '';\n        this.value = undefined;\n        this.type = '';\n        this.subType = '';\n    }\n    /**\n     * Create a token.\n     * @param pos - The starting position of the token in the input.\n     * @param row - The row number of the token's starting position.\n     * @param col - The column number of the token's starting position.\n     * @param token - The raw text of the token from the input.\n     * @param value - The parsed value of the token.\n     * @param type - A descriptive type name for the token.\n     * @param subType - Optional subtype for the token.\n     */\n    static init(pos, row, col, token, value, type, subType) {\n        const t = new Token();\n        t.pos = pos;\n        t.row = row;\n        t.col = col;\n        t.token = token;\n        t.value = value;\n        t.type = type;\n        if (subType) {\n            t.subType = subType;\n        }\n        return t;\n    }\n    clone() {\n        const t = new Token();\n        t.pos = this.pos;\n        t.row = this.row;\n        t.col = this.col;\n        t.token = this.token;\n        t.value = this.value;\n        t.type = this.type;\n        t.subType = this.subType;\n        return t;\n    }\n    getStartPos() {\n        return { row: this.row, col: this.col, pos: this.pos };\n    }\n    /**\n     * Returns the ending position (row, col, pos) of the token.\n     * Useful for debugging and generating error messages.\n     */\n    getEndPos() {\n        const text = this.token.trimEnd();\n        const lines = text.split('\\n');\n        const lastLine = lines[lines.length - 1];\n        const row = this.row + lines.length - 1;\n        const col = lines.length > 1 ? lastLine.length : this.col + lastLine.length;\n        const pos = this.pos + text.length;\n        return { row, col, pos };\n    }\n}\nexport default Token;\n","import TokenType from '../tokenizer/token-types';\nimport Token from '../tokenizer/tokens';\n/**\n * Represents a token node. It represents the leaf nodes in the AST.\n */\nclass TokenNode extends Token {\n    constructor(token) {\n        super();\n        Object.assign(this, token);\n    }\n    /**\n     * Returns the parsed value from the token.\n     * @param defs If the token is of type string, then check if it is a reference\n     *             and return the value from the definitions.\n     * @returns The parsed value.\n     */\n    toValue(defs) {\n        if ((this.type === 'string' || this.type === TokenType.STRING) && defs !== undefined) {\n            const valueFound = defs.getV(this.value);\n            return valueFound === undefined ? this.value : valueFound;\n        }\n        return this.value;\n    }\n}\nexport default TokenNode;\n","export default class Schema {\n    /**\n     * Creates a new instance of Internet Object Schema.\n     * Backward-compatible with legacy constructor usage that passes member objects.\n     * @param name The name of the schema\n     * @param o Optional member definition objects (legacy)\n     */\n    constructor(name, ...o) {\n        /** The names of the members (properties) in the schema */\n        this.names = [];\n        /** The definitions of the members (properties) in the schema */\n        this.defs = {};\n        /**\n         * Controls additional properties (dynamic fields) in the object.\n         * - false: No additional properties allowed\n         * - true: Any additional property allowed (no constraints)\n         * - MemberDef: Additional properties must match the given type/constraints\n         *   (e.g., string, array, object, or with constraints like {string, minLen: 10})\n         *\n         * If the schema uses *: type, *: {}, or *: [string], then open is set to the corresponding MemberDef.\n         * If the schema uses just *, then open is true.\n         * If no * is present, open is false.\n         */\n        this.open = false;\n        this.name = name;\n        // Legacy varargs support: new Schema('Name', { field: def }, { field2: def })\n        if (o && o.length > 0) {\n            o.forEach((item) => {\n                const key = Object.keys(item)[0];\n                const value = item[key];\n                if (value.path === undefined)\n                    value.path = key;\n                this.names.push(key);\n                this.defs[key] = value;\n            });\n        }\n    }\n    /** Returns the member definition of the given member name. */\n    get(name) {\n        return this.defs[name];\n    }\n    /** Checks if a member exists by name. */\n    has(name) {\n        return this.defs[name] !== undefined;\n    }\n    /** Returns the number of members in the schema. */\n    get memberCount() {\n        return this.names.length;\n    }\n    /** Builder entry for new, immutable-style construction while keeping runtime mutability */\n    static create(name) {\n        return new SchemaBuilder(name);\n    }\n    /** Legacy helper for creating from varargs member objects */\n    static fromLegacy(name, ...memberObjects) {\n        return new Schema(name, ...memberObjects);\n    }\n}\nexport class SchemaBuilder {\n    constructor(name) {\n        this.name = name;\n        this.names = [];\n        this.defs = {};\n        this.isOpen = false;\n    }\n    addMember(name, def) {\n        if (this.defs[name]) {\n            throw new Error(`Member '${name}' already exists in schema '${this.name}'`);\n        }\n        this.names.push(name);\n        this.defs[name] = { ...def, path: def.path || name };\n        return this;\n    }\n    setOpen(open) {\n        this.isOpen = open;\n        return this;\n    }\n    build() {\n        const schema = new Schema(this.name);\n        // Populate mutable structure to keep backward compatibility\n        for (const n of this.names) {\n            schema.names.push(n);\n            schema.defs[n] = this.defs[n];\n        }\n        schema.open = this.isOpen;\n        // Freeze names and defs for immutability\n        Object.freeze(schema.names);\n        Object.freeze(schema.defs);\n        return schema;\n    }\n}\n","import ErrorCodes from '../errors/io-error-codes';\nimport ValidationError from '../errors/io-validation-error';\nimport TokenNode from '../parser/nodes/tokens';\nimport TokenType from '../parser/tokenizer/token-types';\nimport Schema from '../schema/schema';\n/**\n * IODefinitions manages definitions (schemas, variables, and regular definitions) for Internet Object.\n *\n * Definitions are accessed by key, but the order in which they are defined is important:\n * - Variables and schema references defined earlier can be used in later definitions, but not vice versa.\n * - This follows the Internet Object specification (see 'the-definitions').\n *\n * The class provides key-based access, mutation, and iteration facilities, while ensuring definition order is respected for reference resolution.\n */\nclass IODefinitions {\n    constructor() {\n        /**\n         * The default schema, if defined. Reset when $schema is deleted or updated.\n         */\n        this._defaultSchema = null;\n        /**\n         * Internal storage for definitions. Order is preserved as per insertion sequence.\n         */\n        this._definitions = {};\n    }\n    /**\n     * Returns the number of definitions in the collection.\n     * @returns Number of definitions.\n     */\n    get length() {\n        return Object.keys(this._definitions).length;\n    }\n    /**\n     * Returns an array of definition keys, in insertion order.\n     * @returns Array of keys.\n     */\n    get keys() {\n        return Object.keys(this._definitions);\n    }\n    /**\n     * Returns the key-value pair at the specified index, preserving definition order.\n     * @param index Index of the definition.\n     * @returns Object with key and value.\n     */\n    at(index) {\n        const key = this.keys[index];\n        return { key, value: this._definitions[key] };\n    }\n    /**\n     * Returns the default schema, if defined.\n     * @returns The default Schema instance or null.\n     */\n    get defaultSchema() {\n        return this._defaultSchema || this._definitions[\"$schema\"]?.value || null;\n    }\n    /**\n     * Gets a definition value by key, regardless of whether it's a variable, schema, or regular definition.\n     * @param key The definition key\n     * @returns The value associated with the key, or undefined if not found\n     */\n    get(key) {\n        return this._definitions[key]?.value;\n    }\n    /**\n     * Gets the variable value. This function is intended to be used internally\n     * for quickly fetching the variable value, hence it accepts any key to keep the\n     * consumer code free from type checking. The function validates the key and\n     * returns the associated value, if available. Otherwise returns undefined.\n     * @param key {any} The variable key starting with $\n     * @returns The value associated with the variable\n     */\n    getV(k) {\n        let key = \"\";\n        if ((k || {}).type === TokenType.STRING) {\n            key = k.value;\n        }\n        else if (typeof k === 'string') {\n            key = k;\n        }\n        else {\n            return;\n        }\n        const def = this._definitions[key];\n        if (!def) {\n            // Only throw errors for variables and schemas\n            if (key.startsWith(\"$\") || key.startsWith(\"@\")) {\n                const positionParam = (typeof k === 'string') ? undefined : k;\n                if (key.startsWith(\"$\")) {\n                    throw new ValidationError(ErrorCodes.schemaNotDefined, `Schema ${key} is not defined.`, positionParam);\n                }\n                throw new ValidationError(ErrorCodes.variableNotDefined, `Variable ${key} is not defined.`, positionParam);\n            }\n            return undefined;\n        }\n        if (def.isVariable) {\n            return def.value;\n        }\n        // Check nested references. If yes, then resolve them and set in the\n        // place of the variable.\n        if (def.value instanceof TokenNode) {\n            const schema = this.getV(def.value);\n            if (schema instanceof Schema) {\n                this.set(key, schema);\n                return schema;\n            }\n        }\n        return def.value;\n    }\n    set(k, v) {\n        const dv = {\n            isSchema: k.startsWith(\"$\"),\n            isVariable: k.startsWith(\"@\"),\n            value: v\n        };\n        this._definitions[k] = dv;\n        this._defaultSchema = null;\n    }\n    /**\n     * Removes a definition by key.\n     * @param key The key of the definition to remove\n     * @returns True if the key existed and was deleted, false otherwise\n     */\n    delete(key) {\n        if (key in this._definitions) {\n            delete this._definitions[key];\n            // If the deleted key was $schema, reset _defaultSchema\n            if (key === \"$schema\") {\n                this._defaultSchema = null;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Pushes a new definition to the definitions list.\n     * @param key The key of the definition\n     * @param value The value of the definition\n     */\n    push(key, value, isSchema = false, isVariable = false) {\n        this._definitions[key] = { isSchema, isVariable, value };\n        if (key === \"$schema\") {\n            this._defaultSchema = value;\n        }\n    }\n    /**\n     * Merges the definitions with the other definitions.\n     * @param other     The other definitions to merge with\n     * @param override  If true, the other definitions will override the current\n     *                  definitions\n     */\n    merge(other, override = false) {\n        for (let i = 0; i < other.length; i++) {\n            const { key, value } = other.at(i);\n            if (override || !this._definitions[key]) {\n                this.push(key, value.value, value.isSchema, value.isVariable);\n            }\n        }\n    }\n    toJSON() {\n        const obj = {};\n        let keysCount = 0;\n        for (let i = 0; i < this.length; i++) {\n            const def = this.at(i);\n            // Skip schema and variable definitions\n            if (def.value.isSchema || def.value.isVariable) {\n                continue;\n            }\n            keysCount++;\n            obj[def.key] = def.value.value?.toObject ? def.value.value.toObject() : def.value.value;\n        }\n        if (keysCount) {\n            return obj;\n        }\n        return null;\n    }\n    /**\n     * Returns an iterator of definition keys.\n     */\n    /**\n     * Returns an iterator of definition keys (useful for for...of).\n     */\n    *keyIterator() {\n        for (const key of Object.keys(this._definitions)) {\n            yield key;\n        }\n    }\n    /**\n     * Returns an iterator of [key, value] pairs.\n     */\n    *entries() {\n        for (const key of this.keyIterator()) {\n            yield [key, this._definitions[key]];\n        }\n    }\n    /**\n     * Default iterator for [key, value] pairs.\n     */\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n}\nexport default IODefinitions;\n","import IODefinitions from './definitions';\nclass IOHeader {\n    constructor() {\n        this._schema = null;\n        this._definitions = new IODefinitions();\n    }\n    get schema() {\n        return this._schema || this._definitions.defaultSchema;\n    }\n    set schema(value) {\n        this._schema = value;\n    }\n    get definitions() {\n        return this._definitions;\n    }\n    merge(other, override = false) {\n        if (override && other.schema) {\n            this._schema = other.schema;\n        }\n        if (other.definitions) {\n            this._definitions.merge(other.definitions, override);\n        }\n    }\n    toJSON() {\n        return this._definitions.toJSON();\n    }\n}\nexport default IOHeader;\n","/**\n * Place this function to check and ensure the code where invoked must never\n * reach. This function is ueful to identify issues with the code by identifying\n * the code path which must have never reached.\n * @param x The object which needs to be asserted as never\n */\nfunction assertNever(x, pos) {\n    let message = \"Assert never\";\n    if (x !== undefined && x !== null) {\n        message = `Assert never: ${x.toString()}`;\n    }\n    if (pos) {\n        message += ` at ${pos.toString()}`;\n    }\n    throw new Error(message);\n}\nexport default assertNever;\n","class IOObject {\n    constructor(o) {\n        this.items = [];\n        this.keyMap = new Map();\n        if (o) {\n            for (const [key, value] of Object.entries(o)) {\n                this.set(key, value);\n            }\n        }\n    }\n    /**\n     * Adds or updates a key-value pair in the IOObject.\n     * If the key exists, updates the value at its index.\n     * @param key The key to add or update.\n     * @param value The value associated with the key.\n     * @returns The IOObject instance.\n     */\n    set(key, value) {\n        if (this.keyMap.has(key)) {\n            const index = this.keyMap.get(key);\n            this.items[index] = [key, value];\n        }\n        else {\n            const index = this.items.length;\n            this.items.push([key, value]);\n            this.keyMap.set(key, index);\n        }\n        // Synchronize instance property\n        Object.defineProperty(this, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n        });\n        return this;\n    }\n    /**\n     * Appends values to the IOObject.\n     * Values can be with or without keys.\n     * @param items Variadic arguments of values or [key, value] pairs.\n     */\n    push(...items) {\n        for (const item of items) {\n            if (Array.isArray(item)) {\n                const [key, value] = item;\n                if (this.has(key)) {\n                    throw new Error(`Key '${key}' already exists`);\n                }\n                const index = this.items.length;\n                this.items.push([key, value]);\n                this.keyMap.set(key, index);\n            }\n            else {\n                this.items.push([undefined, item]);\n            }\n        }\n    }\n    /**\n     * Retrieves the value associated with the given key.\n     * @param key The key to look up.\n     * @returns The value if found, otherwise undefined.\n     */\n    get(key) {\n        const index = this.keyMap.get(key);\n        if (index !== undefined) {\n            const entry = this.items[index];\n            return entry ? entry[1] : undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Retrieves the value at the specified index.\n     * @param index The index to access.\n     * @returns The value if index is valid and entry exists, otherwise undefined.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            return undefined;\n        }\n        const entry = this.items[index];\n        return entry ? entry[1] : undefined;\n    }\n    /**\n     * Retrieves the key at the specified index.\n     * @param index The index to access.\n     * @returns The key if index is valid and exists, otherwise undefined.\n     */\n    keyAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            return undefined;\n        }\n        const entry = this.items[index];\n        return entry ? entry[0] : undefined;\n    }\n    /**\n     * Checks if the IOObject contains a given key.\n     * @param key The key to check.\n     * @returns True if the key exists, otherwise false.\n     */\n    has(key) {\n        return this.keyMap.has(key);\n    }\n    /**\n     * Deletes a key-value pair from the IOObject by key.\n     * @param key The key to delete.\n     * @returns True if the key was found and deleted, otherwise false.\n     */\n    delete(key) {\n        const index = this.keyMap.get(key);\n        if (index !== undefined && this.items[index]) {\n            this.items[index] = undefined;\n            this.keyMap.delete(key);\n            // Remove instance property\n            delete this[key];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Deletes a value at a specific index.\n     * Throws an error if the index is out of range.\n     * @param index The index to delete.\n     * @returns True if the value was deleted, otherwise false.\n     * @throws Error if the index is invalid.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            throw new Error('Index out of range');\n        }\n        const entry = this.items[index];\n        if (entry) {\n            const key = entry[0];\n            if (key !== undefined) {\n                this.keyMap.delete(key);\n            }\n            this.items[index] = undefined;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Updates the value at the specified index.\n     * Throws an error if the index is out of range.\n     * @param index The index to set.\n     * @param value The value to set.\n     * @returns True if the value was updated, otherwise false.\n     * @throws Error if the index is invalid.\n     */\n    setAt(index, value) {\n        if (index < 0 || index >= this.items.length) {\n            throw new Error('Index out of range');\n        }\n        const entry = this.items[index];\n        if (entry) {\n            this.items[index] = [entry[0], value];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the index of the given key.\n     * @param key The key to find.\n     * @returns The index if found, otherwise -1.\n     */\n    indexOfKey(key) {\n        return this.keyMap.get(key) ?? -1;\n    }\n    /**\n     * Returns the index of the given value.\n     * @param value The value to find.\n     * @returns The index if found, otherwise -1.\n     */\n    indexOf(value) {\n        return this.items.findIndex((entry) => entry !== undefined && Object.is(entry[1], value));\n    }\n    /**\n     * Checks if the IOObject is empty.\n     * @returns True if empty, otherwise false.\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * Creates an IOObject from an array of values or [key, value] pairs.\n     * @param array The array to create from.\n     * @returns A new IOObject instance.\n     */\n    static fromArray(array) {\n        const io = new IOObject();\n        for (const item of array) {\n            if (Array.isArray(item)) {\n                io.set(item[0], item[1]);\n            }\n            else {\n                io.push(item);\n            }\n        }\n        return io;\n    }\n    /**\n     * Returns the number of entries in the IOObject, including undefined entries.\n     */\n    get length() {\n        return this.items.length;\n    }\n    /**\n     * Clears all key-value pairs from the IOObject.\n     */\n    clear() {\n        // Remove all instance properties for keys\n        for (const key of this.keysArray()) {\n            delete this[key];\n        }\n        this.items = [];\n        this.keyMap.clear();\n    }\n    /**\n     * Compacts the items array by removing undefined entries and updating the keyMap.\n     * Note: This operation is O(n) and may affect performance on large datasets.\n     * Use this method when you need to reduce memory usage or after multiple deletions.\n     */\n    compact() {\n        const newItems = [];\n        const newKeyMap = new Map();\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                newItems.push(entry);\n                const key = entry[0];\n                if (key !== undefined) {\n                    newKeyMap.set(key, newItems.length - 1);\n                }\n            }\n        }\n        this.items = newItems;\n        this.keyMap = newKeyMap;\n    }\n    /**\n     * Executes a provided function once for each key-value pair.\n     * @param callbackfn Function to execute for each element.\n     * @param thisArg Value to use as `this` when executing callback.\n     */\n    forEach(callbackfn, thisArg) {\n        for (let index = 0; index < this.items.length; index++) {\n            const entry = this.items[index];\n            if (entry !== undefined) {\n                callbackfn.call(thisArg, entry[1], entry[0], index);\n            }\n        }\n    }\n    /**\n     * Returns an iterable of key, value pairs for every entry in the IOObject.\n     */\n    entries() {\n        return this._createIterator((entry) => entry);\n    }\n    /**\n     * Returns an array of keys in the IOObject.\n     * Excludes entries without keys (i.e., where key is undefined).\n     * @returns An array of keys.\n     */\n    keysArray() {\n        return this.items\n            .filter((entry) => entry !== undefined && entry[0] !== undefined)\n            .map((entry) => entry[0]);\n    }\n    /**\n     * Returns an iterable of keys in the IOObject.\n     * Excludes entries without keys (i.e., where key is undefined).\n     */\n    keys() {\n        return (function* (items) {\n            for (const entry of items) {\n                if (entry !== undefined && entry[0] !== undefined) {\n                    yield entry[0];\n                }\n            }\n        })(this.items);\n    }\n    /**\n     * Returns an iterable of values in the IOObject.\n     */\n    values() {\n        return (function* (items) {\n            for (const entry of items) {\n                if (entry !== undefined) {\n                    yield entry[1];\n                }\n            }\n        })(this.items);\n    }\n    /**\n     * Returns an array of values in the IOObject.\n     * Includes all entries, even those without keys.\n     * @returns An array of values.\n     */\n    valuesArray() {\n        return this.items\n            .filter((entry) => entry !== undefined)\n            .map((entry) => entry[1]);\n    }\n    /**\n     * Creates an iterator based on a selector function.\n     * @param selector Function to select the output of the iterator.\n     */\n    *_createIterator(selector) {\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                yield selector(entry);\n            }\n        }\n    }\n    /**\n     * Returns an iterator over the entries in insertion order.\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Returns the default string representation of the object.\n     */\n    get [Symbol.toStringTag]() {\n        return 'IOObject';\n    }\n    /**\n     * Finds a value based on a predicate function.\n     * @param predicate Function to test each element.\n     * @returns The value if found, otherwise undefined.\n     */\n    find(predicate) {\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined && predicate(entry[1], entry[0], index)) {\n                return entry[1];\n            }\n            index++;\n        }\n        return undefined;\n    }\n    /**\n     * Finds the index of a value based on a predicate function.\n     * @param predicate Function to test each element.\n     * @returns The index if found, otherwise -1.\n     */\n    findIndex(predicate) {\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined && predicate(entry[1], entry[0], index)) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n    /**\n     * Creates a new array populated with the results of calling a provided function on every element.\n     * @param callbackfn Function that produces an element of the new Array.\n     * @param thisArg Value to use as `this` when executing callback.\n     * @returns A new array with each element being the result of the callback function.\n     */\n    map(callbackfn, thisArg) {\n        const result = [];\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                result.push(callbackfn.call(thisArg, entry[1], entry[0], index));\n            }\n            index++;\n        }\n        return result;\n    }\n    /**\n     * Converts the InternetObject to a JSON object. If the items do not have keys,\n     * use the index as the key. If the value has toJSON method, it will be called.\n     * Used when calling JSON.stringify.\n     * @returns An array of entries.\n     */\n    toJSON() {\n        const obj = {};\n        this.forEach((value, key, index) => {\n            if (typeof value === \"undefined\")\n                return;\n            obj[key || index] =\n                typeof value === 'object' && typeof value?.toJSON === 'function'\n                    ? value.toJSON()\n                    : value;\n        });\n        return obj;\n    }\n}\nexport default IOObject;\n","import assertNever from '../errors/asserts/asserts';\nimport IOObject from \"./internet-object\";\n/**\n * IOCollection is a collection of IOObject instances.\n */\nclass IOCollection {\n    /**\n     * Constructs a new IOCollection instance.\n     * @param items - An optional array of items to initialize the collection with.\n     */\n    constructor(items = []) {\n        this._items = items;\n    }\n    /**\n     * Pushes one or more items to the IOCollection\n     * @param items - The items to push.\n     * @returns The updated IOCollection.\n     */\n    push(...items) {\n        this._items.push(...items);\n        return this;\n    }\n    /**\n     * Gets the item at the specified index.\n     * @param index - The index of the item to retrieve.\n     * @throws {Error} If the index is out of range.\n     * @returns The item at the specified index.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Index out of range');\n        }\n        return this._items[index];\n    }\n    /**\n     * Sets the item at the specified index.\n     * @param index - The index at which to set the item.\n     * @param item - The item to set.\n     * @throws {Error} If the index is negative.\n     * @returns The updated IOCollection.\n     */\n    setAt(index, item) {\n        if (index < 0) {\n            throw new Error('Index cannot be negative.');\n        }\n        if (index >= this._items.length) {\n            this._items.push(item);\n        }\n        else {\n            this._items[index] = item;\n        }\n        return this;\n    }\n    /**\n     * Deletes an item from the IOCollection at the specified index.\n     * @param index - The index of the item to delete.\n     * @throws {Error} If the index is out of range.\n     * @returns The updated IOCollection.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Index out of range');\n        }\n        this._items.splice(index, 1);\n        return this;\n    }\n    /**\n     * Gets the length of the IOCollection.\n     * @returns The number of items in the IOCollection.\n     */\n    get length() {\n        return this._items.length;\n    }\n    /**\n     * Checks if the IOCollection is empty.\n     * @returns True if the IOCollection is empty, otherwise false.\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * Creates a new IOCollection with the results of calling a provided function on every element.\n     * @param callback - Function that produces an element of the new IOCollection.\n     * @returns A new IOCollection with each element being the result of the callback function.\n     */\n    map(callback) {\n        const mappedItems = this._items.map(callback);\n        return new IOCollection(mappedItems);\n    }\n    /**\n     * Creates a new IOCollection with all elements that pass the test implemented by the provided function.\n     * @param callback - Function to test each element of the IOCollection.\n     * @returns A new IOCollection with the elements that pass the test.\n     */\n    filter(callback) {\n        const filteredItems = this._items.filter(callback);\n        return new IOCollection(filteredItems);\n    }\n    /**\n     * Applies a function against an accumulator and each element in the IOCollection to reduce it to a single value.\n     * @param callback - Function to execute on each element in the IOCollection.\n     * @param initialValue - Initial value to start the reduction.\n     * @returns The single value that results from the reduction.\n     */\n    reduce(callback, initialValue) {\n        return this._items.reduce(callback, initialValue);\n    }\n    /**\n     * Executes a provided function once for each IOCollection element.\n     * @param callback - Function to execute on each element.\n     */\n    forEach(callback) {\n        this._items.forEach(callback);\n    }\n    /**\n     * Tests whether at least one element in the IOCollection passes the test implemented by the provided function.\n     * @param callback - Function to test each element.\n     * @returns True if the callback function returns a truthy value for at least one element, otherwise false.\n     */\n    some(callback) {\n        return this._items.some(callback);\n    }\n    /**\n     * Tests whether all elements in the IOCollection pass the test implemented by the provided function.\n     * @param callback - Function to test each element.\n     * @returns True if the callback returns a truthy value for all elements, otherwise false.\n     */\n    every(callback) {\n        return this._items.every(callback);\n    }\n    /**\n     * Returns the value of the first element in the IOCollection that satisfies the provided testing function.\n     * @param callback - Function to execute on each element.\n     * @returns The first element that satisfies the testing function, or undefined if no elements satisfy it.\n     */\n    find(callback) {\n        return this._items.find(callback);\n    }\n    /**\n     * Returns the index of the first element in the IOCollection that satisfies the provided testing function.\n     * @param callback - Function to execute on each element.\n     * @returns The index of the first element that satisfies the testing function, or -1 if no elements satisfy it.\n     */\n    findIndex(callback) {\n        return this._items.findIndex(callback);\n    }\n    /**\n     * Inserts one or more items into the IOCollection at the specified index.\n     * @param index - The index at which to insert the items.\n     * @param items - The items to insert.\n     * @returns The new length of the IOCollection.\n     */\n    insert(index, ...items) {\n        this._items.splice(index, 0, ...items);\n        return this._items.length;\n    }\n    /**\n     * Removes the last item from the IOCollection.\n     * @returns The removed item, or undefined if the IOCollection is empty.\n     */\n    pop() {\n        return this._items.pop();\n    }\n    /**\n     * Converts the IOCollection to a JSON-compatible representation.\n     * @param options Optional configuration for JSON conversion\n     * @param options.skipErrors If true, excludes error objects from output (default: false)\n     * @returns An array of JSON-compatible representations of the items.\n     */\n    toJSON(options) {\n        const skipErrors = options?.skipErrors ?? false;\n        return this._items\n            .filter((item) => {\n            // If skipErrors is true, filter out items with toValue that return __error\n            if (skipErrors && typeof item === 'object' && item !== null) {\n                if (typeof item.toValue === 'function') {\n                    const value = item.toValue();\n                    if (value && value.__error === true) {\n                        return false; // Skip this error item\n                    }\n                }\n            }\n            return true; // Keep this item\n        })\n            .map((item) => {\n            if (item instanceof IOObject) {\n                return item.toJSON();\n            }\n            else if (typeof item === 'object' && item !== null) {\n                // Check if item has toValue method (e.g., ErrorNode)\n                if (typeof item.toValue === 'function') {\n                    return item.toValue();\n                }\n                // Check if item has toJSON method\n                if (typeof item.toJSON === 'function') {\n                    return item.toJSON();\n                }\n                return JSON.stringify(item);\n            }\n            return item;\n        });\n    }\n    /**\n     * Returns all Error objects contained within this collection's ErrorNodes.\n     *\n     * Note: This method is primarily useful when working with collections directly.\n     * When using Document.getErrors(), all errors (parser + validation) are already\n     * aggregated at the document level.\n     *\n     * @returns Array of Error objects from ErrorNode items in this collection\n     */\n    getErrors() {\n        const errors = [];\n        for (const item of this._items) {\n            // ErrorNode-like shape: has an `error` property of type Error\n            if (item && typeof item === 'object' && item.error instanceof Error) {\n                errors.push(item.error);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Allows iteration over the IOCollection using for..of syntax.\n     * @returns An iterator for the IOCollection.\n     */\n    *[Symbol.iterator]() {\n        yield* this._items;\n    }\n    /**\n     * Returns an iterator of [index, item] pairs.\n     * @returns An iterator of index-item pairs.\n     */\n    *entries() {\n        for (let index = 0; index < this._items.length; index++) {\n            yield [index, this._items[index]];\n        }\n    }\n    /**\n     * Returns an iterator of item indices.\n     * @returns An iterator of item indices.\n     */\n    *keys() {\n        for (let index = 0; index < this._items.length; index++) {\n            yield index;\n        }\n    }\n    /**\n     * Returns an iterator of IOCollection items.\n     * @returns An iterator of IOCollection items.\n     */\n    *values() {\n        yield* this._items;\n    }\n}\nconst proxy = {\n    get: (target, property) => {\n        if (property in target) {\n            return Reflect.get(target, property);\n        }\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            return target.getAt(Number(property));\n        }\n        assertNever(property);\n    },\n    set: (target, property, value) => {\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            target.setAt(Number(property), value);\n            return true;\n        }\n        throw new Error('Cannot set a value on a Collection');\n    },\n    deleteProperty: (target, property) => {\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            const index = Number(property);\n            target.deleteAt(index);\n            return true;\n        }\n        throw new Error('Cannot delete a value on a Collection');\n    }\n};\nexport default IOCollection;\n","/**\n * Decimal Utility Functions\n *\n * Core utility functions for decimal arithmetic operations following KISS principles.\n * All functions use BigInt-only calculations and avoid JavaScript Number class.\n */\nimport { DecimalError } from './decimal';\n/**\n * Normalizes a BigInt coefficient by handling leading zeros and sign normalization.\n *\n * @param coefficient The BigInt coefficient to normalize\n * @returns Normalized coefficient and zero flag\n */\nexport function normalizeCoefficient(coefficient) {\n    // Handle zero case\n    if (coefficient === 0n) {\n        return {\n            coefficient: 0n,\n            isZero: true\n        };\n    }\n    // For non-zero values, BigInt already handles normalization\n    // No leading zeros exist in BigInt representation\n    return {\n        coefficient,\n        isZero: false\n    };\n}\n/**\n * Gets the absolute value of a BigInt coefficient.\n *\n * @param coefficient The BigInt coefficient\n * @returns The absolute value as BigInt\n */\nexport function getAbsoluteValue(coefficient) {\n    return coefficient < 0n ? -coefficient : coefficient;\n}\n/**\n * Gets the sign of a BigInt coefficient.\n *\n * @param coefficient The BigInt coefficient\n * @returns 1 for positive, -1 for negative, 0 for zero\n */\nexport function getSign(coefficient) {\n    if (coefficient === 0n)\n        return 0;\n    return coefficient > 0n ? 1 : -1;\n}\n/**\n * Cache for powers of 10\n */\nconst POW10_CACHE = new Map();\n/**\n * Gets a power of 10 as BigInt, using cache for performance.\n * @param exponent The exponent for the power of 10\n * @returns 10^exponent as BigInt\n */\nexport function getPow10(exponent) {\n    if (exponent < 0) {\n        throw new Error('Exponent must be non-negative');\n    }\n    if (!POW10_CACHE.has(exponent)) {\n        POW10_CACHE.set(exponent, 10n ** BigInt(exponent));\n    }\n    return POW10_CACHE.get(exponent);\n}\n/**\n * Scales up a coefficient by multiplying by powers of 10.\n * Effectively moves the decimal point to the right.\n *\n * @param coefficient The BigInt coefficient to scale up\n * @param scaleFactor The number of decimal places to scale up (must be non-negative)\n * @returns The scaled up coefficient\n * @throws Error if scaleFactor is negative\n */\nexport function scaleUp(coefficient, scaleFactor) {\n    if (scaleFactor < 0) {\n        throw new Error(`Scale factor must be non-negative, got ${scaleFactor}`);\n    }\n    if (scaleFactor === 0) {\n        return coefficient;\n    }\n    return coefficient * getPow10(scaleFactor);\n}\n/**\n * Scales down a coefficient by dividing by powers of 10 with basic truncation.\n * Effectively moves the decimal point to the left.\n *\n * @param coefficient The BigInt coefficient to scale down\n * @param scaleFactor The number of decimal places to scale down (must be non-negative)\n * @returns The scaled down coefficient (truncated, not rounded)\n * @throws Error if scaleFactor is negative\n */\nexport function scaleDown(coefficient, scaleFactor) {\n    if (scaleFactor < 0) {\n        throw new Error('Scale factor must be non-negative');\n    }\n    if (scaleFactor === 0) {\n        return coefficient;\n    }\n    return coefficient / getPow10(scaleFactor);\n}\n/**\n * Rounds a coefficient using round-half-up behavior when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function roundHalfUp(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with rounding\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Round half up logic\n    const halfDivisor = divisor / 2n;\n    const absRemainder = remainder < 0n ? -remainder : remainder;\n    if (absRemainder >= halfDivisor) {\n        return quotient + (coefficient >= 0n ? 1n : -1n);\n    }\n    return quotient;\n}\n/**\n * Rounds a coefficient using ceiling behavior (always round up) when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The ceiling rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function ceilRound(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with ceiling\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Ceiling logic: if there's any remainder and coefficient is positive, round up\n    // If coefficient is negative and there's remainder, don't round (towards zero)\n    if (remainder !== 0n && coefficient > 0n) {\n        return quotient + 1n;\n    }\n    return quotient;\n}\n/**\n * Rounds a coefficient using floor behavior (always round down) when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The floor rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function floorRound(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with floor\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Floor logic: if there's any remainder and coefficient is negative, round down\n    // If coefficient is positive and there's remainder, don't round (towards zero)\n    if (remainder !== 0n && coefficient < 0n) {\n        return quotient - 1n;\n    }\n    return quotient;\n}\n/**\n * Formats a BigInt coefficient as a decimal string with the specified scale and precision.\n * Uses normalization utilities for proper coefficient handling and decimal point placement.\n *\n * @param coefficient The BigInt coefficient to format\n * @param scale The number of decimal places\n * @param precision Optional. The total number of significant digits. If provided, validates that the coefficient fits within precision.\n * @returns The formatted decimal string\n * @throws Error if the coefficient exceeds the specified precision\n */\nexport function formatBigIntAsDecimal(coefficient, scale, precision) {\n    // Handle zero case\n    if (coefficient === 0n) {\n        return scale > 0 ? `0.${'0'.repeat(scale)}` : '0';\n    }\n    // Validate precision and scale if precision is provided\n    if (precision !== undefined) {\n        const validationResult = validatePrecisionScale(coefficient, precision, scale);\n        if (!validationResult.valid) {\n            throw new DecimalError(`Coefficient validation failed: ${validationResult.reason}`);\n        }\n    }\n    // Extract sign and work with absolute value\n    const sign = coefficient < 0n ? '-' : '';\n    const absCoeff = coefficient < 0n ? -coefficient : coefficient;\n    let coeffStr = absCoeff.toString();\n    // Pad with leading zeros if needed\n    while (coeffStr.length <= scale) {\n        coeffStr = '0' + coeffStr;\n    }\n    // Split into integer and fractional parts\n    const integerPart = coeffStr.slice(0, coeffStr.length - scale) || '0';\n    const fractionalPart = scale > 0 ? coeffStr.slice(-scale) : '';\n    // Validate that the formatted number fits within precision constraints\n    // This is a check on the significant digits in the formatted result\n    if (precision !== undefined) {\n        // Count significant digits (ignore leading zeros in integer part)\n        const significantIntegerDigits = integerPart === '0' ? 0 : integerPart.replace(/^0+/, '').length;\n        // For fractional part, count all digits except trailing zeros if integer part is 0\n        let significantFractionalDigits = fractionalPart.length;\n        if (significantIntegerDigits === 0) {\n            // For values less than 1, ignore leading zeros in fractional part\n            const significantFractionalPart = fractionalPart.replace(/^0+/, '');\n            significantFractionalDigits = significantFractionalPart.length || 0;\n        }\n        const totalSignificantDigits = significantIntegerDigits + significantFractionalDigits;\n        if (totalSignificantDigits > precision) {\n            throw new DecimalError(`Formatted value exceeds specified precision (${precision}). Value has ${totalSignificantDigits} significant digits.`);\n        }\n    }\n    return sign + integerPart + (scale > 0 ? '.' + fractionalPart : '');\n}\n/**\n * Fits a coefficient to the specified precision by truncating and rounding if necessary.\n * Uses the specified rounding mode to handle precision overflow.\n *\n * @param coefficient The BigInt coefficient to fit to precision\n * @param precision The maximum number of significant digits allowed\n * @param scale The current scale of the coefficient\n * @param roundingMode The rounding mode to use ('round', 'ceil', 'floor')\n * @returns The coefficient fitted to the specified precision\n * @throws DecimalError if the coefficient cannot be fitted to the precision\n */\nexport function fitToPrecision(coefficient, precision, scale, roundingMode = 'round') {\n    // Handle zero coefficient\n    if (coefficient === 0n) {\n        return 0n;\n    }\n    // Get absolute value for digit counting\n    const absCoeff = getAbsoluteValue(coefficient);\n    const coeffStr = absCoeff.toString();\n    // If already fits within precision, return unchanged\n    if (coeffStr.length <= precision) {\n        return coefficient;\n    }\n    // Calculate how many digits to remove\n    const excessDigits = coeffStr.length - precision;\n    // If excess digits are more than scale, we can't fit without losing integer part\n    if (excessDigits > scale) {\n        // We would lose digits from the integer part, which is not allowed\n        throw new DecimalError(`Cannot fit coefficient to precision ${precision}. ` +\n            `Coefficient has ${coeffStr.length} digits with scale ${scale}. ` +\n            `Would lose ${excessDigits - scale} digits from integer part.`);\n    }\n    // Calculate target scale after truncation\n    const targetScale = scale - excessDigits;\n    // Apply appropriate rounding based on mode\n    let result;\n    switch (roundingMode) {\n        case 'round':\n            result = roundHalfUp(coefficient, scale, targetScale);\n            break;\n        case 'ceil':\n            result = ceilRound(coefficient, scale, targetScale);\n            break;\n        case 'floor':\n            result = floorRound(coefficient, scale, targetScale);\n            break;\n        default:\n            throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n    }\n    // Verify the result fits within precision\n    const resultStr = getAbsoluteValue(result).toString();\n    if (resultStr.length > precision) {\n        // This can happen with rounding (e.g., 999 rounded to 2 digits becomes 1000)\n        // In this case, we need to adjust scale again\n        if (targetScale > 0) {\n            // Use the same rounding mode for consistency\n            switch (roundingMode) {\n                case 'round':\n                    return roundHalfUp(result, targetScale, targetScale - 1);\n                case 'ceil':\n                    return ceilRound(result, targetScale, targetScale - 1);\n                case 'floor':\n                    return floorRound(result, targetScale, targetScale - 1);\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n        else {\n            // Special case for rounding that causes overflow (e.g., 9999 -> 10000)\n            // If the result ends with zeros, we can remove them to fit precision\n            if (result % 10n === 0n) {\n                // Count trailing zeros\n                let tempResult = result;\n                let zerosToRemove = 0;\n                while (tempResult % 10n === 0n && zerosToRemove < resultStr.length - precision) {\n                    tempResult = tempResult / 10n;\n                    zerosToRemove++;\n                }\n                if (getAbsoluteValue(tempResult).toString().length <= precision) {\n                    return tempResult;\n                }\n            }\n            throw new DecimalError(`Rounding resulted in precision overflow. ` +\n                `Result has ${resultStr.length} digits, but precision is ${precision}.`);\n        }\n    }\n    return result;\n}\n/**\n * Validates if a coefficient fits within the specified precision and scale constraints.\n *\n * @param coefficient The BigInt coefficient to validate\n * @param precision The maximum number of significant digits allowed\n * @param scale The number of decimal places\n * @returns A ValidationResult object indicating if the coefficient is valid and why if not\n */\nexport function validatePrecisionScale(coefficient, precision, scale) {\n    // Validate precision and scale parameters\n    if (precision <= 0) {\n        return { valid: false, reason: 'Precision must be positive' };\n    }\n    if (scale < 0) {\n        return { valid: false, reason: 'Scale must be non-negative' };\n    }\n    if (scale > precision) {\n        return { valid: false, reason: 'Scale must be less than or equal to precision' };\n    }\n    // Handle zero coefficient (always valid)\n    if (coefficient === 0n) {\n        return { valid: true };\n    }\n    // Get absolute value for digit counting\n    const absCoeff = getAbsoluteValue(coefficient);\n    const coeffStr = absCoeff.toString();\n    // Check if coefficient fits within precision\n    if (coeffStr.length > precision) {\n        return {\n            valid: false,\n            reason: `Coefficient has ${coeffStr.length} digits, exceeding precision of ${precision}`\n        };\n    }\n    // Calculate integer part digits\n    const integerDigits = coeffStr.length - scale;\n    // If integer part is negative, we have leading zeros in fractional part\n    if (integerDigits < 0) {\n        // This is valid, as it means we have leading zeros in fractional part\n        // For example: 0.001 with scale 3 has integerDigits = -2\n        return { valid: true };\n    }\n    // If we get here, the coefficient fits within precision and scale constraints\n    return { valid: true };\n}\n/**\n * Performs long division between two BigInt coefficients with specified scale and precision.\n * Handles repeating decimals and precision constraints.\n *\n * @param dividend The dividend coefficient\n * @param divisor The divisor coefficient (must not be zero)\n * @param scale The desired scale (decimal places) for the result\n * @param precision The maximum precision allowed for the result\n * @param maxIterations Maximum number of iterations to detect repeating decimals (default: 100)\n * @returns A DivisionResult object containing quotient, remainder, and flags for exactness and repeating digits\n * @throws DecimalError if divisor is zero or if precision constraints cannot be met\n */\nexport function performLongDivision(dividend, divisor, scale, precision, maxIterations = 100) {\n    // Validate inputs\n    if (divisor === 0n) {\n        throw new DecimalError(\"Division by zero\");\n    }\n    if (precision <= 0) {\n        throw new DecimalError(\"Precision must be positive\");\n    }\n    if (scale < 0) {\n        throw new DecimalError(\"Scale must be non-negative\");\n    }\n    if (scale > precision) {\n        throw new DecimalError(\"Scale must be less than or equal to precision\");\n    }\n    // Handle zero dividend case\n    if (dividend === 0n) {\n        return {\n            quotient: 0n,\n            remainder: 0n,\n            isExact: true\n        };\n    }\n    // Work with absolute values for division\n    const isNegative = (dividend < 0n) !== (divisor < 0n);\n    const absDividend = getAbsoluteValue(dividend);\n    const absDivisor = getAbsoluteValue(divisor);\n    // Scale up the dividend to get the desired decimal places (use cached pow10)\n    const scaledDividend = absDividend * getPow10(scale);\n    // Perform integer division\n    let quotient = scaledDividend / absDivisor;\n    const remainder = scaledDividend % absDivisor;\n    // Check if division is exact\n    const isExact = remainder === 0n;\n    // Apply sign to quotient\n    if (isNegative) {\n        quotient = -quotient;\n    }\n    // Check for repeating decimals if not exact\n    let repeatingDigits;\n    if (!isExact && scale > 0) {\n        repeatingDigits = detectRepeatingDecimals(absDividend, absDivisor, scale, maxIterations);\n    }\n    // Ensure the result fits within precision constraints\n    const quotientStr = getAbsoluteValue(quotient).toString();\n    if (quotientStr.length > precision) {\n        // For division, we should truncate excess digits rather than trying to round\n        // This is because division can produce an infinite number of digits\n        const excessDigits = quotientStr.length - precision;\n        if (excessDigits <= scale) {\n            // We can truncate from the fractional part\n            const divisor = 10n ** BigInt(excessDigits);\n            quotient = quotient / divisor;\n        }\n        else {\n            // Cannot fit within precision constraints\n            throw new DecimalError(`Division result exceeds precision limit (${precision}). ` +\n                `Result has ${quotientStr.length} digits, but precision is ${precision}.`);\n        }\n    }\n    return {\n        quotient,\n        remainder: isNegative ? -remainder : remainder,\n        isExact,\n        repeatingDigits\n    };\n}\n/**\n * Aligns two decimal operands to have the same scale for arithmetic operations.\n * Scales up the operand with the smaller scale to match the larger scale.\n *\n * @param aCoefficient First operand coefficient\n * @param aScale Scale of the first operand\n * @param bCoefficient Second operand coefficient\n * @param bScale Scale of the second operand\n * @param maxScale Optional maximum scale to limit the result scale (default: no limit)\n * @param roundingMode The rounding mode to use when scaling down ('round', 'ceil', 'floor')\n * @returns An AlignedOperands object with aligned coefficients and the target scale\n */\nexport function alignOperands(aCoefficient, aScale, bCoefficient, bScale, maxScale, roundingMode = 'round') {\n    // Handle zero operands\n    if (aCoefficient === 0n) {\n        return {\n            a: 0n,\n            b: bCoefficient,\n            targetScale: bScale,\n            scaleAdjustment: 0\n        };\n    }\n    if (bCoefficient === 0n) {\n        return {\n            a: aCoefficient,\n            b: 0n,\n            targetScale: aScale,\n            scaleAdjustment: 0\n        };\n    }\n    // Determine target scale (the larger of the two scales)\n    let targetScale = Math.max(aScale, bScale);\n    // Apply maximum scale constraint if provided\n    if (maxScale !== undefined && targetScale > maxScale) {\n        targetScale = maxScale;\n    }\n    // Calculate scale adjustments\n    const aAdjustment = targetScale - aScale;\n    const bAdjustment = targetScale - bScale;\n    // Scale up operands as needed\n    let adjustedA = aCoefficient;\n    let adjustedB = bCoefficient;\n    if (aAdjustment > 0) {\n        adjustedA = scaleUp(aCoefficient, aAdjustment);\n    }\n    if (bAdjustment > 0) {\n        adjustedB = scaleUp(bCoefficient, bAdjustment);\n    }\n    // If maxScale is less than either original scale, we need to scale down\n    if (maxScale !== undefined) {\n        if (aScale > maxScale) {\n            // Use the specified rounding mode\n            switch (roundingMode) {\n                case 'round':\n                    adjustedA = roundHalfUp(aCoefficient, aScale, maxScale);\n                    break;\n                case 'ceil':\n                    adjustedA = ceilRound(aCoefficient, aScale, maxScale);\n                    break;\n                case 'floor':\n                    adjustedA = floorRound(aCoefficient, aScale, maxScale);\n                    break;\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n        if (bScale > maxScale) {\n            // Use the specified rounding mode\n            switch (roundingMode) {\n                case 'round':\n                    adjustedB = roundHalfUp(bCoefficient, bScale, maxScale);\n                    break;\n                case 'ceil':\n                    adjustedB = ceilRound(bCoefficient, bScale, maxScale);\n                    break;\n                case 'floor':\n                    adjustedB = floorRound(bCoefficient, bScale, maxScale);\n                    break;\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n    }\n    return {\n        a: adjustedA,\n        b: adjustedB,\n        targetScale,\n        scaleAdjustment: Math.max(aAdjustment, bAdjustment)\n    };\n}\n/**\n * Detects repeating decimals in division operation.\n * Uses the standard long division algorithm to identify repeating patterns.\n *\n * @param dividend The dividend (absolute value)\n * @param divisor The divisor (absolute value)\n * @param scale The desired scale (decimal places)\n * @param maxIterations Maximum iterations to detect repeating pattern\n * @returns The repeating decimal digits as a string, or undefined if no repeating pattern found\n */\nfunction detectRepeatingDecimals(dividend, divisor, scale, maxIterations) {\n    // First, get the integer part out of the way\n    const integerPart = dividend / divisor;\n    let remainder = dividend % divisor;\n    // If remainder is zero, there's no repeating decimal\n    if (remainder === 0n) {\n        return undefined;\n    }\n    // Track remainders to detect cycles\n    const remainders = new Map();\n    let fractionalDigits = '';\n    let position = 0;\n    // Perform long division algorithm\n    while (remainder !== 0n && position < maxIterations) {\n        // Scale up remainder by 10\n        remainder = remainder * 10n;\n        // Store the current remainder and position\n        const remainderKey = remainder.toString();\n        if (remainders.has(remainderKey)) {\n            // Found a repeating pattern\n            const cycleStart = remainders.get(remainderKey);\n            return fractionalDigits.substring(cycleStart);\n        }\n        remainders.set(remainderKey, position);\n        // Calculate next digit and remainder\n        const digit = remainder / divisor;\n        remainder = remainder % divisor;\n        // Add digit to fractional part\n        fractionalDigits += digit.toString();\n        position++;\n    }\n    // If we've reached max iterations without finding a cycle,\n    // we can't determine if there's a repeating pattern\n    return undefined;\n} /**\n\n * RDBMS-compliant precision and scale calculation result\n */\n/**\n * Calculates the result precision and scale for addition/subtraction operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Addition/Subtraction:\n * - Result Scale = max(scale1, scale2)\n * - Result Precision = max(precision1 - scale1, precision2 - scale2) + result_scale + 1\n *\n * The +1 accounts for potential carry in addition or borrow in subtraction.\n *\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateAdditionResultPrecisionScale(precision1, scale1, precision2, scale2) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Calculate result scale (maximum of input scales)\n    const resultScale = Math.max(scale1, scale2);\n    // Calculate integer digits for each operand\n    const integerDigits1 = precision1 - scale1;\n    const integerDigits2 = precision2 - scale2;\n    // Calculate result precision\n    // max(integer_digits) + result_scale + 1 (for potential carry/borrow)\n    const maxIntegerDigits = Math.max(integerDigits1, integerDigits2);\n    const resultPrecision = maxIntegerDigits + resultScale + 1;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Calculates the result precision and scale for multiplication operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Multiplication:\n * - Result Scale = scale1 + scale2\n * - Result Precision = precision1 + precision2 + 1\n *\n * The +1 accounts for potential overflow in multiplication.\n *\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateMultiplicationResultPrecisionScale(precision1, scale1, precision2, scale2) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Calculate result scale (sum of input scales)\n    const resultScale = scale1 + scale2;\n    // Calculate result precision (sum of input precisions + 1 for overflow)\n    const resultPrecision = precision1 + precision2 + 1;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Calculates the result precision and scale for division operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Division (varies by system, this follows common approach):\n * - Result Scale = max(6, scale1 + precision2 + 1)\n * - Result Precision = precision1 - scale1 + scale2 + max(6, scale1 + precision2 + 1)\n *\n * Different RDBMS systems handle division differently:\n * - SQL Server: Uses a complex formula with minimum scale of 6\n * - PostgreSQL: Uses configurable precision\n * - Oracle: Uses maximum available precision\n *\n * This implementation follows a conservative approach similar to SQL Server.\n *\n * @param precision1 Precision of dividend\n * @param scale1 Scale of dividend\n * @param precision2 Precision of divisor\n * @param scale2 Scale of divisor\n * @param minScale Minimum scale for result (default: 6, following SQL Server)\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateDivisionResultPrecisionScale(precision1, scale1, precision2, scale2, minScale = 6) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    if (minScale < 0) {\n        throw new DecimalError('Minimum scale must be non-negative');\n    }\n    // Calculate result scale\n    const calculatedScale = scale1 + precision2 + 1;\n    const resultScale = Math.max(minScale, calculatedScale);\n    // Calculate result precision\n    const integerDigits1 = precision1 - scale1;\n    const resultPrecision = integerDigits1 + scale2 + resultScale;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Validates that the calculated precision and scale are within reasonable limits\n * and adjusts them if necessary to prevent overflow or excessive memory usage.\n *\n * @param precision The calculated precision\n * @param scale The calculated scale\n * @param maxPrecision Maximum allowed precision (default: 38, SQL Server limit)\n * @param maxScale Maximum allowed scale (default: same as maxPrecision)\n * @returns Adjusted RdbmsArithmeticResult within limits\n * @throws DecimalError if the result cannot be represented within limits\n */\nexport function validateAndAdjustPrecisionScale(precision, scale, maxPrecision = 38, maxScale) {\n    const effectiveMaxScale = maxScale ?? maxPrecision;\n    // Validate basic constraints\n    if (precision <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale > precision) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Check if within limits\n    if (precision <= maxPrecision && scale <= effectiveMaxScale) {\n        return { precision, scale };\n    }\n    // Adjust if exceeding limits\n    let adjustedPrecision = Math.min(precision, maxPrecision);\n    let adjustedScale = Math.min(scale, effectiveMaxScale);\n    // Ensure scale doesn't exceed adjusted precision\n    if (adjustedScale > adjustedPrecision) {\n        // Prioritize scale, but ensure we have at least 1 integer digit\n        adjustedScale = Math.max(0, adjustedPrecision - 1);\n    }\n    // Ensure we have at least 1 integer digit\n    if (adjustedScale >= adjustedPrecision) {\n        adjustedScale = Math.max(0, adjustedPrecision - 1);\n    }\n    return {\n        precision: adjustedPrecision,\n        scale: adjustedScale\n    };\n}\n/**\n * Determines the appropriate precision and scale for a decimal result\n * based on the operation type and operand characteristics.\n *\n * This is a convenience function that combines the specific calculation\n * functions with validation and adjustment.\n *\n * @param operation The arithmetic operation type\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @param options Optional configuration for limits and division behavior\n * @returns RdbmsArithmeticResult with final precision and scale\n */\nexport function calculateRdbmsArithmeticResult(operation, precision1, scale1, precision2, scale2, options) {\n    let result;\n    // Calculate based on operation type\n    switch (operation) {\n        case 'add':\n        case 'subtract':\n            result = calculateAdditionResultPrecisionScale(precision1, scale1, precision2, scale2);\n            break;\n        case 'multiply':\n            result = calculateMultiplicationResultPrecisionScale(precision1, scale1, precision2, scale2);\n            break;\n        case 'divide':\n            result = calculateDivisionResultPrecisionScale(precision1, scale1, precision2, scale2, options?.divisionMinScale);\n            break;\n        default:\n            throw new DecimalError(`Unsupported operation: ${operation}`);\n    }\n    // Validate and adjust if necessary\n    return validateAndAdjustPrecisionScale(result.precision, result.scale, options?.maxPrecision, options?.maxScale);\n}\n","// Decimal.ts\n// A high-precision decimal number implementation with controlled rounding behaviors\nimport { alignOperands, formatBigIntAsDecimal, roundHalfUp, ceilRound, floorRound, validatePrecisionScale, calculateRdbmsArithmeticResult, scaleUp, getPow10 } from './decimal-utils';\nexport class DecimalError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DecimalError\";\n    }\n}\nclass Decimal {\n    /**\n     * Constructs a Decimal instance by parsing the input value.\n     *\n     * Constructor behavior varies based on input type:\n     *\n     * 1. String input:\n     *    - If precision/scale not provided: Infers from string format\n     *    - If precision/scale provided: Validates and formats according to specs\n     *    Example: new Decimal(\"123.45\") or new Decimal(\"123.45\", 5, 2)\n     *\n     * 2. Decimal input (conversion):\n     *    - If precision/scale not provided: Inherits from source Decimal\n     *    - If precision/scale provided: Adjusts value to match new precision/scale\n     *    Example: new Decimal(existingDecimal) or new Decimal(existingDecimal, 5, 2)\n     *\n     * 3. Number input:\n     *    - Always requires precision and scale parameters\n     *    Example: new Decimal(123.45, 5, 2)\n     *\n     * @param value The value to initialize the Decimal with (string, number, or Decimal)\n     * @param precision The total number of significant digits (M)\n     * @param scale The number of digits after the decimal point (D)\n     * @throws {DecimalError} If value format is invalid or precision/scale constraints are violated\n     */\n    constructor(value, precision, scale) {\n        // Initialize with default values to satisfy TypeScript\n        this.coefficient = 0n;\n        this.exponent = 0;\n        // Infer or validate precision and scale based on input type\n        [precision, scale] = this.resolvePrecisionAndScale(value, precision, scale);\n        // Store the precision and scale\n        this.precision = precision;\n        this.scale = scale;\n        // Validate scale and precision relationship\n        this.validatePrecisionAndScale(precision, scale);\n        // Initialize the decimal based on the input type\n        let decimalInit;\n        if (typeof value === 'string') {\n            decimalInit = this.initFromString(value, precision, scale);\n        }\n        else if (typeof value === 'number') {\n            decimalInit = this.initFromNumber(value, precision, scale);\n        }\n        else if (value instanceof Decimal) {\n            decimalInit = this.initFromDecimal(value, precision, scale);\n        }\n        else {\n            throw new DecimalError(\"Unsupported value type for Decimal constructor.\");\n        }\n        // Assign the computed coefficient and exponent\n        this.coefficient = decimalInit.coefficient;\n        this.exponent = decimalInit.exponent;\n    }\n    /**\n     * Resolves precision and scale values based on the input type.\n     * For strings, infers from the string if not provided.\n     * For Decimal instances, inherits from source if not provided.\n     * For numbers, ensures both are provided.\n     *\n     * @private\n     */\n    resolvePrecisionAndScale(value, precision, scale) {\n        if (typeof value === 'number') {\n            if (precision === undefined || scale === undefined) {\n                throw new DecimalError(\"Precision and scale must be provided for number type.\");\n            }\n            return [precision, scale];\n        }\n        if (value instanceof Decimal) {\n            if (precision === undefined || scale === undefined) {\n                precision = value.getPrecision();\n                scale = value.getScale();\n            }\n            return [precision, scale];\n        }\n        if (typeof value === 'string') {\n            if (precision === undefined || scale === undefined) {\n                // Infer precision and scale from string\n                const regex = /^-?(\\d+)(?:\\.(\\d+))?$/;\n                const match = value.trim().match(regex);\n                if (!match) {\n                    throw new DecimalError(\"Invalid decimal string format.\");\n                }\n                const integerPart = match[1];\n                const fractionalPart = match[2] || '';\n                precision = integerPart.length + fractionalPart.length;\n                scale = fractionalPart.length;\n            }\n            return [precision, scale];\n        }\n        throw new DecimalError(\"Unsupported value type for Decimal constructor.\");\n    }\n    /**\n     * Validates that scale is less than or equal to precision.\n     * @private\n     */\n    validatePrecisionAndScale(precision, scale) {\n        // Use the utility function for validation\n        const result = validatePrecisionScale(1n, precision, scale); // Coefficient doesn't matter for parameter validation\n        if (!result.valid) {\n            throw new DecimalError(result.reason || \"Invalid precision or scale\");\n        }\n    }\n    /**\n     * Initializes a Decimal from a string value.\n     * @private\n     */\n    initFromString(value, precision, scale) {\n        // Validate string format\n        if (!Decimal.isValidDecimal(value)) {\n            throw new DecimalError(\"Invalid decimal string format.\");\n        }\n        // Parse the string into components\n        const { sign, integerPart, fractionalPart } = Decimal.parseString(value);\n        // Process the fractional part with potential rounding\n        let adjustedInteger = integerPart;\n        let adjustedFractional = fractionalPart;\n        // Process rounding if needed\n        if (fractionalPart.length > scale) {\n            const rounded = Decimal.roundForDecimal(integerPart + '.' + fractionalPart, precision, scale);\n            adjustedInteger = rounded.integerPart;\n            adjustedFractional = rounded.fractionalPart;\n        }\n        else {\n            // Pad with zeros if needed\n            adjustedFractional = fractionalPart.padEnd(scale, '0');\n        }\n        // Normalize integer part by removing leading zeros\n        const normalizedInteger = adjustedInteger.replace(/^0+/, '') || '0';\n        // Combine integer and fractional parts for coefficient\n        const combined = normalizedInteger + adjustedFractional;\n        // Remove leading zeros from combined (except when value is zero)\n        const combinedNormalized = combined.replace(/^0+/, '') || '0';\n        // Calculate total digits and validate precision\n        if (combinedNormalized.length > precision) {\n            // Try rounding to fit precision at the target scale\n            const rounded = Decimal.roundForDecimal(normalizedInteger + '.' + adjustedFractional, precision, scale);\n            const roundedCombined = rounded.integerPart + rounded.fractionalPart;\n            // If after rounding the significant digits still exceed precision, throw\n            if (roundedCombined.replace(/^0+/, '').length > precision) {\n                throw new DecimalError(`Value '${value}' exceeds specified precision (${precision}) after rounding.`);\n            }\n            const coeff = BigInt(roundedCombined);\n            return {\n                coefficient: sign === '-' ? -coeff : coeff,\n                exponent: scale\n            };\n        }\n        // Convert to BigInt with sign\n        const coeff = BigInt(combinedNormalized);\n        return {\n            coefficient: sign === '-' ? -coeff : coeff,\n            exponent: scale\n        };\n    }\n    /**\n     * Initializes a Decimal from a number value.\n     * @private\n     */\n    initFromNumber(value, precision, scale) {\n        // Convert number to string and reuse string initialization logic\n        return this.initFromString(value.toString(), precision, scale);\n    }\n    /**\n     * Initializes a Decimal from an existing Decimal instance.\n     * @private\n     */\n    initFromDecimal(value, precision, scale) {\n        const fromPrecision = value.getPrecision();\n        const fromScale = value.getScale();\n        const fromCoefficient = value.getCoefficient();\n        // Calculate integer part capacity\n        const targetIntegerDigits = precision - scale;\n        // Determine actual integer digits used\n        const valueStr = value.toString();\n        const actualIntegerDigits = valueStr.split('.')[0].replace('-', '').length;\n        // Ensure integer part fits in target precision-scale\n        if (actualIntegerDigits > targetIntegerDigits) {\n            throw new DecimalError(`Cannot adjust precision: integer part needs ${actualIntegerDigits} digits, ` +\n                `but target precision-scale only allows ${targetIntegerDigits}.`);\n        }\n        // Handle scale adjustments\n        if (scale > fromScale) {\n            return this.increaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient);\n        }\n        else if (scale < fromScale) {\n            return this.decreaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient);\n        }\n        else {\n            return this.sameScaleForDecimal(value, precision, scale, fromCoefficient);\n        }\n    }\n    /**\n     * Handles increasing the scale when converting from one Decimal to another.\n     * @private\n     */\n    increaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient) {\n        // Scale increase: pad with zeros using util\n        const scaleDifference = scale - fromScale;\n        const newCoefficient = scaleUp(fromCoefficient, scaleDifference);\n        // Verify the new coefficient fits within precision\n        const newCoeffStr = newCoefficient.toString().replace('-', '');\n        if (newCoeffStr.length > precision) {\n            throw new DecimalError(`Value exceeds the specified precision (${precision}) after scaling.`);\n        }\n        return {\n            coefficient: newCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Handles decreasing the scale when converting from one Decimal to another.\n     * @private\n     */\n    decreaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient) {\n        // Scale decrease: use util roundHalfUp\n        const roundedCoefficient = roundHalfUp(fromCoefficient, fromScale, scale);\n        // Update precision to match resultant digits\n        const roundedStr = roundedCoefficient.toString().replace('-', '');\n        precision = roundedStr.length;\n        return {\n            coefficient: roundedCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Handles keeping the same scale when converting from one Decimal to another.\n     * @private\n     */\n    sameScaleForDecimal(value, precision, scale, fromCoefficient) {\n        // Same scale, just verify precision\n        if (value.getTotalDigits() > precision) {\n            throw new DecimalError(`Value exceeds the specified precision (${precision}).`);\n        }\n        return {\n            coefficient: fromCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Special rounding implementation specifically for the Decimal constructor.\n     * Ensures correct rounding behavior for all cases including edge cases.\n     * @private\n     */\n    static roundForDecimal(value, _precision, targetScale) {\n        // Parse into parts (positive only; sign handled by caller)\n        const [intRaw = '0', fracRaw = ''] = value.split('.');\n        const currentScale = fracRaw.length;\n        // Build coefficient (no sign)\n        const coeff = BigInt((intRaw || '0') + (fracRaw || ''));\n        // Adjust scale using canonical roundHalfUp\n        const adjusted = roundHalfUp(coeff, currentScale, targetScale);\n        // Format via canonical formatter and split\n        const formatted = formatBigIntAsDecimal(adjusted, targetScale);\n        const [integerPart, fractionalPart = ''] = formatted.split('.');\n        return { integerPart, fractionalPart };\n    }\n    /**\n     * Returns the number of significant digits (excluding sign).\n     * @private\n     */\n    getTotalDigits() {\n        return this.coefficient.toString().replace('-', '').length;\n    }\n    /**\n     * Validates if a string is a valid decimal format.\n     * @param str The string to validate.\n     * @returns True if valid, else false.\n     */\n    static isValidDecimal(str) {\n        // Trim leading/trailing whitespace\n        let trimmed = str.trim();\n        // Remove trailing 'm' if present (like \"123.45m\")\n        if (trimmed.endsWith('m')) {\n            trimmed = trimmed.slice(0, -1);\n        }\n        // Match standard decimal formats including scientific notation\n        const regex = /^[+\\-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$/;\n        return regex.test(trimmed);\n    }\n    /**\n     * Parses the string into sign, integer part, and fractional part.\n     * Handles scientific notation and normalization.\n     * @param str The string to parse.\n     * @returns An object containing sign, integerPart, and fractionalPart.\n     */\n    static parseString(str) {\n        let trimmed = str.trim();\n        // Remove trailing 'm' if present (like \"123.45m\")\n        if (trimmed.endsWith('m')) {\n            trimmed = trimmed.slice(0, -1);\n        }\n        let sign = '';\n        // Handle sign\n        if (trimmed.startsWith('-')) {\n            sign = '-';\n            trimmed = trimmed.slice(1);\n        }\n        else if (trimmed.startsWith('+')) {\n            trimmed = trimmed.slice(1);\n        }\n        // Split into mantissa and exponent parts\n        const [mantissa, exponentPart] = trimmed.split(/[eE]/);\n        const exponent = exponentPart ? parseInt(exponentPart, 10) : 0;\n        // Split mantissa into integer and fractional parts\n        const [integerPartRaw, fractionalPartRaw = ''] = mantissa.split('.');\n        let integerPart = integerPartRaw || '0';\n        let fractionalPart = fractionalPartRaw;\n        // Adjust for exponent\n        if (exponent > 0) {\n            // Positive exponent moves decimal point right\n            if (fractionalPart.length > exponent) {\n                integerPart += fractionalPart.slice(0, exponent);\n                fractionalPart = fractionalPart.slice(exponent);\n            }\n            else {\n                integerPart += fractionalPart.padEnd(exponent, '0');\n                fractionalPart = '';\n            }\n        }\n        else if (exponent < 0) {\n            // Negative exponent moves decimal point left\n            const absExp = Math.abs(exponent);\n            if (integerPart.length > absExp) {\n                fractionalPart = integerPart.slice(-absExp) + fractionalPart;\n                integerPart = integerPart.slice(0, -absExp);\n            }\n            else {\n                fractionalPart = integerPart.padStart(absExp, '0') + fractionalPart;\n                integerPart = '0';\n            }\n        }\n        return { sign, integerPart, fractionalPart };\n    }\n    /**\n     * Converts the input value to a Decimal instance.\n     * @param value The value to convert to a Decimal.\n     * @returns A Decimal instance.\n     * @throws {DecimalError} If the value cannot be converted to a Decimal.\n     */\n    static ensureDecimal(value) {\n        if (value instanceof Decimal) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            return new Decimal(value.toString());\n        }\n        if (typeof value === 'string') {\n            return new Decimal(value);\n        }\n        throw new DecimalError(`Unsupported value type for Decimal conversion: ${typeof value}`);\n    }\n    /**\n     * Converts the Decimal instance to a JavaScript Number.\n     * @returns The numeric representation.\n     * @throws {DecimalError} If the conversion results in infinity.\n     */\n    toNumber() {\n        const sign = this.coefficient < 0n ? '-' : '';\n        let absCoeffStr = (this.coefficient < 0n ? -this.coefficient : this.coefficient).toString();\n        // For integers, directly convert\n        if (this.exponent === 0) {\n            return Number(`${sign}${absCoeffStr}`);\n        }\n        // For decimals, format appropriately\n        while (absCoeffStr.length <= this.exponent) {\n            absCoeffStr = '0' + absCoeffStr;\n        }\n        const integerPart = absCoeffStr.slice(0, -this.exponent) || '0';\n        const fractionalPart = absCoeffStr.slice(-this.exponent);\n        const numberStr = `${sign}${integerPart}.${fractionalPart}`;\n        const numberValue = Number(numberStr);\n        // Safe check for overflow\n        if (!isFinite(numberValue)) {\n            throw new DecimalError(\"Conversion to Number results in Infinity.\");\n        }\n        return numberValue;\n    }\n    /**\n     * Compares this Decimal instance with another.\n     * @param other The other Decimal to compare with.\n     * @returns 1 if greater, -1 if less, 0 if equal.\n     * @throws {DecimalError} If decimals have different precision or scale.\n     */\n    compareTo(other) {\n        // Ensure same precision and scale\n        if (this.precision !== other.precision || this.scale !== other.scale) {\n            throw new DecimalError(\"Decimals must have the same precision and scale for comparison.\");\n        }\n        if (this.coefficient === other.coefficient)\n            return 0;\n        return this.coefficient > other.coefficient ? 1 : -1;\n    }\n    /**\n     * Compares the structure of this Decimal with another.\n     * The structure is defined by precision and scale.\n     * @param other The other Decimal to compare.\n     * @returns True if the structure is the same, else false.\n     */\n    compareStructure(other) {\n        return this.precision === other.precision && this.scale === other.scale;\n    }\n    /**\n     * Checks if this Decimal is equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if equal, else false.\n     */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Checks if this Decimal is less than another.\n     * @param other The other Decimal to compare with.\n     * @returns True if less, else false.\n     */\n    lessThan(other) {\n        return this.compareTo(other) === -1;\n    }\n    /**\n     * Checks if this Decimal is greater than another.\n     * @param other The other Decimal to compare with.\n     * @returns True if greater, else false.\n     */\n    greaterThan(other) {\n        return this.compareTo(other) === 1;\n    }\n    /**\n     * Checks if this Decimal is less than or equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if less than or equal, else false.\n     */\n    lessThanOrEqual(other) {\n        return this.compareTo(other) <= 0;\n    }\n    /**\n     * Checks if this Decimal is greater than or equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if greater than or equal, else false.\n     */\n    greaterThanOrEqual(other) {\n        return this.compareTo(other) >= 0;\n    }\n    /**\n     * Returns the string representation of the Decimal.\n     * @returns The normalized string representation.\n     */\n    toString() {\n        return formatBigIntAsDecimal(this.coefficient, this.scale);\n    }\n    /**\n     * Gets the total number of significant digits.\n     * @returns The precision value.\n     */\n    getPrecision() {\n        return this.precision;\n    }\n    /**\n     * Gets the number of fractional digits.\n     * @returns The scale value.\n     */\n    getScale() {\n        return this.scale;\n    }\n    /**\n     * Gets the exponent (same as scale for this implementation).\n     * @returns The exponent value.\n     */\n    getExponent() {\n        return this.exponent;\n    }\n    /**\n     * Gets the internal coefficient (scaled integer representation).\n     * @returns The coefficient as a BigInt.\n     */\n    getCoefficient() {\n        return this.coefficient;\n    }\n    /**\n     * Gets the format pattern representing the precision and scale.\n     * @returns A string representing the format pattern (e.g., \"xxx.xx\").\n     */\n    getFormatPattern() {\n        const precision = 'x'.repeat(this.precision - this.scale);\n        const scale = 'x'.repeat(this.scale);\n        return this.scale > 0 ? `${precision}.${scale}` : `${precision}`;\n    }\n    /**\n     * Converts this Decimal to a new Decimal with the specified precision and scale.\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale\n     * @throws {DecimalError} If conversion is not possible due to precision constraints\n     */\n    convert(targetPrecision, targetScale) {\n        // Validate that the target scale doesn't exceed the target precision\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        try {\n            // Use the existing constructor logic to handle precision and scale conversion\n            return new Decimal(this, targetPrecision, targetScale);\n        }\n        catch (error) {\n            // Re-throw the error for clarity\n            if (error instanceof DecimalError) {\n                throw error;\n            }\n            // Wrap any other unexpected errors\n            throw new DecimalError(`Conversion failed: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using round-half-up behavior.\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using round-half-up\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    round(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient to the target scale\n        const roundedCoeff = roundHalfUp(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(roundedCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using ceiling behavior (always round up).\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using ceiling\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    ceil(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient using ceiling behavior\n        const ceiledCoeff = ceilRound(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(ceiledCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using floor behavior (always round down).\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using floor\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    floor(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient using floor behavior\n        const flooredCoeff = floorRound(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(flooredCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Computes the modulo (remainder) of this Decimal by another Decimal.\n     * Uses truncation toward zero for the quotient (RDBMS-like), so the remainder has the same sign as the dividend.\n     * Result scale is max(scale1, scale2).\n     * @param other The Decimal divisor\n     * @returns A new Decimal representing (this % other)\n     */\n    mod(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        if (other.coefficient === 0n)\n            throw new DecimalError('Division by zero');\n        // Align both operands to a common scale T = max(s1, s2) without losing precision\n        const { a: aCoeff, b: bCoeff, targetScale } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale);\n        // Integer division with truncation toward zero (BigInt division semantics)\n        const q = aCoeff / bCoeff;\n        const remainderCoeff = aCoeff - q * bCoeff;\n        // Determine precision from actual digits\n        const digits = remainderCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(digits, this.precision, other.precision);\n        const resultStr = formatBigIntAsDecimal(remainderCoeff, targetScale);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n    /**\n     * Adds this Decimal to another and returns a new Decimal.\n     * The result will match the scale of the first operand (this), and will be rounded if necessary.\n     * @param other The Decimal to add.\n     * @returns A new Decimal representing the sum, rounded to this.scale.\n     */\n    /**\n * Adds this Decimal to another and returns a new Decimal.\n * The result will match the scale of the first operand (this), and will be rounded if necessary.\n * @param other The Decimal to add.\n * @returns A new Decimal representing the sum, rounded to this.scale.\n */\n    /**\n * Adds this Decimal to another and returns a new Decimal.\n * The result will match the scale of the first operand (this), and will be rounded if necessary.\n * @param other The Decimal to add.\n * @returns A new Decimal representing the sum, rounded to this.scale.\n */\n    add(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // RDBMS addition: resultScale = max(s1, s2); resultPrecision per standard\n        const { precision: calcPrecision, scale: calcScale } = calculateRdbmsArithmeticResult('add', this.precision, this.scale, other.precision, other.scale, { maxPrecision: 10000, maxScale: 10000 });\n        // Align operands to calcScale\n        const { a: aCoeff, b: bCoeff } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale, calcScale, 'round');\n        // Add aligned coefficients\n        const sumCoeff = aCoeff + bCoeff;\n        // Determine final precision: accommodate actual digits if they exceed calcPrecision\n        const digits = sumCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(calcPrecision, digits);\n        // Format and construct\n        const resultStr = formatBigIntAsDecimal(sumCoeff, calcScale);\n        return new Decimal(resultStr, finalPrecision, calcScale);\n    }\n    /**\n     * Subtracts another Decimal from this and returns a new Decimal.\n     * The result will match the scale of the first operand (this), and will be rounded if necessary.\n     * @param other The Decimal to subtract.\n     * @returns A new Decimal representing the difference, rounded to this.scale.\n     */\n    sub(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // RDBMS subtraction: use utility to determine result precision/scale\n        const { precision: calcPrecision, scale: calcScale } = calculateRdbmsArithmeticResult('subtract', this.precision, this.scale, other.precision, other.scale, { maxPrecision: 10000, maxScale: 10000 });\n        // Align operands to calcScale\n        const { a: aCoeff, b: bCoeff } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale, calcScale, 'round');\n        // Subtract aligned coefficients\n        const diffCoeff = aCoeff - bCoeff;\n        // Determine final precision: accommodate actual digits if they exceed calcPrecision\n        const digits = diffCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(calcPrecision, digits);\n        // Format and construct\n        const resultStr = formatBigIntAsDecimal(diffCoeff, calcScale);\n        return new Decimal(resultStr, finalPrecision, calcScale);\n    }\n    /**\n     * Multiplies this Decimal by another and returns a new Decimal.\n     * Uses utility functions for scale operations and rounding.\n     * The result scale follows RDBMS standard: max(scale1, scale2).\n     * @param other The Decimal to multiply by.\n     * @returns A new Decimal representing the product with RDBMS-compliant scale.\n     */\n    mul(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // Multiply coefficients directly using BigInt arithmetic\n        const resultCoeff = this.coefficient * other.coefficient;\n        const intermediateScale = this.scale + other.scale;\n        // Tests expect result scale to be max(s1, s2)\n        const targetScale = Math.max(this.scale, other.scale);\n        // Adjust result to target scale\n        let adjustedCoeff = resultCoeff;\n        if (intermediateScale > targetScale) {\n            adjustedCoeff = roundHalfUp(resultCoeff, intermediateScale, targetScale);\n        }\n        else if (intermediateScale < targetScale) {\n            adjustedCoeff = scaleUp(resultCoeff, targetScale - intermediateScale);\n        }\n        // Compute appropriate precision\n        const resultDigits = adjustedCoeff.toString().replace('-', '').length;\n        let finalPrecision = Math.max(this.precision, other.precision, resultDigits);\n        if (resultDigits > finalPrecision)\n            finalPrecision = resultDigits;\n        const resultStr = formatBigIntAsDecimal(adjustedCoeff, targetScale);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n    /**\n     * Divides this Decimal by another and returns a new Decimal.\n     * The result will match the scale of the dividend (this), and will be rounded if necessary.\n     * This behavior is consistent with industry standards and ensures predictable precision.\n     * @param other The Decimal to divide by.\n     * @returns A new Decimal representing the quotient, rounded to this.scale.\n     */\n    div(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        if (other.coefficient === 0n)\n            throw new DecimalError('Division by zero');\n        // Tests expect result scale to follow the divisor's scale\n        const targetScale = other.scale;\n        // Compute numerator scaling: coeffA * 10^(targetScale + sB - sA)\n        const exponentAdjustment = targetScale + other.scale - this.scale;\n        let numerator;\n        if (exponentAdjustment >= 0) {\n            numerator = this.coefficient * getPow10(exponentAdjustment);\n        }\n        else {\n            const down = getPow10(-exponentAdjustment);\n            numerator = this.coefficient / down;\n        }\n        const denominator = other.coefficient;\n        let quotient = numerator / denominator;\n        let remainder = numerator % denominator;\n        // Round half up from remainder using the true sign of the result\n        const absDen = denominator < 0n ? -denominator : denominator;\n        const absRem = remainder < 0n ? -remainder : remainder;\n        if (absRem * 2n >= absDen) {\n            const isNegative = (numerator < 0n) !== (denominator < 0n);\n            quotient += isNegative ? -1n : 1n;\n        }\n        const resultStr = formatBigIntAsDecimal(quotient, targetScale);\n        const digits = (quotient < 0n ? (-quotient).toString() : quotient.toString()).length;\n        const finalPrecision = Math.max(this.precision, other.precision, digits);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n}\nexport default Decimal;\n","import IOCollection from \"./collection\";\nimport IOObject from \"./internet-object\";\nclass IOSection {\n    constructor(data, name, _schemaName) {\n        this._data = data;\n        this._name = name;\n        this._schemaName = _schemaName;\n    }\n    get name() {\n        return this._name;\n    }\n    get schemaName() {\n        return this._schemaName;\n    }\n    get data() {\n        return this._data;\n    }\n    toJSON(options) {\n        // IOObject\n        if (this._data instanceof IOObject) {\n            return this._data.toJSON();\n        }\n        // IOCollection\n        else if (this._data instanceof IOCollection) {\n            return this._data.toJSON(options);\n        }\n        // Plain object\n        else if (this._data && typeof this._data === 'object') {\n            return this._data;\n        }\n        return null;\n    }\n}\nexport default IOSection;\n","class IOSectionCollection {\n    constructor() {\n        this._sections = [];\n        this._sectionNames = {};\n        return new Proxy(this, proxy);\n    }\n    get sections() {\n        return this._sections;\n    }\n    get length() {\n        return this._sections.length;\n    }\n    get(nameOrIndex) {\n        if (typeof nameOrIndex === 'string') {\n            const index = this._sectionNames[nameOrIndex];\n            if (index === undefined) {\n                return undefined;\n            }\n            return this._sections[index];\n        }\n        return this._sections[nameOrIndex];\n    }\n    push(section) {\n        if (section.name !== undefined) {\n            this._sectionNames[section.name] = this._sections.length;\n        }\n        this._sections.push(section);\n    }\n    /**\n     * Makes the IOSectionCollection iterable, yielding key-value pairs.\n     */\n    *[Symbol.iterator]() {\n        for (const section of this._sections) {\n            yield section;\n        }\n    }\n}\nconst proxy = {\n    get: (target, property) => {\n        if (property in target) {\n            return Reflect.get(target, property);\n        }\n        if (typeof property === 'string') {\n            if (/^[0-9]+$/.test(property)) {\n                return target.get(Number(property));\n            }\n            return target.get(property);\n        }\n    },\n    set: (target, property, value) => {\n        throw new Error('Cannot set a value on a IOSectionCollection');\n    }\n};\nexport default IOSectionCollection;\n","import InternetObjectError from \"./io-error\";\n/**\n * Represents the syntax error in InternetObject. When this error is thrwon,\n * it suggests that a syntax in the associated object is is not correct.\n */\nclass IOSyntaxError extends InternetObjectError {\n    /**\n     * Creates a new `IOSyntaxError` error.\n     * @param errorCode {string} An errorCode associated with is error\n     * @param message {string} The message which needs to be displayed\n     * @param node {Node} The node object, required while parsing raw internet-object data or schema\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     *\n     * @internal\n     */\n    constructor(errorCode, fact, posRange, isEof = false, ssf) {\n        super(errorCode, fact, posRange, isEof, ssf);\n        this.name = 'InternetObject(SyntaxError)';\n        this.updateMessage();\n    }\n}\nexport default IOSyntaxError;\n","class ContainerNode {\n    constructor(type, children = []) {\n        this.type = type;\n        this.children = children;\n    }\n    toValue(defs) {\n        return this.children.map((child) => {\n            if (child) {\n                return child.toValue(defs);\n            }\n            return undefined;\n        });\n    }\n}\nexport default ContainerNode;\n","import ContainerNode from \"./containers\";\nclass ArrayNode extends ContainerNode {\n    constructor(children = [], openBracket, closeBracket) {\n        super('array', children);\n        this.openBracket = openBracket;\n        this.closeBracket = closeBracket;\n    }\n    toValue(defs) {\n        return this.children.map((child) => {\n            if (child?.toValue) { // This is a Node\n                return child.toValue(defs);\n            }\n            return child; // other non-node values such null, undefined, etc.\n        });\n    }\n    getStartPos() {\n        return this.openBracket.getStartPos();\n    }\n    getEndPos() {\n        return this.closeBracket.getEndPos();\n    }\n}\nexport default ArrayNode;\n","class MemberNode {\n    constructor(value, key) {\n        this.type = 'member';\n        this.value = value;\n        if (key) {\n            this.key = key;\n        }\n    }\n    toValue(defs) {\n        if (this.key) {\n            return {\n                [this.key.value]: this.value.toValue(defs),\n            };\n        }\n        else {\n            return this.value.toValue(defs);\n        }\n    }\n    getStartPos() {\n        if (this.key) {\n            return this.key.getStartPos();\n        }\n        return this.value.getStartPos();\n    }\n    getEndPos() {\n        if (this.value) {\n            return this.value.getEndPos();\n        }\n        if (this.key) {\n            return this.key.getEndPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n}\nexport default MemberNode;\n","import InternetObject from '../../core/internet-object';\nimport ContainerNode from './containers';\nclass ObjectNode extends ContainerNode {\n    constructor(children = [], openBracket, closeBracket) {\n        super('object', children);\n        if (openBracket) {\n            this.openBracket = openBracket;\n        }\n        if (closeBracket) {\n            this.closeBracket = closeBracket;\n        }\n    }\n    toObject(defs) {\n        const value = {};\n        let index = 0;\n        for (const child of this.children) {\n            if (child && child.value) {\n                if (child.key) {\n                    value[child.key.value] = child.value.toValue(defs);\n                }\n                else {\n                    value[index] = child.value.toValue(defs);\n                }\n            }\n            else {\n                value[index] = undefined;\n            }\n            index++;\n        }\n        return value;\n    }\n    getStartPos() {\n        if (this.openBracket) {\n            return this.openBracket.getStartPos();\n        }\n        return this.children[0]?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        if (this.closeBracket) {\n            return this.closeBracket.getEndPos();\n        }\n        return this.children[this.children.length - 1]?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    toValue(defs) {\n        const o = new InternetObject();\n        for (let i = 0; i < this.children.length; i++) {\n            const member = this.children[i];\n            if (member && member.value) {\n                if (member.key) {\n                    // o[member.key.value] = member.value.toValue(defs);\n                    o.set(member.key.value, member.value.toValue(defs));\n                }\n                else {\n                    o.set(i.toString(), member.value.toValue(defs));\n                }\n            }\n        }\n        return o;\n    }\n    // Utility Methods\n    isEmpty() {\n        return this.children.length === 0 || this.children.every(child => child === undefined);\n    }\n    toDebugString() {\n        const memberStrings = this.children.map((child, index) => {\n            if (!child)\n                return `[${index}]: undefined`;\n            const member = child;\n            const keyStr = member.key ? member.key.value : `[${index}]`;\n            const valueStr = member.value ?\n                (typeof member.value.toValue === 'function' ?\n                    JSON.stringify(member.value.toValue()) :\n                    String(member.value)) :\n                'undefined';\n            return `${keyStr}: ${valueStr}`;\n        });\n        return `ObjectNode { ${memberStrings.join(', ')} }`;\n    }\n    hasKey(key) {\n        return this.children.some(child => {\n            if (!child)\n                return false;\n            const member = child;\n            return member.key && member.key.value === key;\n        });\n    }\n    getKeys() {\n        const keys = [];\n        this.children.forEach((child, index) => {\n            if (child) {\n                const member = child;\n                if (member.key) {\n                    keys.push(member.key.value);\n                }\n                else {\n                    keys.push(index.toString());\n                }\n            }\n        });\n        return keys;\n    }\n    isValid() {\n        // An object is valid if none of its members contain ErrorNodes\n        return this.children.every(child => {\n            if (!child)\n                return true; // undefined members are considered valid\n            const member = child;\n            // Check if the member value is an ErrorNode\n            if (member.value && member.value.error !== undefined) {\n                return false;\n            }\n            // Check if the member key is an ErrorNode (though this is less common)\n            if (member.key && member.key.error !== undefined) {\n                return false;\n            }\n            return true;\n        });\n    }\n}\nexport default ObjectNode;\n","import InternetObjectError from '../errors/io-error';\nimport ErrorCodes from '../errors/io-error-codes';\nclass TypedefRegistry {\n    /**\n     * Enable/disable console warnings on duplicate type registrations.\n     * Default is disabled to avoid noise and performance overhead in hot paths/tests.\n     */\n    static setWarnOnDuplicates(enable) {\n        this.warnDuplicates = enable;\n    }\n    /**\n     * Registers TypeDef constructors for the specified types.\n     * @param typeDefConstructors The TypeDef constructor classes\n     */\n    static register(...typeDefConstructors) {\n        for (const Constructor of typeDefConstructors) {\n            for (const type of Constructor.types) {\n                if (this.typeDefMap.has(type)) {\n                    if (this.warnDuplicates && !this.warnedDuplicateTypes.has(type)) {\n                        console.warn(`TypeDef for '${type}' is already registered. Skipping.`);\n                        this.warnedDuplicateTypes.add(type);\n                    }\n                    continue;\n                }\n                this.typeDefMap.set(type, new Constructor(type));\n                this.typeNames.add(type);\n            }\n        }\n    } /**\n     * Unregisters the specified type from the registry.\n     * @param type The type name to unregister\n     */\n    static unregister(type) {\n        if (this.typeDefMap.has(type)) {\n            this.typeDefMap.delete(type);\n            this.typeNames.delete(type);\n        }\n    }\n    /**\n     * Gets the array of registered type names.\n     */\n    static get types() {\n        return Object.freeze(Array.from(this.typeNames));\n    }\n    /**\n     * Returns the associated TypeDef object for the specified type.\n     * @param type The registered type name\n     * @throws {InternetObjectError} When the type is not registered\n     */\n    static get(type) {\n        const typeDef = this.typeDefMap.get(type);\n        if (!typeDef) {\n            throw new InternetObjectError(ErrorCodes.invalidType, `Type '${type}' is not registered`);\n        }\n        return typeDef;\n    }\n    /**\n     * Checks if the specified type is registered.\n     * @param typeName The type name to check\n     */\n    static isRegisteredType(typeName) {\n        return this.typeDefMap.has(typeName);\n    }\n    /**\n     * Clears all registered types. Primarily for testing.\n     */\n    static clear() {\n        this.typeDefMap.clear();\n        this.typeNames.clear();\n        this.warnedDuplicateTypes.clear();\n    }\n    /**\n     * Gets the count of registered types.\n     */\n    static get count() {\n        return this.typeDefMap.size;\n    }\n}\nTypedefRegistry.typeDefMap = new Map();\nTypedefRegistry.typeNames = new Set();\nTypedefRegistry.warnDuplicates = false;\nTypedefRegistry.warnedDuplicateTypes = new Set();\nexport default TypedefRegistry;\n","import TypedefRegistry from '../typedef-registry';\nexport function processMember(member, memberDef, defs) {\n    const typeDef = TypedefRegistry.get(memberDef.type);\n    if (!typeDef) {\n        throw new Error(`Type ${memberDef.type} is not registered.`);\n    }\n    let valueNode = member?.value;\n    return typeDef.parse(valueNode, memberDef, defs);\n}\n","import InternetObject from '../core/internet-object';\nimport ErrorCodes from '../errors/io-error-codes';\nimport SyntaxError from '../errors/io-syntax-error';\nimport ValidationError from '../errors/io-validation-error';\nimport TokenNode from '../parser/nodes/tokens';\nimport assertNever from '../errors/asserts/asserts';\nimport Schema from './schema';\nimport { processMember } from './processing/member-processor';\nexport default function processObject(data, schema, defs, collectionIndex) {\n    if (schema instanceof TokenNode) {\n        const schemaName = schema.value;\n        schema = defs?.getV(schemaName);\n    }\n    if (schema instanceof Schema === false) {\n        assertNever(\"Invalid schema type\");\n    }\n    return _processObject(data, schema, defs, collectionIndex);\n}\nfunction _processObject(data, schema, defs, collectionIndex) {\n    const o = new InternetObject();\n    let positional = true;\n    const processedNames = new Set();\n    // Process positional schema members\n    let i = 0;\n    for (; i < schema.names.length; i++) {\n        let member = data.children[i];\n        let name = schema.names[i];\n        let memberDef = schema.defs[name];\n        if (member) {\n            if (member.key) {\n                positional = false;\n                break;\n            }\n            processedNames.add(name);\n            const val = processMember(member, memberDef, defs);\n            if (val !== undefined)\n                o.set(name, val);\n        }\n        else {\n            if (!memberDef.optional) {\n                throw new ValidationError(ErrorCodes.valueRequired, `Expecting a value for ${memberDef.path}.`, data);\n            }\n        }\n    }\n    // Process remaining positional members\n    if (positional) {\n        for (; i < data.children.length; i++) {\n            const member = data.children[i];\n            if (!schema.open) {\n                throw new SyntaxError(ErrorCodes.additionalValuesNotAllowed, `Additional values are not allowed in the ${schema.name}. The ${schema.name} schema is not open.`, member.value);\n            }\n            if (member.key) {\n                positional = false;\n                break;\n            }\n            const val = member.value.toValue(defs);\n            o.push(val);\n        }\n    }\n    // Process remaining keyed members\n    for (; i < data.children.length; i++) {\n        let member = data.children[i];\n        if (!member.key) {\n            throw new SyntaxError(ErrorCodes.unexpectedPositionalMember, \"Positional members must not be allowed after the keyed member is found.\", member);\n        }\n        let name = member.key.value;\n        let memberDef = schema.defs[name];\n        if (processedNames.has(name)) {\n            throw new SyntaxError(ErrorCodes.duplicateMember, `Member ${name} is already defined.`, member);\n        }\n        // When the member is not found check if the schema is open to allow\n        // additional properties. If not throw an error.\n        if (!memberDef && !schema.open) {\n            throw new SyntaxError(ErrorCodes.unknownMember, `The ${schema.name ? `${schema.name} ` : ''}schema does not define a member named '${name}'.`, member.key);\n        }\n        // In an open schema, the memberDef is not found. Use schema.open constraints if available, else type 'any'.\n        if (!memberDef && schema.open) {\n            if (typeof schema.open === 'object' && schema.open.type) {\n                memberDef = { ...schema.open, path: name };\n            }\n            else {\n                memberDef = { type: 'any', path: name };\n            }\n        }\n        processedNames.add(name);\n        const val = processMember(member, memberDef, defs);\n        o.set(name, val);\n    }\n    // Check for missing required members and if the missing member has a\n    // default value, then set the default value. Otherwise, throw an error.\n    // But before throwing an error reset the position to the data node.\n    for (const name in schema.defs) {\n        // Skip the wildcard additional property definition ('*').\n        // It's not an actual member and must not participate in required checks.\n        if (name === '*')\n            continue;\n        const memberDef = schema.defs[name];\n        if (!processedNames.has(name)) {\n            const member = data.children.find((m) => m.key?.value === name);\n            try {\n                const val = processMember(member, memberDef, defs);\n                if (val !== undefined) {\n                    o.set(name, val);\n                }\n            }\n            catch (err) {\n                if (err instanceof ValidationError) {\n                    // in case of missing member, set the position to the parent object.\n                    err.positionRange = data;\n                }\n                throw err;\n            }\n        }\n    }\n    // Fallback: if schema is open and result is empty, process all data members as type 'any' or using schema.open constraints\n    if ((schema.open === true || (typeof schema.open === 'object' && schema.open.type)) && o.isEmpty()) {\n        for (const member of data.children) {\n            if (!member)\n                continue;\n            const memberNode = member;\n            let name = memberNode.key ? memberNode.key.value : undefined;\n            if (!name)\n                continue;\n            let memberDef;\n            if (typeof schema.open === 'object' && schema.open.type) {\n                memberDef = { ...schema.open, path: name };\n            }\n            else {\n                memberDef = { type: 'any', path: name };\n            }\n            const val = processMember(memberNode, memberDef, defs);\n            o.set(name, val);\n        }\n        return o;\n    }\n    return o;\n}\n","/**\n * ErrorNode represents a parsing error that occurred during AST construction.\n * This allows the parser to continue processing and collect multiple errors\n * instead of stopping at the first error encountered.\n */\nclass ErrorNode {\n    constructor(error, position, endPosition) {\n        this.error = error;\n        this.position = position;\n        this.endPosition = endPosition;\n    }\n    /**\n     * Determines the error category based on the error type.\n     * This enables UI to apply different styling (e.g., red for syntax, orange for validation).\n     *\n     * @returns 'syntax' for parser/syntax errors, 'validation' for schema validation errors, 'runtime' for others\n     */\n    getErrorCategory() {\n        const errorName = this.error.name;\n        // Check for InternetObject error types\n        if (errorName.includes('SyntaxError')) {\n            return 'syntax';\n        }\n        if (errorName.includes('ValidationError')) {\n            return 'validation';\n        }\n        // Fallback to runtime for unknown error types\n        return 'runtime';\n    }\n    /**\n     * Returns error information as a value object.\n     * This allows ErrorNodes to be serialized alongside valid nodes.\n     * Includes error category for UI styling.\n     */\n    toValue(defs) {\n        return {\n            __error: true,\n            category: this.getErrorCategory(),\n            message: this.error.message,\n            name: this.error.name,\n            position: this.position,\n            ...(this.endPosition && { endPosition: this.endPosition })\n        };\n    }\n    /**\n     * Returns the starting position of the error.\n     */\n    getStartPos() {\n        return this.position;\n    }\n    /**\n     * Returns the ending position of the error.\n     * If no end position was provided, returns the start position.\n     */\n    getEndPos() {\n        return this.endPosition || this.position;\n    }\n}\nexport default ErrorNode;\n","import TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../schema';\nexport class SchemaResolver {\n    static resolve(schema, defs) {\n        if (schema instanceof TokenNode) {\n            const schemaName = schema.value;\n            // Match existing behavior: defer to definitions.getV for resolution and error semantics\n            const resolved = defs?.getV(schemaName);\n            if (!(resolved instanceof Schema)) {\n                // Safety net; typically getV would throw for missing/invalid refs\n                throw new Error(`Schema '${schemaName}' not found or invalid`);\n            }\n            return resolved;\n        }\n        return schema;\n    }\n    static isSchemaVariable(value) {\n        return value instanceof TokenNode && typeof value.value === 'string' && value.value.startsWith('$');\n    }\n}\n","import Collection from '../../core/collection';\nimport ErrorNode from '../../parser/nodes/error';\nimport processObject from '../object-processor';\nimport { SchemaResolver } from '../utils/schema-resolver';\nexport default function processCollection(data, schema, defs, errorCollector) {\n    // Pre-resolve schema once for better performance\n    const resolvedSchema = SchemaResolver.resolve(schema, defs);\n    // Pre-allocate collection with known size\n    const collection = new Collection();\n    const length = data.children.length;\n    // Process items; include ErrorNode so UI can surface error info objects\n    for (let i = 0; i < length; i++) {\n        const item = data.children[i];\n        // If parsing produced an ErrorNode, preserve it in the collection\n        // so that downstream consumers (toJSON/UI) can render error info.\n        // NOTE: Parser errors are already in document._errors, so we don't add them to errorCollector.\n        if (item instanceof ErrorNode) {\n            // Push ErrorNode directly; IOCollection.toJSON handles toValue()\n            // which serializes error details with positions.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            collection.push(item);\n        }\n        else {\n            try {\n                collection.push(processObject(item, resolvedSchema, defs, i));\n            }\n            catch (error) {\n                // Validation error occurred - convert to ErrorNode and collect the error\n                if (error instanceof Error) {\n                    const errorNode = new ErrorNode(error, item.getStartPos(), item.getEndPos());\n                    // Add validation error to error collector if provided\n                    if (errorCollector) {\n                        errorCollector.push(error);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    collection.push(errorNode);\n                }\n                else {\n                    // Re-throw non-Error exceptions\n                    throw error;\n                }\n            }\n        }\n    }\n    return collection;\n}\n","import Collection from \"../../core/collection\";\nimport ContainerNode from \"./containers\";\nclass CollectionNode extends ContainerNode {\n    constructor(children = []) {\n        super('collection', children);\n    }\n    toValue(defs) {\n        const value = new Collection();\n        for (const child of this.children) {\n            value.push(child?.toValue(defs));\n        }\n        return value;\n    }\n    getStartPos() {\n        return this.children[0]?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        return this.children[this.children.length - 1]?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    // Utility Methods\n    isEmpty() {\n        return this.children.length === 0 || this.children.every(child => child === undefined);\n    }\n    toDebugString() {\n        const itemStrings = this.children.map((child, index) => {\n            if (!child)\n                return `[${index}]: undefined`;\n            const valueStr = typeof child.toValue === 'function' ?\n                JSON.stringify(child.toValue()) :\n                String(child);\n            return `[${index}]: ${valueStr}`;\n        });\n        return `CollectionNode { ${itemStrings.join(', ')} }`;\n    }\n    size() {\n        return this.children.length;\n    }\n    hasValidItems() {\n        return this.children.some(child => {\n            if (!child)\n                return true; // undefined items are valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true; // Valid item found\n        });\n    }\n    getValidItems() {\n        return this.children.filter((child) => {\n            if (!child)\n                return true; // undefined items are valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true; // Valid item\n        });\n    }\n    isValid() {\n        // A collection is valid if none of its items are ErrorNodes\n        return this.children.every(child => {\n            if (!child)\n                return true; // undefined items are considered valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true;\n        });\n    }\n}\nexport default CollectionNode;\n","import CollectionNode from '../../parser/nodes/collections';\nimport ObjectNode from '../../parser/nodes/objects';\nimport TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../schema';\nexport class ValidationUtils {\n    static isValidDataNode(data) {\n        return data instanceof ObjectNode || data instanceof CollectionNode;\n    }\n    static isValidSchema(schema) {\n        return schema instanceof Schema || schema instanceof TokenNode;\n    }\n    static validateProcessingInputs(data, schema) {\n        if (!ValidationUtils.isValidDataNode(data)) {\n            const hasCtorName = data?.constructor?.name;\n            const typeName = data === null ? 'null'\n                : data === undefined ? 'undefined'\n                    : hasCtorName === undefined ? 'undefined'\n                        : hasCtorName || 'unknown';\n            throw new Error(`Invalid data node type: ${typeName}`);\n        }\n        if (!ValidationUtils.isValidSchema(schema)) {\n            const hasCtorName = schema?.constructor?.name;\n            const typeName = schema === null ? 'null'\n                : schema === undefined ? 'undefined'\n                    : hasCtorName === undefined ? 'undefined'\n                        : hasCtorName || 'unknown';\n            throw new Error(`Invalid schema type: ${typeName}`);\n        }\n        return { data: data, schema: schema };\n    }\n}\nexport class ProcessingResult {\n    constructor(success, data, error) {\n        this.success = success;\n        this.data = data;\n        this.error = error;\n        Object.freeze(this); // ensure immutability at runtime\n    }\n    static success(data) {\n        return new ProcessingResult(true, data);\n    }\n    static failure(error) {\n        return new ProcessingResult(false, undefined, error);\n    }\n    isSuccess() {\n        return this.success;\n    }\n}\n","import ObjectNode from '../parser/nodes/objects';\nimport processObject from './object-processor';\nimport processCollection from './processing/collection-processor';\nimport { ValidationUtils } from './utils/validation-utils';\nexport default function processSchema(data, schema, defs, errorCollector) {\n    // Early return for null data\n    if (data === null) {\n        return null;\n    }\n    // Validate inputs\n    const { data: validData, schema: validSchema } = ValidationUtils.validateProcessingInputs(data, schema);\n    // Route to appropriate processor\n    if (validData instanceof ObjectNode) {\n        return processObject(validData, validSchema, defs);\n    }\n    // Must be CollectionNode at this point due to validation\n    return processCollection(validData, validSchema, defs, errorCollector);\n}\n","import ErrorCodes from '../../errors/io-error-codes';\nimport InternetObjectValidationError from '../../errors/io-validation-error';\nimport TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\n/**\n * Performs the common validations required before serialization and deserialization\n * @param memberDef The memberDef object\n * @param value The value which needs to be validated\n * @param node The node object, required for tracing line and column when parsing raw internet object code!\n *\n * @internal\n */\nfunction doCommonTypeCheck(memberDef, value, node, defs, collectionIndex) {\n    const isUndefined = value === undefined || value instanceof TokenNode && value.type === TokenType.UNDEFINED;\n    const isNull = node instanceof TokenNode ? node.value === null : value === null;\n    // Check for undefined\n    if (isUndefined) {\n        if (memberDef.default !== undefined)\n            return { value: _default(memberDef.default), changed: true };\n        if (memberDef.optional)\n            return { value: undefined, changed: true };\n        throw new InternetObjectValidationError(..._valueRequired(memberDef, node, collectionIndex));\n    }\n    // Check for null\n    if (isNull) {\n        if (memberDef.null)\n            return { value: null, changed: true };\n        const msg = `Null is not allowed for ${memberDef.path}` + (collectionIndex !== undefined ? ` at index ${collectionIndex}` : '');\n        throw new InternetObjectValidationError(ErrorCodes.nullNotAllowed, msg, node);\n    }\n    value = (typeof value === 'object' && value.toValue) ? value.toValue(defs) : value;\n    // Validate choices\n    if (memberDef.choices !== undefined) {\n        let val = value instanceof TokenNode ? value.value : value;\n        let found = false;\n        for (let choice of memberDef.choices) {\n            if (typeof choice === 'string' && choice[0] === '@') {\n                choice = defs?.getV(choice);\n                choice = choice instanceof TokenNode ? choice.value : choice;\n            }\n            if (val === choice) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new InternetObjectValidationError(..._invlalidChoice(memberDef, value, node));\n        }\n    }\n    // If everything is okay, return same data\n    return { value: value, changed: false };\n}\nfunction _default(value) {\n    if (typeof value === 'string') {\n        if (value === 'N')\n            return null;\n        if (value === 'T' || value === 'true')\n            return true;\n        if (value === 'F' || value === 'false')\n            return false;\n        return value;\n    }\n    return value;\n}\nfunction _valueRequired(memberDef, node, collectionIndex) {\n    const msg = `Value is required for ${memberDef.path}` + (collectionIndex !== undefined ? ` at index ${collectionIndex}` : '');\n    return [ErrorCodes.valueRequired, msg, node];\n}\nfunction _nullNotAllowed(memberDef, node) {\n    return [ErrorCodes.nullNotAllowed, `${memberDef.path} does not support null.`, node];\n}\n// Return an invalid choice error parameters\nfunction _invlalidChoice(memberDef, value, node) {\n    if (!memberDef.choices)\n        throw Error('Choices not checked during NumberDef implementation.');\n    value = value.toValue\n        ? value.toValue()\n        : value.toObject\n            ? value.toObject()\n            : value;\n    value = JSON.stringify(value);\n    let msg = `The value of \"${memberDef.path}\" must be one of the [${memberDef.choices.join(', ')}]. Currently it is ${value}.`;\n    if (memberDef.choices.length === 1) {\n        msg = `The value of \"${memberDef.path}\" must be '${memberDef.choices[0]}'. Currently it is ${value}.`;\n    }\n    return [ErrorCodes.invalidChoice, msg, node];\n}\nexport default doCommonTypeCheck;\n","import ErrorCodes from '../../errors/io-error-codes';\nimport InternetObjectError from '../../errors/io-error';\nimport ValidationError from '../../errors/io-validation-error';\nimport MemberNode from '../../parser/nodes/members';\nimport { getMemberDef } from '../../schema/compile-object';\nimport Schema from '../../schema/schema';\nimport TypedefRegistry from '../../schema/typedef-registry';\nimport doCommonTypeCheck from './common-type';\nconst of = { type: \"any\", __memberdef: true };\nconst schema = new Schema(\"any\", { type: { type: \"string\", optional: false, null: false, choices: [\"any\"] } }, { default: { type: \"any\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false } }, { anyOf: { type: \"array\", optional: true, null: false, of } }, { isSchema: { type: \"bool\", optional: true, null: false, default: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nexport default class AnyDef {\n    get type() { return 'any'; }\n    get schema() { return schema; }\n    parse(node, memberDef, defs, collectionIndex) {\n        const valueNode = defs?.getV(node) || node;\n        const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        const anyOf = memberDef.anyOf;\n        if (!anyOf) {\n            if (memberDef.__memberdef) { // Convert to memberDef\n                const md = getMemberDef(new MemberNode(node), \"\", defs);\n                return md;\n            }\n            return value;\n        }\n        const errors = [];\n        for (let i = 0; i < anyOf.length; i++) {\n            const def = anyOf[i];\n            def.path = memberDef.path;\n            const typeDef = TypedefRegistry.get(def.type);\n            if (!typeDef) {\n                throw new InternetObjectError(ErrorCodes.invalidType, `Invalid type definition '${def.type}'`);\n            }\n            try {\n                return typeDef.parse(node, def, defs, collectionIndex);\n            }\n            catch (e) {\n                errors.push(e);\n                continue;\n            }\n        }\n        // None of the types matched\n        if (errors.length === anyOf.length) {\n            throw new ValidationError(ErrorCodes.invalidValue, `None of the constraints defined for '${memberDef.path}' matched.`, node);\n        }\n        return valueNode;\n    }\n    static get types() { return ['any']; }\n}\n","import assertNever from '../../errors/asserts/asserts';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport ArrayNode from '../../parser/nodes/array';\nimport Schema from '../../schema/schema';\nimport TypedefRegistry from '../../schema/typedef-registry';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"array\", { type: { type: \"string\", optional: false, null: false, choices: [\"array\"] } }, { default: { type: \"array\", optional: true, null: false } }, { of: { type: \"any\", optional: true, null: false, __memberdef: true } }, { len: { type: \"number\", optional: true, null: false, min: 0 } }, { minLen: { type: \"number\", optional: true, null: false, min: 0 } }, { maxLen: { type: \"number\", optional: true, null: false, min: 0 } });\nclass ArrayDef {\n    constructor() {\n        this.parse = (valueNode, memberDef, defs, collectionIndex) => {\n            return _processNode(valueNode, memberDef, defs, collectionIndex);\n        };\n    }\n    get type() { return 'array'; }\n    get schema() { return schema; }\n    static get types() { return ['array']; }\n}\nfunction _processNode(node, memberDef, defs, collectionIndex) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof ArrayNode === false) {\n        throw new ValidationError(ErrorCodes.notAnArray, `Expecting an array value for '${memberDef.path}'`, node);\n    }\n    // Find the right typeDef\n    let typeDef;\n    let arrayMemberDef = {\n        type: 'any'\n    };\n    if (memberDef.of instanceof Schema) {\n        typeDef = TypedefRegistry.get('object');\n        arrayMemberDef.schema = memberDef.of;\n        arrayMemberDef.path = memberDef.path;\n    }\n    else if (memberDef.of?.type) {\n        typeDef = TypedefRegistry.get(memberDef.of.type);\n        if (!typeDef) {\n            throw new ValidationError(ErrorCodes.invalidType, `Invalid type definition '${memberDef.of.type}'`, node);\n        }\n        arrayMemberDef = memberDef.of;\n        arrayMemberDef.path = memberDef.path;\n    }\n    else if (typeof memberDef.of === 'string') {\n        assertNever(memberDef.of);\n    }\n    else {\n        typeDef = TypedefRegistry.get('any');\n    }\n    const array = [];\n    valueNode.children.forEach((item) => {\n        // If it is a definition\n        if (valueNode !== node) {\n            try {\n                array.push(typeDef?.parse(item, arrayMemberDef, defs));\n            }\n            catch (err) {\n                // Before rethrowing the error, change the position of the error to\n                // the original node.\n                if (err instanceof ValidationError) {\n                    err.positionRange = node;\n                }\n                throw err;\n            }\n        }\n        else {\n            array.push(typeDef?.parse(item, arrayMemberDef, defs));\n        }\n    });\n    return array;\n}\nfunction _invlalidChoice(key, token, min) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be greater than or equal to ${min}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nfunction _invlalidLength(key, token, length, collectionIndex) {\n    const actualLength = token instanceof ArrayNode ? token.children.length : 0;\n    return [\n        ErrorCodes.invalidLength,\n        `The \"${key}\" must be ${length}, Currently it is ${actualLength} for collection index ${collectionIndex}.`,\n        token\n    ];\n}\nfunction _invlalidMinLength(key, token, min, collectionIndex) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be greater than or equal to ${min}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nfunction _invlalidMaxLength(key, token, max, collectionIndex) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be less than or equal to ${max}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nexport default ArrayDef;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BooleanDef_instances, _BooleanDef_validate;\nimport ValidationError from '../../errors/io-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../../schema/schema';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"bool\", { type: { type: \"string\", optional: false, null: false, choices: [\"bool\"] } }, { default: { type: \"bool\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nclass BooleanDef {\n    constructor() {\n        _BooleanDef_instances.add(this);\n    }\n    get type() { return 'bool'; }\n    get schema() { return schema; }\n    parse(node, memberDef, defs) {\n        return __classPrivateFieldGet(this, _BooleanDef_instances, \"m\", _BooleanDef_validate).call(this, node, memberDef, defs);\n    }\n    strinfigy(value) {\n        return value.toString();\n    }\n    static get types() { return ['bool']; }\n}\n_BooleanDef_instances = new WeakSet(), _BooleanDef_validate = function _BooleanDef_validate(node, memberDef, defs) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof TokenNode === false || valueNode.type !== TokenType.BOOLEAN) {\n        throw new ValidationError(ErrorCodes.notABool, `Expecting a boolean value for '${memberDef.path}' but found ${valueNode.toValue()}.`, node);\n    }\n    return valueNode.value;\n};\nexport default BooleanDef;\n","export const datetimeExp = {\n    // https://regex101.com/r/v1YLhA/2\n    datetime: /^(?<dt>(?<year>\\d{4})(?:\\-(?<month>(?:1[0-2]|0[1-9]))(?:\\-(?<date>[0-2][0-9]|3[0-1]))?)?(T(?<hour>[0-1][0-9]|2[0-3])(?:\\:(?<minute>[0-5][0-9])(?:\\:(?<sec>[0-5][0-9])(?:\\.(?<milisecond>(?:\\d{3})+))?)?)?)?(?<tz>(Z)|((?:\\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:\\:[0-5][0-9])?)))?)$/,\n    // https://regex101.com/r/yXu5MC/2\n    date: /^(?<year>\\d{4})(?:\\-(?<month>(?:1[0-2]|0[1-9]))(?:\\-(?<date>[0-2][0-9]|3[0-1]))?)?$/,\n    // https://regex101.com/r/hbiNMv/4\n    time: /^(?<hour>[0-1][0-9]|2[0-3])(?:\\:(?<minute>[0-5][0-9])(?:\\:(?<second>[0-5][0-9])(?:\\.(?<milisecond>(?:\\d{3})+))?)?)?$/\n};\nexport const datetimePlainExp = {\n    // https://regex101.com/r/0j7nlS/3\n    // Note: Since this expression starts with ^ and does not end with $, it will\n    // ignore any characters after the valid datetime format.\n    // Unlike regular datetime expressions, this won't complain about the invalid\n    // datetime format if the expression finds invalid characters after the\n    // valid datetime format. For example, 20200101000000000Zabc will be\n    // considered as a valid datetime format with 'abc' ignored.\n    // This is required because, putting $ at the end of the expression will\n    // cause it to pick up invalid groups from the datetime string.\n    datetime: /^(?<year>\\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?(?:(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\\d{3})+))?)?)?)?(?<tz>(Z)|((?:\\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:[0-5][0-9])?)))?/,\n    // https://regex101.com/r/VDkmzU/2\n    date: /^(?<year>\\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?$/,\n    // https://regex101.com/r/X5AA4A/3\n    time: /^(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\\d{3})+))?)?)?$/\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted datetime. Returns null when the invalid datetime\n * is found.\n */\nexport const parseDateTime = (value) => {\n    // If the first 6 characters contain '-', it is regular datetime format.\n    // Otherwise, it is plain datetime format (no separator)\n    const exp = /[\\-\\:]/.test(value.substring(0, 6)) ? datetimeExp.datetime : datetimePlainExp.datetime;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { year, month, date, hour, minute, second, milisecond, tz } = match.groups || {};\n    const utc = tz ? tz : 'Z';\n    const dateStr = `${year}-${month || '01'}-${date || '01'}T${hour || '00'}:${minute || '00'}:${second || '00'}.${milisecond || '000'}${utc}`;\n    return new Date(dateStr);\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted date. Returns null when the invalid date\n * is found.\n */\nexport const parseDate = (value) => {\n    const exp = /\\-/.test(value.substring(0, 5)) ? datetimeExp.date : datetimePlainExp.date;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { year, month, date } = match.groups || {};\n    const dateStr = `${year}-${month || '01'}-${date || '01'}T00:00:00.000Z`;\n    return new Date(dateStr);\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted time. Returns null when the invalid time\n * is found.\n */\nexport const parseTime = (value) => {\n    const exp = /\\:/.test(value.substring(0, 3)) ? datetimeExp.time : datetimePlainExp.time;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { hour, minute, second, milisecond } = match.groups || {};\n    const dateStr = `1900-01-01T${hour || '00'}:${minute || '00'}:${second || '00'}.${milisecond ? milisecond : '000'}Z`;\n    return new Date(dateStr);\n};\nexport const dateToDatetimeString = (date, noSep = false, zuluTime = false) => {\n    if (date === null)\n        return null;\n    return date.toISOString();\n};\nexport const dateToDateString = (date, noSep = false) => {\n    if (date === null)\n        return null;\n    // Convert the date to iso string and return the date part\n    return date.toISOString().split('T')[0];\n};\nexport const dateToTimeString = (date, noSep = false) => {\n    if (date === null)\n        return null;\n    // Convert the date to iso string and return the time part\n    // without the timezone\n    return date.toISOString().split('T')[1].split('.')[0];\n};\nconst _ = (n, pad = 2) => {\n    return n.toLocaleString('en-US', { minimumIntegerDigits: pad, useGrouping: false });\n};\nexport const dateToSmartString = (date, type, noSep = false) => {\n    if (date === null)\n        return null;\n    switch (type) {\n        case \"datetime\":\n            return dateToDatetimeString(date, noSep);\n        case \"date\":\n            return dateToDateString(date, noSep);\n        case \"time\":\n            return dateToTimeString(date, noSep);\n    }\n};\nexport const dateToIOString = (date, type, noSep = false) => {\n    if (date === null)\n        return \"N\";\n    switch (type) {\n        case \"datetime\":\n            return `dt\"${dateToDatetimeString(date, noSep)}\"`;\n        case \"date\":\n            return `d\"${dateToDateString(date, noSep)}\"`;\n        case \"time\":\n            return `t\"${dateToTimeString(date, noSep)}\"`;\n    }\n};\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _DateTimeDef_instances, _DateTimeDef_type, _DateTimeDef_validate;\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport Schema from '../../schema/schema';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport * as dt from '../../utils/datetime';\nimport doCommonTypeCheck from './common-type';\nconst DATETIME_TYPES = ['datetime', 'date', 'time'];\nconst schema = new Schema(\"datetime\", { type: { type: \"string\", optional: false, null: false, choices: DATETIME_TYPES } }, { default: { type: \"datetime\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"datetime\" } } }, { min: { type: \"datetime\", optional: true, null: false } }, { max: { type: \"datetime\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nclass DateTimeDef {\n    get type() { return __classPrivateFieldGet(this, _DateTimeDef_type, \"f\"); }\n    get schema() { return schema; }\n    constructor(type = 'datetime') {\n        _DateTimeDef_instances.add(this);\n        _DateTimeDef_type.set(this, void 0);\n        __classPrivateFieldSet(this, _DateTimeDef_type, type, \"f\");\n    }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        if (valueNode.type !== TokenType.DATETIME) {\n            throw new ValidationError(ErrorCodes.invalidDateTime, `Expecting a ${memberDef.type.toUpperCase()} value for ${memberDef.path}, currently ${valueNode.value}, a ${valueNode.type} value`, node);\n        }\n        // Validate the value\n        __classPrivateFieldGet(this, _DateTimeDef_instances, \"m\", _DateTimeDef_validate).call(this, value, memberDef, node);\n        return value;\n    }\n    strinfigy(value) {\n        return dt.dateToIOString(value, __classPrivateFieldGet(this, _DateTimeDef_type, \"f\"));\n    }\n    static get types() { return DATETIME_TYPES; }\n}\n_DateTimeDef_type = new WeakMap(), _DateTimeDef_instances = new WeakSet(), _DateTimeDef_validate = function _DateTimeDef_validate(value, memberDef, node) {\n    const dateType = memberDef.type;\n    if (memberDef.min) {\n        const min = memberDef.min;\n        if (min && value < min) {\n            throw new ValidationError(ErrorCodes.outOfRange, `Expecting the value ${memberDef.path ? `for '${memberDef.path}'` : ''} to be greater than or equal to '${dt.dateToSmartString(memberDef.min, dateType)}'`, node);\n        }\n    }\n    if (memberDef.max) {\n        const max = memberDef.max;\n        if (max && value > max) {\n            throw new ValidationError(ErrorCodes.outOfRange, `Expecting the value ${memberDef.path ? `for '${memberDef.path}'` : ''} to be less than or equal to '${dt.dateToSmartString(memberDef.max, dateType)}'`, node);\n        }\n    }\n};\nexport default DateTimeDef;\n","import ValidationError from '../../errors/io-validation-error';\n/**\n * All supported number types\n */\nexport const NUMBER_TYPES = [\n    'bigint', 'decimal',\n    'int', 'uint', 'float', 'number',\n    'int8', 'int16', 'int32',\n    'uint8', 'uint16', 'uint32', 'uint64',\n    'float32', 'float64' // Floating point number types\n];\n/**\n * Map for quick type lookup\n */\nexport const NUMBER_MAP = NUMBER_TYPES.reduce((acc, type) => {\n    acc[type] = true;\n    return acc;\n}, {});\n/**\n * Helper function for throwing validation errors\n */\nexport function throwError(code, memberPath, value, node) {\n    throw new ValidationError(code, `The '${memberPath}' must be within the specified range, Currently it is ${value}.`, node);\n}\n/**\n * Get the number of integer digits in a decimal\n */\nexport function getIntegerDigits(decimal) {\n    const valueStr = decimal.toString();\n    return valueStr.split('.')[0].replace('-', '').length;\n}\n","import ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, NUMBER_MAP, throwError } from './common-number';\nconst bigintSchema = new Schema(\"bigint\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"bigint\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"bigint\" } } }, { min: { type: \"bigint\", optional: true, null: false } }, { max: { type: \"bigint\", optional: true, null: false } }, { format: { type: \"string\", optional: true, null: false, choices: [\"decimal\", \"hex\", \"octal\", \"binary\"], default: \"decimal\" } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * BigInt type definition\n *\n * @internal\n */\nclass BigIntDef {\n    constructor() {\n        this._type = 'bigint';\n    }\n    get type() { return this._type; }\n    get schema() { return bigintSchema; }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        value = this.validate(memberDef, value, node);\n        return value;\n    }\n    stringify(value, memberDef) {\n        if (memberDef.format === 'hex') {\n            return value.toString(16);\n        }\n        if (memberDef.format === 'octal') {\n            return value.toString(8);\n        }\n        if (memberDef.format === 'binary') {\n            return value.toString(2);\n        }\n        return value.toString();\n    }\n    /**\n     * Validates bigint value\n     */\n    validate(memberDef, value, node) {\n        const valueType = typeof value === \"bigint\" ? \"bigint\" : NUMBER_MAP[typeof value] ? \"number\" : \"\";\n        if (valueType === \"\") {\n            throw new ValidationError(ErrorCodes.invalidType, `Expecting a value of type '${memberDef.type}' for '${memberDef.path}'`, node);\n        }\n        if (valueType !== \"bigint\") {\n            throw new ValidationError(`not-a-${memberDef.type}`, `Invalid value encountered for '${memberDef.path}'`, node);\n        }\n        const { min, max } = memberDef;\n        if ((min !== undefined && min !== null && value < min) ||\n            (max !== undefined && max !== null && value > max)) {\n            throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n        }\n        return value;\n    }\n}\nexport default BigIntDef;\n","import Decimal from '../../core/decimal';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, throwError, getIntegerDigits } from './common-number';\nconst decimalSchema = new Schema(\"decimal\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"decimal\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"decimal\" } } }, { precision: { type: \"number\", optional: true, null: false } }, { scale: { type: \"number\", optional: true, null: false } }, { min: { type: \"decimal\", optional: true, null: false } }, { max: { type: \"decimal\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Decimal type definition with support for 4 validation modes:\n * 1. Natural comparison (no precision/scale)\n * 2. Scale-only validation (exact decimal places)\n * 3. Precision-only validation (max significant digits)\n * 4. Strict validation (exact DECIMAL(precision, scale))\n *\n * @internal\n */\nclass DecimalDef {\n    constructor() {\n        this._type = 'decimal';\n    }\n    get type() { return this._type; }\n    get schema() { return decimalSchema; }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        value = this.validate(memberDef, value, node);\n        return value;\n    }\n    stringify(value, memberDef) {\n        return value.toString();\n    }\n    /**\n     * Validates decimal value according to the specified mode\n     */\n    validate(memberDef, value, node) {\n        let { min, max, precision: requiredPrecision, scale: requiredScale } = memberDef;\n        const valD = Decimal.ensureDecimal(value);\n        // Mode check: Determine validation mode based on precision and scale\n        const hasRequiredPrecision = requiredPrecision !== null && requiredPrecision !== undefined;\n        const hasRequiredScale = requiredScale !== null && requiredScale !== undefined;\n        // Validate scale if specified (modes 2 and 4)\n        if (hasRequiredScale) {\n            const actualScale = valD.getScale();\n            if (actualScale !== requiredScale) {\n                throwError(ErrorCodes.invalidScale, memberDef.path, `Value has scale ${actualScale}, expected ${requiredScale}`, node);\n            }\n        }\n        // Validate precision if specified (modes 3 and 4)\n        if (hasRequiredPrecision) {\n            const actualPrecision = valD.getPrecision();\n            if (hasRequiredScale) {\n                // Mode 4: Strict validation (both precision and scale)\n                // Check if value fits within DECIMAL(precision, scale)\n                const intDigits = getIntegerDigits(valD);\n                const maxIntDigits = requiredPrecision - requiredScale;\n                if (intDigits > maxIntDigits) {\n                    throwError(ErrorCodes.invalidPrecision, memberDef.path, `Integer part has ${intDigits} digits, DECIMAL(${requiredPrecision},${requiredScale}) allows ${maxIntDigits}`, node);\n                }\n            }\n            else {\n                // Mode 3: Precision-only validation\n                if (actualPrecision > requiredPrecision) {\n                    throwError(ErrorCodes.invalidPrecision, memberDef.path, `Value has precision ${actualPrecision}, max allowed is ${requiredPrecision}`, node);\n                }\n            }\n        }\n        // Validate min constraint - normalize to same scale for comparison\n        if (min !== null && min !== undefined) {\n            const minD = Decimal.ensureDecimal(min);\n            // Use the larger scale for both\n            const targetScale = Math.max(valD.getScale(), minD.getScale());\n            // Calculate precision needed: max integer digits + target scale\n            const valIntDigits = getIntegerDigits(valD);\n            const minIntDigits = getIntegerDigits(minD);\n            const targetPrecision = Math.max(valIntDigits, minIntDigits) + targetScale;\n            const normalizedVal = valD.convert(targetPrecision, targetScale);\n            const normalizedMin = minD.convert(targetPrecision, targetScale);\n            if (normalizedVal.compareTo(normalizedMin) < 0) {\n                throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n            }\n        }\n        // Validate max constraint - normalize to same scale for comparison\n        if (max !== null && max !== undefined) {\n            const maxD = Decimal.ensureDecimal(max);\n            // Use the larger scale for both\n            const targetScale = Math.max(valD.getScale(), maxD.getScale());\n            // Calculate precision needed: max integer digits + target scale\n            const valIntDigits = getIntegerDigits(valD);\n            const maxIntDigits = getIntegerDigits(maxD);\n            const targetPrecision = Math.max(valIntDigits, maxIntDigits) + targetScale;\n            const normalizedVal = valD.convert(targetPrecision, targetScale);\n            const normalizedMax = maxD.convert(targetPrecision, targetScale);\n            if (normalizedVal.compareTo(normalizedMax) > 0) {\n                throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n            }\n        }\n        // Return the value as-is (don't convert unless necessary)\n        return valD;\n    }\n}\nexport default DecimalDef;\n","import InternetObjectError from '../../errors/io-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, NUMBER_MAP, throwError } from './common-number';\nimport BigIntDef from './bigint';\nimport DecimalDef from './decimal';\nconst numberSchema = new Schema(\"number\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"number\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"number\" } } }, { min: { type: \"number\", optional: true, null: false } }, { max: { type: \"number\", optional: true, null: false } }, { format: { type: \"string\", optional: true, null: false, choices: [\"decimal\", \"hex\", \"octal\", \"binary\", \"scientific\"] } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the various number related data types in Internet Object.\n * Delegates to specialized types (BigIntDef, DecimalDef) when appropriate.\n *\n * @internal\n */\nclass NumberDef {\n    get type() { return this._type; }\n    get schema() {\n        if (this._delegateTypeDef) {\n            return this._delegateTypeDef.schema;\n        }\n        return numberSchema;\n    }\n    constructor(type = 'number') {\n        this._type = type;\n        // Delegate to specialized type definitions\n        if (type === 'bigint') {\n            this._delegateTypeDef = new BigIntDef();\n        }\n        else if (type === 'decimal') {\n            this._delegateTypeDef = new DecimalDef();\n        }\n    }\n    parse(node, memberDef, defs) {\n        // Delegate to specialized type if available\n        if (this._delegateTypeDef) {\n            return this._delegateTypeDef.parse(node, memberDef, defs);\n        }\n        // Handle standard number types\n        const valueNode = defs?.getV(node) || node;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        value = this.validateInteger(memberDef, value, node);\n        return value;\n    }\n    stringify(value, memberDef) {\n        // Delegate to specialized type if available\n        if (this._delegateTypeDef && 'stringify' in this._delegateTypeDef) {\n            return this._delegateTypeDef.stringify(value, memberDef);\n        }\n        // Handle standard number types\n        if (memberDef.format === 'scientific') {\n            return value.toExponential();\n        }\n        if (memberDef.format === 'hex') {\n            return value.toString(16);\n        }\n        if (memberDef.format === 'octal') {\n            return value.toString(8);\n        }\n        if (memberDef.format === 'binary') {\n            return value.toString(2);\n        }\n        return value.toString();\n    }\n    /**\n     * Validates integer and float types\n     */\n    validateInteger(memberDef, value, node) {\n        const valueType = typeof value === \"bigint\" ? \"bigint\" : NUMBER_MAP[typeof value] ? \"number\" : \"\";\n        if (valueType === \"\") {\n            throw new ValidationError(ErrorCodes.invalidType, `Expecting a value of type '${memberDef.type}' for '${memberDef.path}'`, node);\n        }\n        if (valueType !== \"number\") {\n            throw new ValidationError(`not-a-${memberDef.type}`, `Invalid value encountered for '${memberDef.path}'`, node);\n        }\n        // Get type-specific bounds\n        const { min: typeBoundMin, max: typeBoundMax } = this.getTypeBounds(this._type);\n        // Use memberDef.min/max if available, otherwise use type bounds\n        const effectiveMin = memberDef.min !== undefined && memberDef.min !== null ? memberDef.min : typeBoundMin;\n        const effectiveMax = memberDef.max !== undefined && memberDef.max !== null ? memberDef.max : typeBoundMax;\n        if ((effectiveMin !== null && value < effectiveMin) || (effectiveMax !== null && value > effectiveMax)) {\n            throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n        }\n        return value;\n    }\n    /**\n     * Get min/max bounds for a specific number type\n     */\n    getTypeBounds(type) {\n        switch (type) {\n            case 'uint':\n                return { min: 0, max: null };\n            case 'int8':\n                return { min: -(2 ** 7), max: 2 ** 7 - 1 };\n            case 'uint8':\n                return { min: 0, max: 2 ** 8 - 1 };\n            case 'int16':\n                return { min: -(2 ** 15), max: 2 ** 15 - 1 };\n            case 'uint16':\n                return { min: 0, max: 2 ** 16 - 1 };\n            case 'int32':\n                return { min: -(2 ** 31), max: 2 ** 31 - 1 };\n            case 'uint32':\n                return { min: 0, max: 2 ** 32 - 1 };\n            case 'uint64':\n            case 'int64':\n            case 'float32':\n            case 'float64':\n                throw new InternetObjectError(ErrorCodes.unsupportedNumberType, `The number type '${type}' is not supported.`);\n            default:\n                return { min: null, max: null };\n        }\n    }\n    static get types() {\n        return NUMBER_TYPES;\n    }\n}\nexport default NumberDef;\n","import ValidationError from '../../errors/io-validation-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ObjectNode from '../../parser/nodes/objects';\nimport compileObject from '../../schema/compile-object';\nimport processObject from '../../schema/object-processor';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"object\", { type: { type: \"string\", optional: false, null: false, choices: [\"object\"] } }, { default: { type: \"object\", optional: true, null: false } }, { schema: { type: \"object\", optional: true, null: false, __schema: true } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the ObjectTypeDef which is reponsible for parsing,\n * validating, loading and serializing Objects.\n */\nclass ObjectDef {\n    constructor() {\n        this._names = null;\n        /**\n         * Parses the object in IO format into JavaScript object.\n         */\n        this.parse = (node, memberDef, defs) => {\n            return this._process(node, memberDef, defs);\n        };\n        // Process the parse and load requests\n        this._process = (node, memberDef, defs) => {\n            const valueNode = defs?.getV(node) || node;\n            const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n            if (changed) {\n                return value;\n            }\n            let schema = memberDef.schema;\n            if (valueNode instanceof ObjectNode === false) {\n                throw new ValidationError(ErrorCodes.invalidObject, `Expecting an object value for '${memberDef.path}'`, node);\n            }\n            if (valueNode === node) {\n                if (memberDef.__schema) {\n                    return compileObject(memberDef.path || \"\", valueNode, defs);\n                }\n                if (!schema) {\n                    schema = new Schema(memberDef.path || \"\");\n                    schema.open = true;\n                }\n                return processObject(valueNode, schema, defs);\n            }\n            // valueNode fetched from defs. Hence, in case of an error, replace the\n            // error position with the original node.\n            try {\n                return processObject(valueNode, schema, defs);\n            }\n            catch (err) {\n                if (err instanceof ValidationError) {\n                    err.positionRange = node;\n                }\n                throw err;\n            }\n            return processObject(valueNode, schema, defs);\n        };\n    }\n    /**\n     * Returns the type this instance is going to handle.\n     * Always returns object\n     */\n    get type() { return 'object'; }\n    static get types() { return ['object']; }\n    get schema() { return schema; }\n}\nexport default ObjectDef;\n","const reStructuralChars = /(?<structural>[\\{\\}\\[\\]\\:\\,\\#\\\"\\'\\\\\\\\~])/gm;\nconst escapeChars = /(?<escape>[\\n\\r\\t])/gm;\nconst reNewLine = /(?<newlines>(\\r\\n?)|\\n)/gm;\nexport const toOpenString = (str, escapeLines) => {\n    str = str.replace(reStructuralChars, '\\\\$1');\n    if (escapeLines) {\n        str = str.replace(reNewLine, '\\\\n');\n    }\n    return str;\n};\nexport const toRegularString = (str, escapeLines, encloser = '\"') => {\n    str = str.replace(escapeChars, '\\\\$1');\n    if (escapeLines) {\n        str = str.replace(reNewLine, '\\\\n');\n    }\n    return `${encloser}${str.replace(encloser, `\\\\${encloser}`)}${encloser}`;\n};\nexport const toRawString = (str, encloser = '\"') => {\n    return `r${encloser}${str.replace(encloser, encloser + encloser)}${encloser}`;\n};\nexport const toAutoString = (str, escapeLines, encloser = '\"') => {\n    // If the string contains any of the structural characters, then return as open string\n    if (reStructuralChars.test(str)) {\n        return toOpenString(str, escapeLines);\n    }\n    // If the string contains any of the escape characters, then retrun as raw string\n    if (escapeChars.test(str)) {\n        return toRawString(str, encloser);\n    }\n    // Otherwise, return as regular string\n    return toRegularString(str, escapeLines, encloser);\n};\n","import ValidationError from '../../errors/io-validation-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport Schema from '../../schema/schema';\nimport * as strings from '../../utils/strings';\nimport doCommonTypeCheck from './common-type';\nconst STRING_TYPES = ['string', 'url', 'email'];\n// Reference: RFC 5322 Official Standard\n// http://emailregex.com\nconst emailExp = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/;\n// http://urlregex.com\nconst urlExp = /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[\\-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9\\.\\-]+|(?:www\\.|[\\-;:&=\\+\\$,\\w]+@)[A-Za-z0-9\\.\\-]+)((?:\\/[\\+~%\\/\\.\\w\\-_]*)?\\??(?:[\\-\\+=&;%@\\.\\w_]*)#?(?:[\\.\\!\\/\\\\\\w]*))?)/;\nconst schema = new Schema(\"string\", { type: { type: \"string\", optional: false, null: false, choices: STRING_TYPES } }, { default: { type: \"string\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"string\" } } }, { pattern: { type: \"string\", optional: true, null: false } }, { flags: { type: \"string\", optional: true, null: false } }, { len: { type: \"number\", optional: true, null: false, min: 0 } }, { minLen: { type: \"number\", optional: true, null: false, min: 0 } }, { maxLen: { type: \"number\", optional: true, null: false, min: 0 } }, { format: { type: \"string\", optional: true, null: false, choices: [\"auto\", \"open\", \"regular\", \"raw\"], default: \"auto\" } }, { escapeLines: { type: \"bool\", optional: true, null: false, default: false } }, { encloser: { type: \"string\", optional: true, null: false, choices: ['\"', \"'\"], default: '\"' } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the StringTypeDef which is reponsible for parsing,\n * validating, loading and serializing strings.\n *\n * It performs the following validation\n * - Value is string\n* - Value is optional\n* - Value is null\n* - Value is in choices\n * - Value length <= maxLength\n * - Value length >= minLen\n */\nexport default class StringDef {\n    constructor(type = 'string') {\n        this._type = type;\n    }\n    get type() { return this._type; }\n    static get types() { return STRING_TYPES; }\n    get schema() { return schema; }\n    /**\n     * Parses the string in IO format into JavaScript strings.\n     */\n    parse(valueNode, memberDef, defs) {\n        return _process(valueNode, memberDef, defs);\n    }\n    stringify(value, memberDef) {\n        const format = memberDef.format || 'auto';\n        switch (format) {\n            case 'auto':\n                return strings.toAutoString(value, memberDef.escapeLines, memberDef.encloser);\n            case 'open':\n                return strings.toOpenString(value, memberDef.escapeLines);\n            case 'regular':\n                return strings.toRegularString(value, memberDef.escapeLines, memberDef.encloser);\n            default:\n                return strings.toRawString(value, memberDef.encloser);\n        }\n    }\n}\nfunction _process(node, memberDef, defs) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof TokenNode === false || valueNode.type !== TokenType.STRING) {\n        throw new ValidationError(ErrorCodes.notAString, `Expecting a string value for '${memberDef.path}' but found ${valueNode.toValue()}.`, node);\n    }\n    _validatePattern(memberDef, value, node);\n    // Len check\n    const len = memberDef.len;\n    if (len !== undefined && typeof len === 'number') {\n        if (value.length !== len) {\n            throw new ValidationError(ErrorCodes.invalidLength, `Invalid length for ${memberDef.path}.`, valueNode);\n        }\n    }\n    // Max length check\n    const maxLen = memberDef.maxLen;\n    if (maxLen !== undefined && typeof maxLen === 'number') {\n        if (value.length > maxLen) {\n            throw new ValidationError(ErrorCodes.invalidMaxLength, `Invalid maxLength for ${memberDef.path}.`, valueNode);\n        }\n    }\n    // Max length check\n    const minLen = memberDef.minLen;\n    if (minLen !== undefined && typeof minLen === 'number') {\n        if (value.length < minLen) {\n            throw new ValidationError(ErrorCodes.invalidMinLength, `Invalid minLen for ${memberDef.path}.`, valueNode);\n        }\n    }\n    return value;\n}\nfunction _validatePattern(memberDef, value, node) {\n    const type = memberDef.type;\n    // Validate user defined pattern\n    if (type === 'string' && memberDef.pattern !== undefined) {\n        let re = memberDef.re;\n        if (!re) {\n            let pattern = memberDef.pattern;\n            let flags = memberDef.flags;\n            // Compile the expression and cache it into the memberDef\n            try {\n                if (flags) {\n                    re = memberDef.re = new RegExp(pattern, flags);\n                }\n                else {\n                    re = memberDef.re = new RegExp(pattern);\n                }\n                memberDef.re = re; // Cache the compiled expression\n            }\n            catch {\n                throw new ValidationError(ErrorCodes.invalidPattern, value, node);\n            }\n        }\n        if (!re.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidPattern, `The value '${value}' does not match the pattern '${memberDef.pattern}'.`, node);\n        }\n    }\n    // Validate email\n    else if (type === 'email') {\n        if (!emailExp.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidEmail, `Invalid email address: ${value}`, node);\n        }\n    }\n    // Validate url\n    else if (type === 'url') {\n        if (!urlExp.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidUrl, `Invalid URL: ${value}`, node);\n        }\n    }\n}\n","import TypedefRegistry from '../../schema/typedef-registry';\nimport AnyDef from './any';\nimport ArrayDef from './array';\nimport BooleanDef from './boolean';\nimport DateTimeDef from './datetime';\nimport NumberDef from './number';\nimport ObjectDef from './object';\nimport StringDef from './string';\nlet registered = false;\nexport default function registerTypes() {\n    if (registered)\n        return;\n    TypedefRegistry.register(AnyDef, ArrayDef, BooleanDef, NumberDef, ObjectDef, StringDef, DateTimeDef);\n    registered = true;\n}\n","import SyntaxError from '../../errors/io-syntax-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nexport function createMemberDef(input, opts) {\n    const allowNameless = opts?.allowNameless === true;\n    if (!input || typeof input !== 'object') {\n        throw new SyntaxError(ErrorCodes.invalidMemberDef, 'Invalid member definition input provided.');\n    }\n    const { name, type } = input;\n    if (!type || typeof type !== 'string') {\n        throw new SyntaxError(ErrorCodes.invalidType, 'MemberDef.type must be a non-empty string.');\n    }\n    if (!allowNameless && (!name || typeof name !== 'string' || name.trim() === '')) {\n        throw new SyntaxError(ErrorCodes.invalidMemberDef, 'MemberDef must have a valid name.');\n    }\n    // Basic shape checks for common compound types\n    if (type === 'array') {\n        if (!('of' in input) || typeof input.of !== 'object' || !input.of) {\n            throw new SyntaxError(ErrorCodes.invalidDefinition, \"Array MemberDef must include an 'of' definition.\");\n        }\n    }\n    // Normalize boolean-like flags when provided\n    const out = { ...input };\n    if ('optional' in out && out.optional !== undefined) {\n        out.optional = Boolean(out.optional);\n    }\n    if ('null' in out && out.null !== undefined) {\n        out.null = Boolean(out.null);\n    }\n    return out;\n}\nexport default createMemberDef;\n","import TokenNode from '../../parser/nodes/tokens';\nimport ObjectNode from '../../parser/nodes/objects';\nimport ArrayNode from '../../parser/nodes/array';\nimport TypedefRegistry from '../typedef-registry';\n/**\n * Converts additional property schema node to canonical MemberDef.\n * Supports: string, object, array, MemberDef with constraints, open forms.\n */\nexport function canonicalizeAdditionalProps(node, path = '*') {\n    // Switch on node type\n    if (node instanceof TokenNode) {\n        if (typeof node.value === 'string') {\n            // Built-in types (string, int, bool, etc.)\n            if (TypedefRegistry.isRegisteredType(node.value)) {\n                return { type: node.value, path };\n            }\n            // Open form: *\n            if (node.value === '*') {\n                return { type: 'any', path };\n            }\n        }\n        return { type: 'any', path };\n    }\n    if (node instanceof ObjectNode) {\n        // Open object form: {}\n        if (node.children.length === 0) {\n            return { type: 'object', path, open: true };\n        }\n        // Check if first child is a MemberNode with no key and value is TokenNode (type)\n        const firstChild = node.children[0];\n        if (firstChild && !firstChild.key && firstChild.value instanceof TokenNode) {\n            const typeToken = firstChild.value;\n            if (typeof typeToken.value === 'string' && TypedefRegistry.isRegisteredType(typeToken.value)) {\n                // Collect constraints from other children (MemberNode with key)\n                const memberDef = { type: typeToken.value, path };\n                for (let i = 1; i < node.children.length; i++) {\n                    const child = node.children[i];\n                    if (child && child.key && child.value instanceof TokenNode) {\n                        memberDef[child.key.value] = child.value.value;\n                    }\n                }\n                return memberDef;\n            }\n        }\n        // MemberDef with constraints (fallback)\n        return { type: 'object', path };\n    }\n    if (node instanceof ArrayNode) {\n        // Open array form: []\n        if (node.children.length === 0) {\n            return { type: 'array', path, of: { type: 'any' } };\n        }\n        // Array of type: [string]\n        const child = node.children[0];\n        if (child instanceof TokenNode && typeof child.value === 'string') {\n            return { type: 'array', path, of: { type: child.value } };\n        }\n        return { type: 'array', path };\n    }\n    // Already a MemberDef or unknown node\n    if (typeof node === 'object' && node.type) {\n        return { ...node, path };\n    }\n    return { type: 'any', path };\n}\n","import TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport Token from '../../parser/tokenizer/tokens';\nimport SyntaxError from '../../errors/io-syntax-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport assertNever from '../../errors/asserts/asserts';\n// Normalize a key token: accept Token or TokenNode(STRING) and return a TokenNode(STRING)\nexport function normalizeKeyToken(keyNode) {\n    if (!keyNode) {\n        assertNever('Key node must not be null in schema definition.');\n    }\n    if (keyNode instanceof TokenNode) {\n        if (keyNode.type === TokenType.STRING)\n            return keyNode;\n    }\n    else if (keyNode instanceof Token) {\n        if (keyNode.type === TokenType.STRING)\n            return new TokenNode(keyNode);\n    }\n    throw new SyntaxError(ErrorCodes.invalidKey, 'The key must be a string.', keyNode);\n}\n","import assertNever from '../errors/asserts/asserts';\nimport SyntaxError from '../errors/io-syntax-error';\nimport ErrorCodes from '../errors/io-error-codes';\nimport ArrayNode from '../parser/nodes/array';\nimport MemberNode from '../parser/nodes/members';\nimport ObjectNode from '../parser/nodes/objects';\nimport TokenNode from '../parser/nodes/tokens';\nimport TokenType from '../parser/tokenizer/token-types';\nimport TypedefRegistry from './typedef-registry';\nimport processSchema from './processor';\nimport Schema from './schema';\nimport Token from '../parser/tokenizer/tokens';\nimport registerTypes from './types';\nimport createMemberDef from './types/memberdef-factory';\nimport { canonicalizeAdditionalProps } from './utils/additional-props-canonicalizer';\nimport { normalizeKeyToken } from './utils/member-utils';\n// Register built-in types\nregisterTypes();\nexport default function compileObject(name, node, defs) {\n    // Check if the node is a string token and starts with $. If yes, then\n    // it is a schema variable. In this case, just return the node as it is\n    // to be processed later.\n    if (node instanceof TokenNode &&\n        node.type === TokenType.STRING &&\n        node.value.startsWith('$')) {\n        return node;\n    }\n    if (node instanceof ObjectNode === false) {\n        throw new SyntaxError(ErrorCodes.invalidSchema, \"Schema must be an object.\", node);\n    }\n    const schema = new Schema(name);\n    parseObjectDef(node, schema, \"\", defs);\n    return schema;\n}\nfunction parseObjectOrTypeDef(o, path, defs) {\n    // When the object node is empty object, then the type definition is\n    // object without schema definition. Such objects can accept any object\n    // as value.\n    // For example:\n    // address: {},\n    if (o.children.length === 0) {\n        const schema = new Schema(path);\n        schema.open = true;\n        return {\n            type: 'object',\n            path,\n            schema\n        };\n    }\n    // When the object node is type definition. The type deinition has first\n    // member as the type name\n    // For example:\n    // age: { number, min: 10, max: 20 }\n    const firstNode = o.children[0];\n    if (!firstNode.key) {\n        if (firstNode.value instanceof TokenNode) {\n            const token = firstNode.value;\n            if (token.type === TokenType.STRING) {\n                // Built-in type shorthand: { string, min: ..., max: ... }\n                if (TypedefRegistry.isRegisteredType(token.value)) {\n                    return parseMemberDef(token.value, o);\n                }\n                // Schema variable shorthand: { $Person, ... }\n                if (typeof token.value === 'string' && token.value.startsWith('$')) {\n                    return { type: 'object', schema: token, path };\n                }\n            }\n        }\n    }\n    // When the object node is a member type definition defined using the\n    // object definition syntax. It must hae a type property.\n    // For example:\n    // name: { min: 10, max: 20, type: string }\n    let type = '';\n    let typeNode = null;\n    for (let i = 0; i < o.children.length; i++) {\n        const child = o.children[i];\n        if (child instanceof MemberNode && child.key && child.key.value === 'type') {\n            if (child.value instanceof TokenNode && child.value.type === TokenType.STRING) {\n                type = child.value.value;\n                typeNode = child.value;\n                break;\n            }\n        }\n    }\n    // If type exists, and a valid type, then parse the member definition\n    // name: { minLength: 10, maxLength: 20, type: string }\n    if (type !== '') {\n        // Support type: $SchemaVar\n        if (typeof type === 'string' && type.startsWith('$')) {\n            return { type: 'object', schema: typeNode, path };\n        }\n        if (TypedefRegistry.isRegisteredType(type)) {\n            return parseMemberDef(type, o);\n        }\n        // If the type is not registered, then it is an invalid type\n        // name: { minLength: 10, maxLength: 20, type: xyz }\n        throw new SyntaxError(ErrorCodes.invalidType, `The specified value '${type}' is not a valid type.`, typeNode);\n    }\n    // If the type is not defined, then consider it an object type with\n    // custom schema.\n    return {\n        type: 'object',\n        schema: parseObjectDef(o, new Schema(path), path, defs),\n        path,\n    };\n}\n// field: {array, of:string, minLen:2}         # Array of strings with minimum length of 2\n// field: {array, of:string}                   # Array of strings\n// field: {of:string, type:array, minLen:2}    # Array of strings with minimum length of 2\n// field: {array, of:{ name: string, age: number }} # Array of objects\n// field: {array, of:[string]}                 # Array of arrays of strings\n// field: {array, of:{array, of:{}, minLen: 2 }} # Array of arrays of any type of objects with minimum length of 2\n//\n// Array Objects\n// field: { [], choices:[[a, b, c], [d, e, f]] }\n// Array MemberDefs\n// field: []                                   # Array of any type\n// field: [string]                             # Array of strings\n// field: [ [string] ]                         # Array of arrays of strings\n// field: [ { name: string, age: number } ]    # Array of objects\n// field: [ [ { name: string, age: number } ] ]# Array of arrays of objects\n// field: [ {type:string, len:6, pattern:r'[a-z0-9]+'} ]   # Array of strings with length of 6 and alphanumeric values\nfunction parseArrayOrTypeDef(a, path, defs) {\n    // The length of the array child must be <= 1. If the length is > 1, then\n    // it is an invalid schema.\n    if (a.children.length > 1) {\n        throw new SyntaxError(ErrorCodes.invalidSchema, \"The array definition must have only one child.\", a.children[1]);\n    }\n    // When the array node is empty array, then the type definition is\n    // array without schema definition. Such arrays can accept any type items\n    // in the array.\n    // For example:\n    // tags: []\n    if (a.children.length === 0) {\n        return createMemberDef({\n            type: 'array',\n            of: {\n                type: 'any',\n                path,\n                null: true,\n            },\n            path,\n        }, { allowNameless: true });\n    }\n    // When the array node has one child, then it is a type definition.\n    // For example:\n    // tags: [string], friends: [ { name: string, age: number } ]\n    //\n    const child = a.children[0];\n    if (child instanceof TokenNode) {\n        if (child.type === TokenType.STRING) {\n            const type = child.value;\n            // [string], [number], [boolean], [object], [array] etc.\n            if (TypedefRegistry.isRegisteredType(type)) {\n                return createMemberDef({\n                    type: 'array',\n                    of: {\n                        type: child.value,\n                        path,\n                    },\n                    path,\n                }, { allowNameless: true });\n            }\n            // If the type is a schema variable, then return the schema variable\n            // [$employee], [$address], [$person] etc.\n            else if (!!defs && type.startsWith('$')) {\n                return createMemberDef({\n                    type: 'array',\n                    of: {\n                        type: 'object',\n                        schema: child,\n                        path,\n                    },\n                    path,\n                }, { allowNameless: true });\n            }\n        }\n        // If the type is not registered, then it is an invalid type\n        throw new SyntaxError(ErrorCodes.invalidType, `The specified value (${child.value}) is not a valid type`, child);\n    }\n    // If the child is an object node, then it is a member type definition\n    // For example:\n    // friends: [ { name: string, age: number } ]\n    if (child instanceof ObjectNode) {\n        return createMemberDef({\n            type: 'array',\n            of: parseObjectOrTypeDef(child, path, defs),\n            path,\n        }, { allowNameless: true });\n    }\n    // If the child is an array node, then it is an array type definition\n    // For example:\n    // friends: [ [string] ] or friends: [ [ { name: string, age: number } ] ]\n    if (child instanceof ArrayNode) {\n        return createMemberDef({\n            type: 'array',\n            of: parseArrayOrTypeDef(child, path, defs),\n            path,\n        }, { allowNameless: true });\n    }\n    // Throw an error if the child is not a string or object node\n    throw new SyntaxError(ErrorCodes.invalidSchema, \"The array of type definition must be a string or object.\", child);\n}\n// function parseArrayDef(o: ObjectNode, schema:Schema, path:string, defs?:Definitions): Schema {\n// }\nfunction parseObjectDef(o, schema, path, defs) {\n    // Note: empty-object and no-names cases are handled explicitly below.\n    for (let index = 0; index < o.children.length; index++) {\n        const child = o.children[index];\n        if (child === null) {\n            assertNever(\"Child value must not be null in schema definition.\");\n        }\n        const memberNode = child;\n        if (memberNode.value instanceof TokenNode && memberNode.value.type === TokenType.UNDEFINED) {\n            throw new SyntaxError(ErrorCodes.emptyMemberDef, \"The next member definition is empty.\", memberNode.value);\n        }\n        // Handle additional properties (dynamic fields)\n        if (memberNode.key && memberNode.key.value === '*') {\n            // Use canonicalizer for additional property MemberDef\n            if (memberNode.value) {\n                const additionalDef = canonicalizeAdditionalProps(memberNode.value, '*');\n                schema.defs['*'] = additionalDef;\n                schema.open = additionalDef;\n            }\n            else {\n                schema.open = true;\n            }\n            if (index !== o.children.length - 1) {\n                throw new SyntaxError(ErrorCodes.invalidSchema, \"The * is only allowed at the last position.\", memberNode.value);\n            }\n            continue;\n        }\n        // Regular member\n        if (memberNode.key) {\n            const memberDef = getMemberDef(memberNode, path, defs);\n            addMemberDef(memberDef, schema, path);\n        }\n        else {\n            // If the last index and the value is *, then this is an open schema\n            const open = memberNode.value instanceof TokenNode && memberNode.value.type === TokenType.STRING && memberNode.value.value === '*';\n            if (open) {\n                if (index !== o.children.length - 1) {\n                    throw new SyntaxError(ErrorCodes.invalidSchema, \"The * is only allowed at the last position.\", memberNode.value);\n                }\n                schema.open = true;\n                continue;\n            }\n            // Normalize key token for keyless path to ensure Token | TokenNode(STRING)\n            const keyToken = normalizeKeyToken(memberNode.value);\n            const fieldInfo = parseName(keyToken);\n            // Always infer type as 'any' if not explicitly provided\n            const memberDef = createMemberDef({\n                ...fieldInfo,\n                type: 'any'\n            });\n            addMemberDef(memberDef, schema, path);\n        }\n    }\n    if (schema.names.length === 0) {\n        schema.open = true;\n    }\n    return schema;\n}\nfunction parseMemberDef(type, o) {\n    const typeDef = TypedefRegistry.get(type);\n    const memberDef = processSchema(o, typeDef.schema);\n    return memberDef?.toJSON();\n}\nfunction addMemberDef(memberDef, schema, path) {\n    // Duplicate member detection (compile-time)\n    if (schema.defs[memberDef.name]) {\n        throw new SyntaxError(ErrorCodes.duplicateMember, `Member ${memberDef.name} is already defined in schema ${schema.name}.`, schema.defs[memberDef.name]);\n    }\n    memberDef.path = _(path, memberDef.name);\n    schema.names.push(memberDef.name);\n    schema.defs[memberDef.name] = memberDef;\n}\nconst parseName = (keyNode) => {\n    if (!keyNode) {\n        assertNever(\"Key node must not be null in schema definition.\");\n    }\n    if (!(keyNode instanceof Token)) {\n        throw new SyntaxError(ErrorCodes.invalidKey, \"The key must be a string.\", keyNode);\n    }\n    const key = keyNode.value;\n    const optionalExp = /\\?$/;\n    const nullExp = /\\*$/;\n    const optNullExp = /(\\?\\*)|(\\*\\?)$/;\n    if (keyNode.type !== TokenType.STRING) {\n        throw new SyntaxError(ErrorCodes.invalidKey, \"The key must be a string.\", keyNode);\n    }\n    // Optional and null\n    if (key.match(optNullExp)) {\n        return {\n            name: key.substring(0, key.length - 2),\n            optional: true,\n            null: true\n        };\n    }\n    // null\n    if (key.match(nullExp)) {\n        return {\n            name: key.substring(0, key.length - 1),\n            optional: false,\n            null: true\n        };\n    }\n    // Optional\n    if (key.match(optionalExp) !== null) {\n        return {\n            name: key.substring(0, key.length - 1),\n            optional: true,\n            null: false\n        };\n    }\n    return { name: key, optional: false, null: false };\n};\n// moved to utils/member-utils.ts\nexport function getMemberDef(memberDef, path, defs) {\n    const node = memberDef.value;\n    let fieldInfo = { name: \"\" };\n    if (memberDef.key) {\n        fieldInfo = parseName(normalizeKeyToken(memberDef.key));\n    }\n    // If the value token is a string, then ensure that it is a valid type\n    // For example:\n    // name: string, age: number\n    if (node instanceof TokenNode && node.type === TokenType.STRING) {\n        const type = node.value;\n        // If the type string starts with $, then it is a schema variable\n        if (type.startsWith('$')) {\n            return {\n                ...fieldInfo,\n                type: \"object\",\n                schema: node,\n            };\n        }\n        if (TypedefRegistry.isRegisteredType(type) === false) {\n            throw new SyntaxError(ErrorCodes.invalidType, `The specified value '${type}' is not a valid type.`, node);\n        }\n        return {\n            ...fieldInfo,\n            type,\n        };\n    }\n    // If the value token is an object, then parse the object definition\n    if (node instanceof ObjectNode) {\n        const objectDef = parseObjectOrTypeDef(node, _(path, fieldInfo.name));\n        return {\n            ...fieldInfo,\n            ...objectDef,\n        };\n    }\n    // If the value token is an array, then parse the array definition\n    if (node instanceof ArrayNode) {\n        const arrayDef = parseArrayOrTypeDef(node, _(path, fieldInfo.name), defs);\n        return {\n            ...fieldInfo,\n            ...arrayDef,\n        };\n    }\n    throw new SyntaxError(ErrorCodes.invalidType, `Found '${node.toValue()}' but expecting a data type definition.`, node);\n}\n// concacts the path and key\nfunction _(path, key) {\n    if (path === \"\") {\n        return key;\n    }\n    return `${path}.${key}`;\n}\n","/**\n * Utility functions for creating proper error ranges across tokenizer, parser, and validator.\n *\n * Industry-standard approach (TypeScript, Roslyn, rust-analyzer):\n * 1. Single-token errors: Highlight the specific problematic token\n * 2. Construct errors: Span entire construct (from opening to expected closing)\n * 3. Validation errors: Highlight the exact value that failed validation\n * 4. Unclosed/unterminated: From start to end of input or boundary\n */\n/**\n * Creates a PositionRange from a single token.\n * Use for: Invalid characters, unexpected tokens, type mismatches.\n *\n * @param token - The token to create range from\n * @returns PositionRange spanning the token\n */\nexport function singleTokenRange(token) {\n    return {\n        getStartPos: () => token.getStartPos(),\n        getEndPos: () => token.getEndPos()\n    };\n}\n/**\n * Creates a PositionRange spanning multiple tokens.\n * Use for: Multi-token expressions, schema definitions.\n *\n * @param startToken - First token of the range\n * @param endToken - Last token of the range\n * @returns PositionRange spanning from start to end\n */\nexport function tokenSpanRange(startToken, endToken) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => endToken.getEndPos()\n    };\n}\n/**\n * Creates a PositionRange for unclosed constructs (strings, arrays, objects).\n * Industry standard: Span from opening delimiter to where closing should be.\n *\n * @param startToken - Opening delimiter token (\", [, {, etc.)\n * @param currentPos - Current position when error detected\n * @returns PositionRange spanning the unclosed construct\n */\nexport function unclosedConstructRange(startToken, currentPos) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => currentPos\n    };\n}\n/**\n * Creates a PositionRange for construct with explicit start and end positions.\n * Use for: Validation errors on specific values, type mismatches.\n *\n * @param startPos - Start position\n * @param endPos - End position\n * @returns PositionRange spanning the positions\n */\nexport function positionSpanRange(startPos, endPos) {\n    return {\n        getStartPos: () => startPos,\n        getEndPos: () => endPos\n    };\n}\n/**\n * Sets the position range on an error object.\n * Automatically updates the error message to include position.\n *\n * @param error - The error to set range on\n * @param range - The position range\n * @returns The error (for chaining)\n */\nexport function setErrorRange(error, range) {\n    error.positionRange = range;\n    return error;\n}\n/**\n * Creates a PositionRange from a start token to end of available content.\n * Use for: Unterminated strings, unclosed brackets at EOF.\n *\n * @param startToken - Opening token\n * @param lastPos - Last valid position in the input\n * @returns PositionRange from start to last position\n */\nexport function toEndOfInputRange(startToken, lastPos) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => lastPos\n    };\n}\n/**\n * Helper to create a Position object.\n *\n * @param pos - Absolute position\n * @param row - Line number (1-based)\n * @param col - Column number (1-based)\n * @returns Position object\n */\nexport function createPosition(pos, row, col) {\n    return { pos, row, col };\n}\n","/**\n * Enumeration representing special symbols in IO.\n */\nvar Symbols;\n(function (Symbols) {\n    Symbols[\"CURLY_OPEN\"] = \"{\";\n    Symbols[\"CURLY_CLOSE\"] = \"}\";\n    Symbols[\"BRACKET_OPEN\"] = \"[\";\n    Symbols[\"BRACKET_CLOSE\"] = \"]\";\n    Symbols[\"COLON\"] = \":\";\n    Symbols[\"COMMA\"] = \",\";\n    Symbols[\"HASH\"] = \"#\";\n    Symbols[\"DOUBLE_QUOTE\"] = \"\\\"\";\n    Symbols[\"SINGLE_QUOTE\"] = \"'\";\n    Symbols[\"BACKSLASH\"] = \"\\\\\";\n    Symbols[\"TILDE\"] = \"~\";\n    Symbols[\"PLUS\"] = \"+\";\n    Symbols[\"MINUS\"] = \"-\";\n    Symbols[\"DOLLAR\"] = \"$\";\n    Symbols[\"DOT\"] = \".\";\n})(Symbols || (Symbols = {}));\nexport default Symbols;\n","import Symbols from \"./symbols\";\nimport TokenType from \"./token-types\";\nconst reSpaces = /\\s/;\nconst reHSpaces = /[ \\t]+/;\n/**\n  * Check if the given character is a special symbol.\n  * @param {string} char - Character to check.\n  * @returns {boolean} True if the character is a special symbol, else false.\n  */\nexport const isSpecialSymbol = (char) => {\n    // const symbols = ['{', '}', '[', ']', ':', ',', '~'];\n    const symbols = [\n        Symbols.CURLY_OPEN,\n        Symbols.CURLY_CLOSE,\n        Symbols.BRACKET_OPEN,\n        Symbols.BRACKET_CLOSE,\n        Symbols.COLON,\n        Symbols.COMMA,\n        Symbols.TILDE,\n        // TODO: Ensure that the following symbols are good to be included here.\n        Symbols.DOUBLE_QUOTE,\n        Symbols.SINGLE_QUOTE,\n    ];\n    return symbols.includes(char);\n};\n/**\n  * Check if the given character is a digit.\n  * @param char The character to check.\n  * @returns {boolean} True if the character is a digit, else false.\n  */\nexport const isDigit = (char) => {\n    return /[0-9]/.test(char);\n};\n// Pre-computed lookup for specific Unicode whitespace characters\nconst WHITESPACE_LOOKUP = new Set([\n    0x1680,\n    0x2028,\n    0x2029,\n    0x202F,\n    0x205F,\n    0x3000,\n    0xFEFF // BOM/Zero width no-break space\n]);\n/**\n  * Check if the given character represents a whitespace.\n  * @param {string} char - Character to check.\n  * @param {boolean} hspacesOnly - If true, only check for horizontal spaces (space and tab).\n  * @returns {boolean} True if the character is a whitespace, else false.\n  */\nexport const isWhitespace = (char, hspacesOnly = false) => {\n    if (hspacesOnly) {\n        return char === ' ' || char === '\\t';\n    }\n    // Use codePointAt for proper Unicode handling\n    const code = char.codePointAt(0) || 0;\n    // Fast path: ASCII whitespace and control characters (U+0000 to U+0020)\n    if (code <= 0x20) {\n        return true;\n    }\n    // Fast path: Extended ASCII range (U+0021 to U+00FF) - only U+00A0 is whitespace\n    if (code <= 0xFF) {\n        return code === 0x00A0;\n    }\n    // Fast path: Anything above U+FEFF is never whitespace\n    if (code > 0xFEFF) {\n        return false;\n    }\n    // Fast path: Unicode range U+2000-U+200A (various em/en spaces)\n    if (code >= 0x2000 && code <= 0x200A) {\n        return true;\n    }\n    // Lookup table for remaining Unicode whitespace characters\n    return WHITESPACE_LOOKUP.has(code);\n};\n/**\n * Check if the given character is valid newline character. It is valid if it\n * is either a carriage return or a line feed.\n */\nexport const isValidNewline = (char) => {\n    return char === '\\r' || char === '\\n';\n};\n/**\n* Check if the given character is an alphabetic character.\n*/\nexport const isValidOpenStringChar = (char) => {\n    // Define terminators based on IO's spec.\n    // const terminators = [\"{\", \"}\", \"[\", \"]\", \":\", \",\", \"\\\"\", \"'\", \"@\", undefined];\n    const terminators = [\n        Symbols.CURLY_OPEN,\n        Symbols.CURLY_CLOSE,\n        Symbols.BRACKET_OPEN,\n        Symbols.BRACKET_CLOSE,\n        Symbols.COLON,\n        Symbols.COMMA,\n        Symbols.HASH,\n        Symbols.DOUBLE_QUOTE,\n        Symbols.SINGLE_QUOTE,\n        Symbols.TILDE,\n    ];\n    return !terminators.includes(char);\n};\n/**\n  * Determine the token type for a special symbol.\n  * @param {string} char - Special symbol character.\n  * @returns {string} Token type.\n  */\nexport const getSymbolTokenType = (char) => {\n    switch (char) {\n        case '{': return TokenType.CURLY_OPEN;\n        case '}': return TokenType.CURLY_CLOSE;\n        case '[': return TokenType.BRACKET_OPEN;\n        case ']': return TokenType.BRACKET_CLOSE;\n        case ':': return TokenType.COLON;\n        case ',': return TokenType.COMMA;\n        case '~': return TokenType.COLLECTION_START;\n        default: return TokenType.UNKNOWN;\n    }\n};\n","var Literals;\n(function (Literals) {\n    Literals[\"NULL\"] = \"null\";\n    Literals[\"N\"] = \"N\";\n    Literals[\"TRUE\"] = \"true\";\n    Literals[\"T\"] = \"T\";\n    Literals[\"FALSE\"] = \"false\";\n    Literals[\"F\"] = \"F\";\n    Literals[\"Inf\"] = \"Inf\";\n    Literals[\"PositiveInf\"] = \"+Inf\";\n    Literals[\"NegativeInf\"] = \"-Inf\";\n    Literals[\"NaN\"] = \"NaN\";\n})(Literals || (Literals = {}));\nexport default Literals;\n","import Decimal from '../../core/decimal';\nimport assertNever from '../../errors/asserts/asserts';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport SyntaxError from '../../errors/io-syntax-error';\nimport { unclosedConstructRange, createPosition } from '../../errors/error-range-utils';\nimport * as dtParser from '../../utils/datetime';\nimport * as is from './is';\nimport Literals from './literals';\nimport Symbols from './symbols';\nimport TokenType from './token-types';\nimport Token from './tokens';\n// Cached regex patterns for performance optimization\nconst REGEX_CACHE = {\n    hex4: /^[0-9a-fA-F]{4}$/,\n    hex2: /^[0-9a-fA-F]{2}$/,\n    floatDigit: /^[0-9.]+$/,\n    intDigit: /^[0-9]+$/,\n    hex: /^[0-9a-fA-F]+$/,\n    octal: /^[0-7]+$/,\n    binary: /^[01]+$/,\n    sectionSchemaName: /^(?:(?:(?<name>[\\p{L}\\p{M}\\p{N}\\-_]+)(?<sep>[ \\t]*:[ \\t]*)?)(?<schema>\\$[\\p{L}\\p{M}\\p{N}\\-_]+)?|(?<schema2>\\$[\\p{L}\\p{M}\\p{N}\\-_]+))/u,\n    annotatedStrStart: /^(?<name>[a-zA-Z]{1,4})(?<quote>['\"])/,\n    base64: /^[A-Za-z0-9+/]*={0,2}$/\n};\n// Character code constants for ultra-fast character checking\nconst CHAR_CODES = {\n    SPACE: 32,\n    TAB: 9,\n    NEWLINE: 10,\n    CARRIAGE_RETURN: 13,\n    DOUBLE_QUOTE: 34,\n    SINGLE_QUOTE: 39,\n    HASH: 35,\n    PLUS: 43,\n    MINUS: 45,\n    DOT: 46,\n    ZERO: 48,\n    NINE: 57,\n    COLON: 58,\n    COMMA: 44,\n    CURLY_OPEN: 123,\n    CURLY_CLOSE: 125,\n    BRACKET_OPEN: 91,\n    BRACKET_CLOSE: 93,\n    BACKSLASH: 92,\n    TILDE: 126,\n    A_UPPER: 65,\n    F_UPPER: 70,\n    A_LOWER: 97,\n    F_LOWER: 102,\n    X_UPPER: 88,\n    X_LOWER: 120,\n    O_UPPER: 79,\n    O_LOWER: 111,\n    B_UPPER: 66,\n    B_LOWER: 98 // 'b'\n};\n// Fast character checking functions using character codes\nconst isDigitFast = (charCode) => charCode >= CHAR_CODES.ZERO && charCode <= CHAR_CODES.NINE;\nconst isHexDigitFast = (charCode) => isDigitFast(charCode) ||\n    (charCode >= CHAR_CODES.A_UPPER && charCode <= CHAR_CODES.F_UPPER) ||\n    (charCode >= CHAR_CODES.A_LOWER && charCode <= CHAR_CODES.F_LOWER);\n// Pre-computed lookup for specific Unicode whitespace characters (matching is.ts)\nconst WHITESPACE_LOOKUP_FAST = new Set([\n    0x1680,\n    0x2028,\n    0x2029,\n    0x202F,\n    0x205F,\n    0x3000,\n    0xFEFF // BOM/Zero width no-break space\n]);\n/**\n * Fast whitespace checking that matches the specification in is.ts\n */\nconst isWhitespaceFast = (charCode) => {\n    // Fast path: ASCII whitespace and control characters (U+0000 to U+0020)\n    if (charCode <= 0x20) {\n        return true;\n    }\n    // Fast path: Extended ASCII range (U+0021 to U+00FF) - only U+00A0 is whitespace\n    if (charCode <= 0xFF) {\n        return charCode === 0x00A0;\n    }\n    // Fast path: Anything above U+FEFF is never whitespace\n    if (charCode > 0xFEFF) {\n        return false;\n    }\n    // Fast path: Unicode range U+2000-U+200A (various em/en spaces)\n    if (charCode >= 0x2000 && charCode <= 0x200A) {\n        return true;\n    }\n    // Lookup table for remaining Unicode whitespace characters\n    return WHITESPACE_LOOKUP_FAST.has(charCode);\n};\nconst regexHex4 = REGEX_CACHE.hex4;\nconst regexHex2 = REGEX_CACHE.hex2;\nconst reFloatDigit = REGEX_CACHE.floatDigit;\nconst reIntDigit = REGEX_CACHE.intDigit;\nconst reHex = REGEX_CACHE.hex;\nconst reOctal = REGEX_CACHE.octal;\nconst reBinary = REGEX_CACHE.binary;\n// https://regex101.com/r/HOVtCj/1\n// const reSectionSchemaName = /^(?<schema>\\$[\\p{L}\\p{M}\\p{N}\\-_]+)(?:[ \\t]*:[ \\t]*(?<name>[\\p{L}\\p{M}\\p{N}\\-_]+))?/u;\n// https://regex101.com/r/jaWr0V/2\n// Cached constants for performance\nconst NON_DECIMAL_PREFIXES = [\"x\", \"X\", \"o\", \"O\", \"b\", \"B\"];\nconst reSectionSchemaName = REGEX_CACHE.sectionSchemaName;\nconst nonDecimalPrefixes = NON_DECIMAL_PREFIXES;\nconst reAnotatedStrStart = REGEX_CACHE.annotatedStrStart;\n/**\n * Tokenizer for IO format.\n */\nclass Tokenizer {\n    /**\n     * Initialize the tokenizer with an input string.\n     * @param input - String to be tokenized.\n     */\n    constructor(input) {\n        this.pos = 0; // Current position within the input string\n        this.input = \"\"; // Input string to tokenize\n        this.row = 1; // Current row within the input string\n        this.col = 1; // Current column within the input string\n        this.reachedEnd = false; // True if the end of the input string has been reached, else false\n        this.inputLength = 0; // Cache input length for performance\n        this.input = input;\n        this.inputLength = input.length; // Cache length for performance\n    }\n    /**\n     * Fast character checking for special symbols using character codes\n     */\n    isSpecialSymbolFast(charCode) {\n        return charCode === CHAR_CODES.CURLY_OPEN || charCode === CHAR_CODES.CURLY_CLOSE ||\n            charCode === CHAR_CODES.BRACKET_OPEN || charCode === CHAR_CODES.BRACKET_CLOSE ||\n            charCode === CHAR_CODES.COMMA || charCode === CHAR_CODES.COLON ||\n            charCode === CHAR_CODES.TILDE;\n    }\n    /**\n     * Fast token type lookup for special symbols using character codes\n     */\n    getSymbolTokenTypeFast(charCode) {\n        switch (charCode) {\n            case CHAR_CODES.CURLY_OPEN: return TokenType.CURLY_OPEN;\n            case CHAR_CODES.CURLY_CLOSE: return TokenType.CURLY_CLOSE;\n            case CHAR_CODES.BRACKET_OPEN: return TokenType.BRACKET_OPEN;\n            case CHAR_CODES.BRACKET_CLOSE: return TokenType.BRACKET_CLOSE;\n            case CHAR_CODES.COMMA: return TokenType.COMMA;\n            case CHAR_CODES.COLON: return TokenType.COLON;\n            case CHAR_CODES.TILDE: return TokenType.COLLECTION_START;\n            default: return TokenType.UNKNOWN;\n        }\n    }\n    /**\n     * Create an error token for invalid input and continue tokenizing.\n     * @param error - The error that occurred\n     * @param startPos - Starting position of the invalid token\n     * @param startRow - Starting row of the invalid token\n     * @param startCol - Starting column of the invalid token\n     * @param tokenText - The invalid token text\n     */\n    createErrorToken(error, startPos, startRow, startCol, tokenText) {\n        return Token.init(startPos, startRow, startCol, tokenText, {\n            __error: true,\n            message: error.message,\n            originalError: error\n        }, TokenType.ERROR);\n    }\n    /**\n     * Skip to the next valid token boundary after an error.\n     * This helps recover from parsing errors by advancing to a safe position.\n     */\n    skipToNextTokenBoundary() {\n        // Skip characters until we find a delimiter, whitespace, or special symbol\n        while (!this.reachedEnd &&\n            !is.isWhitespace(this.input[this.pos]) &&\n            !is.isSpecialSymbol(this.input[this.pos]) &&\n            this.input[this.pos] !== ',' &&\n            this.input[this.pos] !== '\\n') {\n            this.advance();\n        }\n    }\n    /**\n     * Advance the current position and update the row and column accordingly.\n     */\n    advance(step = 1) {\n        if (this.reachedEnd) {\n            return;\n        }\n        // Optimize for single step (most common case)\n        if (step === 1) {\n            if (this.input.charCodeAt(this.pos) === CHAR_CODES.NEWLINE) {\n                this.row++;\n                this.col = 1;\n            }\n            else {\n                this.col++;\n            }\n            this.pos++;\n            if (this.pos >= this.inputLength) {\n                this.reachedEnd = true;\n            }\n            return;\n        }\n        // Handle multiple steps\n        for (let i = 0; i < step; i++) {\n            if (this.input.charCodeAt(this.pos) === CHAR_CODES.NEWLINE) {\n                this.row++;\n                this.col = 1;\n            }\n            else {\n                this.col++;\n            }\n            this.pos++;\n            if (this.pos >= this.inputLength) {\n                this.reachedEnd = true;\n                break;\n            }\n        }\n    }\n    parseSingleLineComment() {\n        while (!this.reachedEnd && this.input[this.pos] !== \"\\n\") {\n            this.advance();\n        }\n    }\n    parseRegularString(encloser) {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        this.advance(); // Move past the opening quotation mark\n        let value = \"\";\n        let needToNormalize = false;\n        while (!this.reachedEnd && this.input[this.pos] !== encloser) {\n            if (is.isWhitespace(this.input[this.pos])) {\n                value += this.skipWhitespaces();\n                continue;\n            }\n            // Check if current character is a backslash (escape character)\n            if (this.input[this.pos] === Symbols.BACKSLASH) {\n                try {\n                    ({ value, needToNormalize } = this.escapeString(value, needToNormalize));\n                    // escapeString has already advanced the position, so continue to next iteration\n                }\n                catch (error) {\n                    // For invalid escape sequences, treat them as literal characters without the backslash\n                    // Note: escapeString has already advanced past the backslash, so pos is at the escape char\n                    if (!this.reachedEnd) {\n                        const escapeChar = this.input[this.pos];\n                        value += escapeChar; // Add the escape character (u, x, etc.) without backslash\n                        // For \\u and \\x sequences, we need to add the invalid hex digits too\n                        if (escapeChar === 'u') {\n                            // Add the next 4 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 4 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else if (escapeChar === 'x') {\n                            // Add the next 2 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 2 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else {\n                            this.advance();\n                        }\n                    }\n                    continue;\n                }\n            }\n            else {\n                value += this.input[this.pos];\n                this.advance();\n            }\n        }\n        // If we reached the end without finding the closing quote,\n        // create an error token for the unclosed string\n        if (this.reachedEnd) {\n            const tokenText = this.input.substring(start, this.pos);\n            // Create a temporary token for the opening quote to get proper range\n            const openingToken = Token.init(start, startRow, startCol, '\"', '\"', \"STRING\");\n            const currentPos = createPosition(this.pos, this.row, this.col);\n            const error = new SyntaxError(ErrorCodes.stringNotClosed, `Unterminated string literal. Expected closing quote '\"' before end of input.`, unclosedConstructRange(openingToken, currentPos), true);\n            return this.createErrorToken(error, start, startRow, startCol, tokenText);\n        }\n        this.advance(); // Move past the closing quotation mark\n        const tokenText = this.input.substring(start, this.pos);\n        // After building the 'value' string, normalize it:\n        if (needToNormalize) {\n            value = value.normalize(\"NFC\");\n        }\n        return Token.init(start, startRow, startCol, tokenText, value, \"STRING\", \"REGULAR_STRING\");\n    }\n    escapeString(value, needToNormalize) {\n        this.advance(); // Move past the backslash\n        if (this.reachedEnd) {\n            throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid escape sequence at end of input. Expected escape character after backslash.`, this.currentPosition, true);\n        }\n        switch (this.input[this.pos]) {\n            case \"b\":\n                value += \"\\b\";\n                break;\n            case \"f\":\n                value += \"\\f\";\n                break;\n            case \"n\":\n                value += \"\\n\";\n                break;\n            case \"r\":\n                value += \"\\r\";\n                break;\n            case \"t\":\n                value += \"\\t\";\n                break;\n            case \"u\":\n                const hex = this.input.substring(this.pos + 1, this.pos + 5);\n                if (regexHex4.test(hex)) {\n                    // /^[0-9a-fA-F]{4}$/\n                    value += String.fromCharCode(parseInt(hex, 16));\n                    this.advance(4); // Move past the 4 hex digits\n                    needToNormalize = true;\n                }\n                else {\n                    throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid Unicode escape sequence '\\\\u${hex}'. Expected 4 hexadecimal digits (0-9, A-F).`, this.currentPosition);\n                }\n                break;\n            case \"x\":\n                const hexByte = this.input.substring(this.pos + 1, this.pos + 3);\n                if (regexHex2.test(hexByte)) {\n                    // /^[0-9a-fA-F]{2}$/\n                    value += String.fromCharCode(parseInt(hexByte, 16));\n                    this.advance(2); // Move past the 2 hex digits\n                    needToNormalize = true;\n                }\n                else {\n                    throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid hexadecimal escape sequence '\\\\x${hexByte}'. Expected 2 hexadecimal digits (0-9, A-F).`, this.currentPosition);\n                }\n                break;\n            default:\n                value += this.input[this.pos]; // Treat unrecognized escape sequences as literal characters without backslash\n                this.advance(); // Move past the escape character\n                break;\n        }\n        return { value, needToNormalize };\n    }\n    get currentPosition() {\n        const getPos = () => {\n            return {\n                pos: this.pos,\n                row: this.row,\n                col: this.col\n            };\n        };\n        return {\n            getStartPos: getPos,\n            getEndPos: getPos\n        };\n    }\n    checkIfAnotatedString() {\n        // Annotated strings starts with a letter and can have a maximum of 4 letters\n        // followed by a quotation mark (single or double).\n        const match = reAnotatedStrStart.exec(this.input.substring(this.pos, this.pos + 5));\n        if (!match) {\n            return null;\n        }\n        return match.groups;\n    }\n    parseAnotatedString(annotation) {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        // Skip over the annotation characters\n        for (let i = 0; i < annotation.name.length; i++) {\n            this.advance();\n        }\n        if (this.reachedEnd) {\n            const tokenText = this.input.substring(start, this.pos);\n            // Create a temporary token for the opening annotation to get proper range\n            const openingToken = Token.init(start, startRow, startCol, annotation.name + annotation.quote, annotation.name, \"STRING\");\n            const currentPos = createPosition(this.pos, this.row, this.col);\n            const error = new SyntaxError(ErrorCodes.stringNotClosed, `Unterminated annotated string literal. Expected closing quote '${annotation.quote}' before end of input.`, unclosedConstructRange(openingToken, currentPos), true);\n            return this.createErrorToken(error, start, startRow, startCol, tokenText);\n        }\n        this.advance(); // Move past the opening quotation mark\n        while (!this.reachedEnd && this.input[this.pos] !== annotation.quote) {\n            this.advance();\n        }\n        // If we reached the end without finding the closing quote,\n        // treat it as an annotated string that goes to EOF\n        const tokenText = this.input.substring(start, this.pos);\n        let value;\n        if (this.reachedEnd) {\n            // Extract value from unclosed string (from after opening quote to EOF)\n            value = tokenText.substring(annotation.name.length + 1);\n        }\n        else {\n            this.advance(); // Move past the closing quotation mark\n            const fullTokenText = this.input.substring(start, this.pos);\n            value = fullTokenText.substring(annotation.name.length + 1, fullTokenText.length - 1);\n        }\n        // Prepare the token\n        const token = new Token();\n        token.pos = start;\n        token.row = startRow;\n        token.col = startCol;\n        token.token = this.reachedEnd ? tokenText : this.input.substring(start, this.pos);\n        token.value = value;\n        return token;\n    }\n    parseRawString(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        token.type = TokenType.STRING;\n        token.subType = \"RAW_STRING\";\n        return token;\n    }\n    parseByteString(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        try {\n            // Validate base64 format using cached regex\n            if (!REGEX_CACHE.base64.test(token.value)) {\n                throw new Error(\"Invalid base64 format\");\n            }\n            token.type = TokenType.BINARY;\n            token.subType = \"BINARY_STRING\";\n            // Convert the base64 string to a byte array\n            token.value = Buffer.from(token.value, \"base64\");\n            return token;\n        }\n        catch (error) {\n            return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n        }\n    }\n    parseDateTime(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        try {\n            let fn = (value) => null;\n            switch (annotation.name) {\n                case \"dt\":\n                    fn = dtParser.parseDateTime;\n                    token.subType = TokenType.DATETIME;\n                    break;\n                case \"d\":\n                    fn = dtParser.parseDate;\n                    token.subType = TokenType.DATE;\n                    break;\n                case \"t\":\n                    fn = dtParser.parseTime;\n                    token.subType = TokenType.TIME;\n                    break;\n                default:\n                    assertNever(annotation);\n            }\n            const dt = fn(token.value);\n            if (!dt) {\n                const error = new SyntaxError(ErrorCodes.invalidDateTime, `Invalid ${annotation.name === 'dt' ? 'datetime' : annotation.name === 'd' ? 'date' : 'time'} format '${token.value}'. Expected valid ISO 8601 format.`, token);\n                return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n            }\n            token.value = dt;\n            token.type = TokenType.DATETIME;\n            return token;\n        }\n        catch (error) {\n            return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n        }\n    }\n    parseNumber() {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        let rawValue = \"\";\n        let base = 10; // default is decimal\n        let hasDecimal = false;\n        let hasExponent = false;\n        let prefix = \"\";\n        let subType;\n        // Check if current position points to a plus or minus sign.\n        if (this.input[this.pos] === \"+\" || this.input[this.pos] === \"-\") {\n            const sign = this.input[this.pos];\n            // If sign is followed by \"Inf\", handle infinite literal.\n            if (this.input.startsWith(\"Inf\", this.pos + 1)) {\n                const infLiteral = sign + \"Inf\";\n                this.advance(4); // sign + \"Inf\"\n                return Token.init(start, startRow, startCol, infLiteral, sign === \"+\" ? Infinity : -Infinity, TokenType.NUMBER);\n            }\n            // Otherwise, allow sign only if immediately followed by a digit or dot.\n            if (is.isDigit(this.input[this.pos + 1]) || this.input[this.pos + 1] === \".\") {\n                rawValue += sign;\n                this.advance();\n            }\n            else {\n                return null;\n            }\n        }\n        // Also support an Inf literal without a sign.\n        else if (this.input.startsWith(\"Inf\", this.pos)) {\n            const infLiteral = \"Inf\";\n            this.advance(3);\n            return Token.init(start, startRow, startCol, infLiteral, Infinity, TokenType.NUMBER);\n        }\n        if (this.input[this.pos] === \".\") {\n            // If there is a dot, ensure it is followed by a digit.\n            if (!reFloatDigit.test(this.input[this.pos + 1])) {\n                return null;\n            }\n        }\n        // Determine the number format\n        if (this.input[this.pos] === \"0\" && nonDecimalPrefixes.includes(this.input[this.pos + 1])) {\n            switch (this.input[this.pos + 1]) {\n                case \"X\":\n                case \"x\":\n                    base = 16;\n                    subType = \"HEX\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reHex.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                case \"O\":\n                case \"o\":\n                    base = 8;\n                    subType = \"OCTAL\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reOctal.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                case \"B\":\n                case \"b\":\n                    base = 2;\n                    subType = \"BINARY\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reBinary.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                default:\n                    assertNever(this.input[this.pos + 1]);\n            }\n        }\n        else {\n            // Parse whole part\n            while (reIntDigit.test(this.input[this.pos])) {\n                rawValue += this.input[this.pos];\n                this.advance();\n            }\n            // Parse decimal point and fractional part\n            if (this.input[this.pos] === \".\") {\n                hasDecimal = true;\n                rawValue += \".\";\n                this.advance();\n                while (reIntDigit.test(this.input[this.pos])) {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n            }\n            // Parse scientific notation (e.g., e10 or E10)\n            if (this.input[this.pos] === \"e\" || this.input[this.pos] === \"E\") {\n                hasExponent = true;\n                rawValue += this.input[this.pos];\n                this.advance();\n                if (this.input[this.pos] === \"+\" || this.input[this.pos] === \"-\") {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n                while (reIntDigit.test(this.input[this.pos])) {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n            }\n        }\n        let tokenType = TokenType.NUMBER;\n        let numberValue;\n        // if the next char is 'n', then it is a BigInt literal\n        if (this.input[this.pos] === \"n\") {\n            tokenType = TokenType.BIGINT;\n            numberValue = BigInt(prefix + rawValue);\n            rawValue += \"n\";\n            this.advance();\n        }\n        else if (this.input[this.pos] === \"m\") {\n            // Decimal literal\n            tokenType = TokenType.DECIMAL;\n            numberValue = new Decimal(rawValue);\n            rawValue += \"f\";\n            this.advance();\n        }\n        else {\n            if (base === 10 && (hasDecimal || hasExponent)) {\n                numberValue = parseFloat(rawValue);\n            }\n            else {\n                numberValue = parseInt(rawValue, base);\n                if (isNaN(numberValue)) {\n                    assertNever(\"Expected a number but got NaN\", this.currentPosition.getStartPos());\n                }\n            }\n        }\n        return Token.init(start, startRow, startCol, prefix + rawValue, numberValue, tokenType, subType);\n    }\n    parseLiteralOrOpenString() {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        let value = \"\";\n        let normalizeString = false;\n        while (!this.reachedEnd && is.isValidOpenStringChar(this.input[this.pos])) {\n            let char = this.input[this.pos];\n            if (is.isWhitespace(char)) {\n                value += this.skipWhitespaces();\n                continue;\n            }\n            if (char === Symbols.MINUS) {\n                // if the next two chars are -- that means it is a\n                // section seperator.\n                if (this.input.substring(this.pos, this.pos + 3) === \"---\") {\n                    break;\n                }\n            }\n            if (char === Symbols.BACKSLASH) {\n                try {\n                    ({ value, needToNormalize: normalizeString } = this.escapeString(value, normalizeString));\n                    // escapeString has already advanced the position, so continue to next iteration\n                    continue;\n                }\n                catch (error) {\n                    // For open strings, preserve the backslash and the escape character\n                    // Note: escapeString has already advanced past the backslash, so pos is at the escape char\n                    value += \"\\\\\";\n                    if (!this.reachedEnd) {\n                        const escapeChar = this.input[this.pos];\n                        value += escapeChar; // Add the escape character (u, x, etc.)\n                        // For \\u and \\x sequences, we need to add the invalid hex digits too\n                        if (escapeChar === 'u') {\n                            // Add the next 4 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 4 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else if (escapeChar === 'x') {\n                            // Add the next 2 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 2 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else {\n                            this.advance();\n                        }\n                    }\n                    continue;\n                }\n            }\n            else {\n                value += char;\n                this.advance();\n            }\n        }\n        value = value.trimEnd();\n        if (normalizeString) {\n            value = value.normalize(\"NFC\");\n        }\n        if (value === \"\") {\n            return null;\n            // assertNever(this.input[this.pos])\n        }\n        switch (value) {\n            case Literals.TRUE:\n            case Literals.T:\n                return Token.init(start, startRow, startCol, value, true, TokenType.BOOLEAN);\n            case Literals.FALSE:\n            case Literals.F:\n                return Token.init(start, startRow, startCol, value, false, TokenType.BOOLEAN);\n            case Literals.NULL:\n            case Literals.N:\n                return Token.init(start, startRow, startCol, value, null, TokenType.NULL);\n            case Literals.Inf:\n            case Literals.NaN:\n                return Token.init(start, startRow, startCol, value, value === Literals.Inf ? Infinity : NaN, TokenType.NUMBER);\n            default:\n                return Token.init(start, startRow, startCol, value, value, TokenType.STRING, \"OPEN_STRING\");\n        }\n    }\n    /**\n     * Merges the two tokens into one token. This is used to merge the\n     * tokens detected by various tokenizer functions.\n     */\n    mergeTokens(first, second) {\n        const token = new Token();\n        token.pos = first.pos;\n        token.row = first.row;\n        token.col = first.col;\n        token.token = first.token + second.token;\n        token.value = first.token + second.value.toString();\n        token.type = second.type;\n        token.subType = second.subType;\n        return token;\n    }\n    /**\n     * Skip over any whitespaces and return them as a string.\n     * @returns {string} The skipped whitespaces.\n     */\n    skipWhitespaces(hspacesOnly = false) {\n        const startPos = this.pos;\n        while (!this.reachedEnd && is.isWhitespace(this.input[this.pos], hspacesOnly)) {\n            const space = this.input[this.pos];\n            // replace \\r\\n or \\r with \\n. This behavior is configurable\n            // with the normalizeNewline option\n            if (space === '\\r') {\n                if (this.input[this.pos + 1] === '\\n') {\n                    this.advance();\n                }\n                this.advance();\n            }\n            else {\n                this.advance();\n            }\n        }\n        // Optimize: use substring instead of character-by-character concatenation\n        if (startPos === this.pos) {\n            return '';\n        }\n        let spaces = this.input.substring(startPos, this.pos);\n        // Only normalize if we found \\r characters\n        if (spaces.includes('\\r')) {\n            spaces = spaces.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n        }\n        return spaces;\n    }\n    /**\n     * Tokenize the input string.\n     * @returns {Token[]} Array of parsed tokens.\n     */\n    tokenize() {\n        // Pre-allocate array with estimated size for better performance\n        const estimatedTokens = Math.max(10, Math.floor(this.inputLength / 8));\n        const tokens = new Array(estimatedTokens);\n        let tokenIndex = 0;\n        while (this.pos < this.inputLength) {\n            const charCode = this.input.charCodeAt(this.pos);\n            // Whitespaces - use fast character code checking\n            if (isWhitespaceFast(charCode)) {\n                // Skip over the whitespace\n                this.advance();\n                continue;\n            }\n            // Single-line comments\n            else if (charCode === CHAR_CODES.HASH) {\n                this.parseSingleLineComment();\n            }\n            // Regular strings\n            else if (charCode === CHAR_CODES.DOUBLE_QUOTE || charCode === CHAR_CODES.SINGLE_QUOTE) {\n                tokens[tokenIndex++] = this.parseRegularString(this.input[this.pos]);\n            }\n            // Special symbols (e.g., curly braces, brackets, etc.) - use fast character code checking\n            else if (this.isSpecialSymbolFast(charCode)) {\n                const startRow = this.row;\n                const startCol = this.col;\n                const ch = this.input[this.pos];\n                tokens[tokenIndex++] = Token.init(this.pos, startRow, startCol, ch, ch, this.getSymbolTokenTypeFast(charCode));\n                this.advance();\n            }\n            // Numbers\n            else if (charCode === CHAR_CODES.PLUS || charCode === CHAR_CODES.MINUS || charCode === CHAR_CODES.DOT || isDigitFast(charCode)) {\n                // Check if it is a SECTION_SEP ---\n                if (charCode === CHAR_CODES.MINUS) {\n                    // If the next two chars are -- that means it is a\n                    // data seperator.\n                    if (this.input.substring(this.pos, this.pos + 3) === \"---\") {\n                        tokenIndex = this.parseSectionSeparator(tokens, tokenIndex);\n                        continue;\n                    }\n                }\n                const token = this.parseNumber();\n                if (token) {\n                    const spaces = this.skipWhitespaces();\n                    if (!this.reachedEnd) {\n                        // If the next character (2abc) is not a symbol or whitespace, then\n                        // it must be a literal or open string. Parse it and merge it\n                        // with the number token.\n                        if (!is.isSpecialSymbol(this.input[this.pos]) &&\n                            !is.isWhitespace(this.input[this.pos])) {\n                            const nextToken = this.parseLiteralOrOpenString();\n                            if (nextToken) {\n                                nextToken.type = TokenType.STRING;\n                                nextToken.subType = \"OPEN_STRING\";\n                                if (spaces.length > 0) {\n                                    nextToken.token = spaces + nextToken.token;\n                                    nextToken.value = spaces + nextToken.value;\n                                }\n                                tokens[tokenIndex++] = this.mergeTokens(token, nextToken);\n                            }\n                            else {\n                                tokens[tokenIndex++] = token;\n                            }\n                        }\n                        else {\n                            tokens[tokenIndex++] = token;\n                        }\n                    }\n                    else {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n                else {\n                    // It wasn't a number, so it must be a literal or open string\n                    const token = this.parseLiteralOrOpenString();\n                    if (token) {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n            }\n            // Literals or open strings\n            else {\n                const annotation = this.checkIfAnotatedString();\n                if (annotation) {\n                    switch (annotation.name) {\n                        case \"r\":\n                            tokens[tokenIndex++] = this.parseRawString(annotation);\n                            break;\n                        case \"b\":\n                            tokens[tokenIndex++] = this.parseByteString(annotation);\n                            break;\n                        case \"d\":\n                        case \"dt\":\n                        case \"t\":\n                            tokens[tokenIndex++] = this.parseDateTime(annotation);\n                            break;\n                        default:\n                            const error = new SyntaxError(ErrorCodes.unsupportedAnnotation, `Unsupported annotation '${annotation.name}'. Supported annotations are: 'r' (raw string), 'b' (binary), 'dt' (datetime), 'd' (date), 't' (time).`, this.currentPosition);\n                            const tokenText = this.input.substring(this.pos, this.pos + annotation.name.length + 1);\n                            tokens[tokenIndex++] = this.createErrorToken(error, this.pos, this.row, this.col, tokenText);\n                            this.skipToNextTokenBoundary();\n                    }\n                }\n                else {\n                    const token = this.parseLiteralOrOpenString();\n                    if (token) {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n            }\n        }\n        // Return properly sized array\n        tokens.length = tokenIndex;\n        return tokens;\n    }\n    parseSectionSeparator(tokens, tokenIndex) {\n        tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, \"---\", \"---\", TokenType.SECTION_SEP);\n        this.advance(3); // Advance past the \"---\"\n        this.skipWhitespaces(true);\n        const match = reSectionSchemaName.exec(this.input.substring(this.pos));\n        if (match) {\n            let schema;\n            let name;\n            let sep = match.groups?.sep;\n            let schema2;\n            if (match.groups) {\n                schema = match.groups.schema;\n                name = match.groups.name;\n                schema2 = match.groups.schema2;\n            }\n            // When only a schema is provided, the schema is the name\n            if (schema2) {\n                tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, schema2, schema2, TokenType.STRING, TokenType.SECTION_SCHEMA);\n                this.advance(schema2.length);\n                this.skipWhitespaces(true);\n            }\n            else if (name) {\n                tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, name, name, TokenType.STRING, TokenType.SECTION_NAME);\n                this.advance(name.length);\n                this.skipWhitespaces(true);\n                if (sep) {\n                    // skip over the separator when it is present\n                    this.advance(sep.length);\n                    this.skipWhitespaces(true);\n                    // Once the sep is detected, the schema must be present\n                    if (!schema) {\n                        const error = new SyntaxError(ErrorCodes.schemaMissing, `Missing schema definition after section separator. Expected schema name starting with '$' (e.g., '$mySchema').`, this.currentPosition);\n                        tokens[tokenIndex++] = this.createErrorToken(error, this.pos, this.row, this.col, \"\");\n                        return tokenIndex;\n                    }\n                    tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, schema, schema, TokenType.STRING, TokenType.SECTION_SCHEMA);\n                    this.advance(schema.length);\n                    this.skipWhitespaces(true);\n                }\n            }\n        }\n        return tokenIndex;\n    }\n}\nexport default Tokenizer;\n","import Document from '../../core/document';\nimport SectionCollection from '../../core/section-collection';\nclass DocumentNode {\n    constructor(header, children = [], errors = []) {\n        this.header = null;\n        this.children = [];\n        this.errors = []; // Accumulated errors during parsing\n        this.header = header;\n        this.children = children;\n        this.errors = errors;\n    }\n    get firstChild() {\n        return this.children.length > 0 ? this.children[0] : null;\n    }\n    /**\n     * Returns all errors accumulated during parsing.\n     * This enables IDEs and tools to show all diagnostics in one pass.\n     */\n    getErrors() {\n        return this.errors;\n    }\n    toValue(defs) {\n        const header = this.header?.toValue(defs) ?? null;\n        const sections = new SectionCollection();\n        for (let i = 0; i < this.children.length; i++) {\n            sections.push(this.children[i].toValue(defs));\n        }\n        return new Document(header, sections);\n    }\n    getStartPos() {\n        if (this.header) {\n            return this.header.getStartPos();\n        }\n        if (this.children.length > 0) {\n            return this.children[0].getStartPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        if (this.children.length > 0) {\n            return this.children[this.children.length - 1].getEndPos();\n        }\n        if (this.header) {\n            return this.header.getEndPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n}\nexport default DocumentNode;\n","import Section from \"../../core/section\";\nimport CollectionNode from \"./collections\";\nimport ObjectNode from \"./objects\";\nclass SectionNode {\n    constructor(child, nameNode, schemaNode) {\n        this.type = 'section';\n        this.child = child;\n        this.nameNode = nameNode;\n        this.schemaNode = schemaNode;\n    }\n    get name() {\n        return this.nameNode?.value || this.schemaNode?.value.toString().substring(1) || 'unnamed';\n    }\n    get schemaName() {\n        return this.schemaNode?.value || \"$schema\";\n    }\n    get firstChild() {\n        return this.child;\n    }\n    get firstChildObject() {\n        if (this.child instanceof ObjectNode) {\n            return this.child;\n        }\n        if (this.child instanceof CollectionNode && this.child.children.length > 0) {\n            return this.child.children[0];\n        }\n        return null;\n    }\n    getStartPos() {\n        return this.child?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        return this.child?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    toValue(defs) {\n        let data = null;\n        if (this.child) {\n            data = this.child.toValue(defs);\n        }\n        return new Section(data, this.name, this.schemaName);\n    }\n}\nexport default SectionNode;\n","import assertNever from '../errors/asserts/asserts';\nimport ErrorCodes from '../errors/io-error-codes';\nimport SyntaxError from '../errors/io-syntax-error';\nimport { tokenSpanRange } from '../errors/error-range-utils';\nimport TokenType from './tokenizer/token-types';\nimport ArrayNode from './nodes/array';\nimport CollectionNode from './nodes/collections';\nimport DocumentNode from './nodes/document';\nimport ErrorNode from './nodes/error';\nimport MemberNode from './nodes/members';\nimport ObjectNode from './nodes/objects';\nimport SectionNode from './nodes/section';\nimport TokenNode from './nodes/tokens';\nclass ASTParser {\n    constructor(tokens) {\n        this.sectionNames = {};\n        this.errors = []; // Accumulated errors during parsing\n        this.tokens = tokens;\n        this.current = 0;\n    }\n    parse() {\n        return this.processDocument();\n    }\n    /**\n     * Creates a syntax error with proper range spanning the entire construct.\n     * Industry standard: Error should highlight from start token to end token.\n     *\n     * @param errorCode - The error code\n     * @param message - Error message\n     * @param startToken - Opening token of the construct (e.g., '{' or '[')\n     * @param members - Array of parsed members/elements (to find last token) - can include undefined\n     * @returns SyntaxError with range spanning the entire construct\n     */\n    createUnclosedConstructError(errorCode, message, startToken, members) {\n        // Find the end position by looking backwards from current, skipping boundary tokens\n        let errorEndToken = null;\n        // Start from the token before current position\n        let checkIndex = this.current - 1;\n        // Skip backwards over any boundary tokens (~ or ---)\n        while (checkIndex >= 0) {\n            const token = this.tokens[checkIndex];\n            if (token &&\n                token.type !== TokenType.COLLECTION_START &&\n                token.type !== TokenType.SECTION_SEP) {\n                errorEndToken = token;\n                break;\n            }\n            checkIndex--;\n        }\n        // Create the error with proper range spanning the entire construct\n        if (startToken && errorEndToken) {\n            const range = tokenSpanRange(startToken, errorEndToken);\n            return new SyntaxError(errorCode, message, range, false);\n        }\n        else if (startToken) {\n            // Fallback: use start token only\n            return new SyntaxError(errorCode, message, startToken, false);\n        }\n        else {\n            // No tokens available - create error without position\n            return new SyntaxError(errorCode, message, undefined, true);\n        }\n    }\n    processDocument() {\n        const sections = new Array();\n        let header = null;\n        let token = this.peek();\n        let first = true;\n        while (true) {\n            if (first) {\n                // When the first token is a section separator, it means that\n                // header section is not present. Just skip the section separator\n                if (token?.type === TokenType.SECTION_SEP) {\n                    first = false;\n                }\n            }\n            const section = this.processSection(first);\n            token = this.peek();\n            if (!token) {\n                sections.push(section);\n                break;\n            }\n            if (first) {\n                header = section;\n            }\n            else {\n                sections.push(section);\n            }\n            if (first)\n                first = false;\n            // If the next token is not a section separator, it means that\n            // the current section is not closed properly. Add error and stop\n            if (token.type !== TokenType.SECTION_SEP) {\n                const error = new SyntaxError(ErrorCodes.unexpectedToken, `Expected section separator '---' but found '${token.token}'. Each section must be properly closed before starting a new one.`, token);\n                this.errors.push(error);\n                break; // Stop parsing but return partial document\n            }\n            // Move to the next token and check if it is a section separator\n            // or the end of file\n            this.advance();\n        }\n        // If there are more than one sections, and the document does not start\n        // with --- then the first one is the header.\n        // section. Remove it from the sections array and return it as the header\n        // if (sections.length > 1 && this.tokens[0].type !== TokenType.SECTION_SEP) {\n        //   const header = sections.shift();\n        //   return new DocumentNode(header ?? null, sections);\n        // }\n        return new DocumentNode(header, sections, this.errors);\n    }\n    processSection(first) {\n        let token = this.peek();\n        // Consume the section separator if present\n        if (token?.type === TokenType.SECTION_SEP) {\n            this.advance();\n        }\n        // If the first token is a section separator, it means that\n        // the section has started without a section name. A header\n        // section does not have a name.\n        const [schemaNode, nameNode] = this.parseSectionAndSchemaNames();\n        let name = nameNode?.value || schemaNode?.value.toString().substring(1) || 'unnamed';\n        const originalName = name;\n        // Check if the section name is already used - implement auto-rename for error recovery\n        if (name && this.sectionNames[name]) {\n            const error = new SyntaxError(ErrorCodes.unexpectedToken, `Duplicate section name '${name}'. Each section must have a unique name within the document.`, void 0, false);\n            this.errors.push(error); // Accumulate error\n            // Auto-rename: users -> users_2, users_3, etc.\n            let suffix = 2;\n            while (this.sectionNames[`${originalName}_${suffix}`]) {\n                suffix++;\n            }\n            name = `${originalName}_${suffix}`;\n            // Update the nameNode with the renamed value\n            if (nameNode) {\n                nameNode.value = name;\n            }\n        }\n        if (!first || (first && name !== 'unnamed' && this.peek()?.type !== TokenType.SECTION_SEP)) {\n            this.sectionNames[name] = true;\n        }\n        const section = this.parseSectionContent();\n        return new SectionNode(section, nameNode, schemaNode);\n    }\n    parseSectionAndSchemaNames() {\n        let schemaNode = null;\n        let nameNode = null;\n        let token = this.peek();\n        if (token?.subType === TokenType.SECTION_NAME) {\n            nameNode = token;\n            // Consume the section name\n            this.advance();\n            token = this.peek();\n            if (token?.subType === TokenType.SECTION_SCHEMA) {\n                schemaNode = token;\n                // Consume the section name\n                this.advance();\n            }\n        }\n        else if (token?.subType === TokenType.SECTION_SCHEMA) {\n            schemaNode = token;\n            // Consume the section name\n            this.advance();\n            token = this.peek();\n        }\n        return [schemaNode, nameNode];\n    }\n    parseSectionContent() {\n        const token = this.peek();\n        if (!token)\n            return null;\n        if (token.type === TokenType.SECTION_SEP) {\n            return null;\n        }\n        // Parse the collection ~\n        if (token.type === TokenType.COLLECTION_START) {\n            return this.processCollection();\n        }\n        // Parse the single object {}\n        return this.processObject(false);\n    }\n    processCollection() {\n        const objects = [];\n        while (this.match(ASTParser.COLLECTION_START_ARRAY)) {\n            // Consume the COLLECTION_START token\n            this.advance();\n            // Remember the position before parsing the item (for fallback)\n            const itemStartPos = this.current;\n            try {\n                // Parse the object and add to the collection\n                objects.push(this.processObject(true));\n            }\n            catch (error) {\n                // Accumulate error for Phase 2\n                this.errors.push(error);\n                // Create error node with actual error position\n                let position = { pos: -1, row: -1, col: -1 };\n                let endPosition = undefined;\n                // Extract position from IOError if available\n                if (error && typeof error === 'object' && 'positionRange' in error) {\n                    const posRange = error.positionRange;\n                    if (posRange && posRange.getStartPos) {\n                        position = posRange.getStartPos();\n                        endPosition = posRange.getEndPos ? posRange.getEndPos() : undefined;\n                    }\n                }\n                // Fallback: if no position in error, use the last valid token position\n                if (position.pos === -1 && this.current > 0 && this.current <= this.tokens.length) {\n                    const lastToken = this.tokens[this.current - 1];\n                    if (lastToken) {\n                        position = lastToken.getEndPos(); // Use end position of last token\n                        endPosition = position; // Point to same location\n                    }\n                }\n                objects.push(new ErrorNode(error, position, endPosition));\n                this.skipToNextCollectionItem();\n            }\n            // No explicit delimiter check is required since the `~`\n            // itself acts as both a delimiter and an indicator for\n            // the next object.\n        }\n        return new CollectionNode(objects);\n    }\n    /**\n     * Skips tokens until the next collection item (COLLECTION_START token) or section end.\n     * This is used for error recovery in collection parsing.\n     */\n    skipToNextCollectionItem() {\n        // Skip tokens until we find next `~` (COLLECTION_START) or section end\n        while (this.peek() &&\n            !this.match(ASTParser.COLLECTION_OR_SECTION_ARRAY)) {\n            this.advance();\n        }\n    }\n    processObject(isCollectionContext) {\n        const obj = this.parseObject(true);\n        // Even after parsing the object, if there is still a token\n        // left, it means that the object is not closed properly.\n        const token = this.peek();\n        this.checkForPendingTokens(token, isCollectionContext);\n        // If there is only one member in the object, and it has no key,\n        // then the object is not an open object. In this case, we need\n        // unwrap the object\n        // For example. { {} } should be unwrapped to {}\n        // {} should be unwrapped to []\n        // 'a' should be unwrapped to [a]\n        // 'a', 'b', 'c' should be unwrapped to [a, b, c]\n        // {}, 'b', 'c' should be unwrapped to [{}, b, c]\n        // {{}} should be unwrapped to [{}]\n        if (obj.children.length === 1) {\n            const firstMember = obj.children[0];\n            if (firstMember && !firstMember.key && firstMember.value) {\n                if (firstMember.value instanceof ObjectNode) {\n                    return firstMember.value;\n                }\n            }\n        }\n        return obj;\n    }\n    checkForPendingTokens(token, isCollectionContext) {\n        if (!token)\n            return;\n        if (token.type === TokenType.SECTION_SEP)\n            return;\n        if (isCollectionContext && token.type === TokenType.COLLECTION_START)\n            return;\n        throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected token '${token.value}'. Expected end of section or start of new collection item '~'.`, token, false);\n    }\n    parseObject(isOpenObject) {\n        const members = [];\n        let openBracket = this.peek();\n        if (isOpenObject) {\n            openBracket = null;\n        }\n        if (!isOpenObject && !this.advanceIfMatch(ASTParser.CURLY_OPEN_ARRAY)) {\n            assertNever(\"The caller must ensure that this function is called \" +\n                \"only when the next token is {\");\n        }\n        let index = 0;\n        let done = false;\n        while (!done) {\n            const nextToken = this.peek();\n            if (!nextToken || this.match([TokenType.CURLY_CLOSE, TokenType.COLLECTION_START, TokenType.SECTION_SEP])) {\n                done = true;\n                break;\n            }\n            else if (nextToken.type === TokenType.COMMA) {\n                // If the next token is a comma(, or new object)\n                // it means that the no value is provided.\n                // Consume the comma and continue.\n                if (this.matchNext([TokenType.COMMA, TokenType.CURLY_CLOSE, TokenType.COLLECTION_START, TokenType.SECTION_SEP])) {\n                    this.pushUndefinedMember(members, nextToken);\n                }\n                else if (this.current + 1 === this.tokens.length) {\n                    this.pushUndefinedMember(members, nextToken);\n                }\n                this.advance();\n                continue;\n            }\n            else {\n                // The member must be preceded by a comma, open bracket, or\n                // the beginning of the object. Otherwise it is invalid\n                // For example, { a: 1, b: 2 } is valid, but { a: 1 b: 2 } is not\n                if (index > 0) {\n                    if (!this.matchPrev([TokenType.COMMA, TokenType.CURLY_OPEN])) {\n                        throw new SyntaxError(ErrorCodes.unexpectedToken, `Missing comma before '${nextToken.value}'. Object members must be separated by commas.`, nextToken, false);\n                    }\n                }\n                const member = this.parseMember();\n                members.push(member);\n                index++;\n            }\n        }\n        // Now, expect a closing bracket if not open object\n        if (!isOpenObject) {\n            if (!this.match(ASTParser.CURLY_CLOSE_ARRAY)) {\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing brace '}'. Object must be properly closed.`, openBracket, members);\n            }\n            let closeBracket = this.peek();\n            this.advance();\n            return new ObjectNode(members, openBracket, closeBracket);\n        }\n        else {\n            return new ObjectNode(members);\n        }\n    }\n    parseMember() {\n        const leftToken = this.peek();\n        if (!leftToken) {\n            assertNever(\"The caller must ensure that this function is called \" +\n                \"only when the member has at least one token\");\n        }\n        if (this.matchNext(ASTParser.COLON_ARRAY)) {\n            const isValidKey = ASTParser.VALID_KEY_TYPES.includes(leftToken.type);\n            if (isValidKey) {\n                // Consume the key and colon\n                this.advance(2);\n                // Parse the value and return the key-value pair\n                const value = this.parseValue();\n                return new MemberNode(value, leftToken);\n            }\n            else {\n                throw new SyntaxError(ErrorCodes.invalidKey, `Invalid key '${leftToken.token}'. Object keys must be strings, numbers, booleans, or null.`, leftToken, false);\n            }\n        }\n        // If the next token is not a colon, that means it is\n        // a value without a key. In this case the key is\n        // the index of the value\n        return new MemberNode(this.parseValue());\n    }\n    parseArray() {\n        const arr = [];\n        const openBracket = this.peek();\n        if (!openBracket || openBracket.type !== TokenType.BRACKET_OPEN) {\n            throw new SyntaxError(ErrorCodes.expectingBracket, `Expected opening bracket '[' to start array but found '${openBracket?.token || 'end of input'}'.`, openBracket === null ? void 0 : openBracket, openBracket === null);\n        }\n        // Consume the opening bracket\n        this.advance();\n        while (true) {\n            const currentToken = this.peek();\n            if (!currentToken) {\n                // Unexpected end of input\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Unexpected end of input while parsing array. Expected closing bracket ']'.`, openBracket, arr);\n            }\n            if (currentToken.type === TokenType.BRACKET_CLOSE) {\n                break;\n            }\n            else if (currentToken.type === TokenType.COLLECTION_START ||\n                currentToken.type === TokenType.SECTION_SEP) {\n                // Reached a synchronization boundary without closing the array\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing bracket ']'. Array must be properly closed.`, openBracket, arr);\n            }\n            else if (currentToken.type === TokenType.COMMA) {\n                // If the next token is a comma or a closing bracket, it implies an undefined\n                // element in the array, which is not allowed. Throw an error.\n                if (this.matchNext([TokenType.COMMA, TokenType.BRACKET_CLOSE])) {\n                    const nextToken = this.tokens[this.current + 1];\n                    throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected comma. Array elements cannot be empty - remove the extra comma or add a value.`, nextToken, false);\n                }\n                // consume the current comma\n                this.advance();\n                continue;\n            }\n            const member = this.parseMember();\n            if (member.key) {\n                arr.push(new ObjectNode([member]));\n            }\n            else {\n                arr.push(member.value);\n            }\n        }\n        // Now, expect a closing bracket\n        if (!this.match(ASTParser.BRACKET_CLOSE_ARRAY)) {\n            throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing bracket ']'. Array must be properly closed.`, openBracket, arr);\n        }\n        const closeBracket = this.peek();\n        this.advance();\n        // Both openBracket and closeBracket are guaranteed to be Token (not null) here\n        return new ArrayNode(arr, openBracket, closeBracket);\n    }\n    parseValue() {\n        const token = this.peek();\n        if (!token) {\n            throw new SyntaxError(ErrorCodes.valueRequired, `Unexpected end of input. Expected a value (string, number, boolean, null, array, or object).`, void 0, true);\n        }\n        switch (token.type) {\n            case TokenType.STRING:\n            case TokenType.NUMBER:\n            case TokenType.BIGINT:\n            case TokenType.DECIMAL:\n            case TokenType.BOOLEAN:\n            case TokenType.NULL:\n            case TokenType.DATETIME: {\n                const node = new TokenNode(token);\n                this.advance();\n                return node;\n            }\n            case TokenType.BRACKET_OPEN:\n                return this.parseArray();\n            case TokenType.CURLY_OPEN:\n                return this.parseObject(false);\n            default:\n                throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected token '${token.value}'. Expected a valid value (string, number, boolean, null, array, or object).`, token, token === null);\n        }\n    }\n    pushUndefinedMember(members, curerntCommaToken) {\n        const valueNode = curerntCommaToken.clone();\n        valueNode.type = TokenType.UNDEFINED;\n        valueNode.value = void 0;\n        const member = new MemberNode(new TokenNode(valueNode));\n        members.push(member);\n    }\n    /**\n     * Type guard to check if a token is valid (not null)\n     */\n    isValidToken(token) {\n        return token !== null;\n    }\n    /**\n     * Returns the current token without advancing the current index\n     * @returns {Token} the current token or null if eof is reached\n     */\n    peek() {\n        return this.current < this.tokens.length ? this.tokens[this.current] : null;\n    }\n    /**\n     * Advances the current token index by the given number of steps\n     */\n    advance(steps = 1) {\n        this.current += steps;\n    }\n    /**\n     * Checks if the current token matches any of the given types.\n     * If a current token is not available, returns false.\n     * @param types - Array of token types to match against\n     * @returns true if current token matches any of the given types\n     */\n    match(types) {\n        const currentToken = this.peek();\n        if (this.isValidToken(currentToken) && types.includes(currentToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    matchPrev(types) {\n        const prevToken = this.tokens[this.current - 1];\n        if (this.isValidToken(prevToken) && types.includes(prevToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Match the next token in the stream without advancing the current index.\n     * If the next token matches any of the given types, returns true, otherwise returns false.\n     * If the next token is not available, returns false.\n     * @param types - Array of token types to match against\n     * @returns true if next token matches any of the given types\n     */\n    matchNext(types) {\n        if (this.current + 1 >= this.tokens.length) {\n            return false;\n        }\n        const nextToken = this.tokens[this.current + 1];\n        if (this.isValidToken(nextToken) && types.includes(nextToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    advanceIfMatch(types) {\n        if (this.match(types)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n}\n// Cached arrays for performance optimization\nASTParser.CURLY_OPEN_ARRAY = [TokenType.CURLY_OPEN];\nASTParser.CURLY_CLOSE_ARRAY = [TokenType.CURLY_CLOSE];\nASTParser.BRACKET_OPEN_ARRAY = [TokenType.BRACKET_OPEN];\nASTParser.BRACKET_CLOSE_ARRAY = [TokenType.BRACKET_CLOSE];\nASTParser.COLLECTION_START_ARRAY = [TokenType.COLLECTION_START];\nASTParser.SECTION_SEP_ARRAY = [TokenType.SECTION_SEP];\nASTParser.COMMA_ARRAY = [TokenType.COMMA];\nASTParser.COLON_ARRAY = [TokenType.COLON];\nASTParser.COLLECTION_OR_SECTION_ARRAY = [TokenType.COLLECTION_START, TokenType.SECTION_SEP];\nASTParser.VALID_KEY_TYPES = [\n    TokenType.STRING,\n    TokenType.NUMBER,\n    TokenType.BOOLEAN,\n    TokenType.NULL,\n];\nexport default ASTParser;\n","import Document from '../core/document';\nimport Header from '../core/header';\nimport Section from '../core/section';\nimport SectionCollection from '../core/section-collection';\nimport assertNever from '../errors/asserts/asserts';\nimport InternetObjectError from '../errors/io-error';\nimport ErrorCodes from '../errors/io-error-codes';\nimport compileObject from '../schema/compile-object';\nimport processSchema from '../schema/processor';\nimport Schema from '../schema/schema';\nimport Tokenizer from './tokenizer';\nimport TokenType from './tokenizer/token-types';\nimport ASTParser from './ast-parser';\nimport CollectionNode from './nodes/collections';\nimport ObjectNode from './nodes/objects';\nimport ErrorNode from './nodes/error';\nexport default function parse(source, externalDefs, o = {}) {\n    // Tokenize the source\n    const tokenizer = new Tokenizer(source);\n    const tokens = tokenizer.tokenize();\n    // If the source is empty, then return empty document\n    if (tokens.length === 0) {\n        return new Document(new Header(), new SectionCollection());\n    }\n    // Parse the tokens into AST - optimize for simple cases\n    const parser = new ASTParser(tokens);\n    const docNode = parser.parse();\n    // Extract errors from docNode for transfer to Document\n    const errors = docNode.getErrors();\n    // Create document with optimized initialization\n    const doc = new Document(new Header(), new SectionCollection(), errors);\n    // If the docNode contains header, then parse it\n    if (docNode.header) {\n        if (docNode.header.child) {\n            // If ObjectNode, it is a default schema\n            //\n            // name, age, address  # <-- This is a schema\n            // ---\n            if (docNode.header.child instanceof ObjectNode) {\n                const schema = compileObject(\"schema\", docNode.header.child);\n                if (schema instanceof Schema) {\n                    doc.header.definitions?.push(\"$schema\", schema, true);\n                    doc.header.schema = schema; // Set as the default schema\n                }\n                else {\n                    assertNever(schema);\n                }\n            }\n            // If CollectionNode, it's always definitions (may include $schema, @variables, or regular key-values)\n            // Example: ~ $schema: {...}, ~ @x: 10, ~ success: T\n            else if (docNode.header.child instanceof CollectionNode) {\n                parseDefs(doc, docNode.header.child);\n            }\n            // Unexpected node\n            else {\n                assertNever(docNode.header.child);\n            }\n            if (externalDefs) {\n                doc.header.definitions.merge(externalDefs, false);\n            }\n        }\n        else {\n            if (externalDefs) {\n                doc.header.definitions.merge(externalDefs, false);\n            }\n        }\n        parseDataWithSchema(docNode, doc);\n    }\n    else {\n        if (externalDefs) {\n            doc.header.definitions.merge(externalDefs, false);\n        }\n        parseDataWithSchema(docNode, doc);\n    }\n    return doc;\n}\nfunction parseData(docNode, doc) {\n    for (let i = 0; i < docNode.children.length; i++) {\n        const sectionNode = docNode.children[i];\n        doc.sections?.push(new Section(sectionNode.child?.toValue(doc.header.definitions || undefined), sectionNode.name));\n    }\n}\nfunction parseDataWithSchema(docNode, doc) {\n    const sectionsLen = docNode.children.length;\n    // Early return if no sections\n    if (sectionsLen === 0) {\n        return;\n    }\n    // Create error collector for validation errors\n    const validationErrors = [];\n    for (let i = 0; i < sectionsLen; i++) {\n        const sectionNode = docNode.children[i];\n        const schemaName = sectionNode.schemaName;\n        // If no explicit schema name, fall back to document's default schema\n        const schema = schemaName\n            ? (schemaName === \"$schema\" ? doc.header.schema : doc.header.definitions?.getV(sectionNode.schemaNode))\n            : doc.header.schema;\n        if (!schema) {\n            parseData(docNode, doc);\n            continue;\n        }\n        const result = processSchema(sectionNode.child, schema, doc.header.definitions || undefined, validationErrors);\n        doc.sections?.push(new Section(result, sectionNode.name, schemaName));\n    }\n    // Append validation errors to document (parser errors are already there from constructor)\n    if (validationErrors.length > 0) {\n        doc.addErrors(validationErrors);\n    }\n}\nfunction parseDefs(doc, cols) {\n    const defs = doc.header.definitions;\n    if (!defs) {\n        throw new Error(\"Document header definitions not initialized. This is an internal error - please report this issue.\");\n    }\n    const schemaDefs = [];\n    for (let i = 0; i < cols.children.length; i++) {\n        const child = cols.children[i];\n        // If child is null then skip\n        if (child === null) {\n            continue;\n        }\n        if (child instanceof ErrorNode) {\n            throw new InternetObjectError(ErrorCodes.invalidDefinition, `Invalid definition: ${child.error.message}`, child);\n        }\n        // Must be an object node\n        if (child instanceof ObjectNode === false) {\n            assertNever(\"Invalid definition, must be object\");\n        }\n        // Must not be null\n        if (child.children[0] === null) {\n            assertNever(\"Invalid definition\");\n        }\n        // Must have only one child\n        if (child.children.length !== 1) {\n            // throw new InternetObjectError(ErrorCodes.invalidDefinition, child.children?.[1], child.children?[1])\n        }\n        const memberNode = child.children[0];\n        // Must have a key\n        if (!memberNode.key) {\n            throw new InternetObjectError(ErrorCodes.invalidDefinition, `Invalid definition: missing key. Each definition must have a key (e.g., '$schema: {...}' or '@variable: value').`, memberNode.value);\n        }\n        const keyToken = memberNode.key;\n        // Key must be a string\n        if (keyToken.type !== TokenType.STRING) {\n            throw new Error(\"Invalid typedef definition: key must be a string.\");\n        }\n        let key = keyToken.value;\n        // If key starts with $, then it is a schema. Dont compile it now,\n        // just keep it as it is. After all the definitions are parsed, compile\n        // the variable schemas.\n        if (key.startsWith('$')) {\n            defs.push(key, memberNode.value, true);\n            schemaDefs.push({ key, schemaDef: memberNode.value });\n            continue;\n        }\n        // If key starts with @, then it is a variable. Keep it as it is\n        if (key.startsWith('@')) {\n            defs.push(key, memberNode.value, false, true);\n            continue;\n        }\n        let value = child.children[0].value;\n        defs.push(key, value.toValue(doc.header.definitions || undefined));\n    }\n    // Compile the schema definitions\n    for (let i = 0; i < schemaDefs.length; i++) {\n        const { key, schemaDef } = schemaDefs[i];\n        const def = compileObject(key, schemaDef, defs);\n        defs.set(key, def);\n    }\n}\n","import parse from \".\";\nexport default function parseDefinitions(source, externalDefs, options) {\n    source = source.trim();\n    if (!source) {\n        return null;\n    }\n    if (!source.endsWith(\"---\")) {\n        source += \"\\n---\";\n    }\n    // If the definition does not start with ~, then it must be\n    // a default schema. So, add \"~ $schema: \" in the beginning to make it a\n    // definition.\n    // if (!source.startsWith(\"~\")) {\n    //   source = \"~ $schema: \" + source\n    // }\n    const doc = parse(source, externalDefs, options);\n    return doc.header.definitions;\n}\n","/**\r\n * Error types and interfaces for the IO Playground.\r\n * Provides structured error objects to replace string-based error messages.\r\n */\r\n\r\n/**\r\n * Error category determines UI treatment (color, severity, icon).\r\n */\r\nexport type ErrorCategory = 'syntax' | 'validation' | 'runtime';\r\n\r\n/**\r\n * Precise range in source text (1-indexed lines and columns).\r\n */\r\nexport interface ErrorRange {\r\n  startLine: number;\r\n  startColumn: number;\r\n  endLine: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Structured error item with all metadata.\r\n * Replaces string-based error messages for better type safety and features.\r\n */\r\nexport interface ErrorItem {\r\n  /** Stable unique ID for de-duplication and focus management */\r\n  id: string;\r\n\r\n  /** Machine-readable error code (e.g., \"invalid-range\", \"missing-bracket\") */\r\n  code?: string;\r\n\r\n  /** Error category for UI styling and severity */\r\n  category: ErrorCategory;\r\n\r\n  /** User-facing error message */\r\n  message: string;\r\n\r\n  /** Source position range */\r\n  range: ErrorRange;\r\n\r\n  /** Which editor the error is from */\r\n  source: 'doc' | 'defs';\r\n}\r\n\r\n/**\r\n * Editor marker for Monaco.\r\n * Subset of monaco.editor.IMarkerData with our extensions.\r\n */\r\nexport interface EditorMarker {\r\n  /** Monaco severity: 8 = Error, 4 = Warning, 2 = Info, 1 = Hint */\r\n  severity: 1 | 2 | 4 | 8;\r\n\r\n  /** Error message displayed in hover */\r\n  message: string;\r\n\r\n  /** 1-indexed line number where error starts */\r\n  startLineNumber: number;\r\n\r\n  /** 1-indexed column where error starts */\r\n  startColumn: number;\r\n\r\n  /** 1-indexed line number where error ends */\r\n  endLineNumber: number;\r\n\r\n  /** 1-indexed column where error ends */\r\n  endColumn: number;\r\n\r\n  /** Optional: stable ID matching ErrorItem.id */\r\n  id?: string;\r\n\r\n  /** Optional: error category for filtering/grouping */\r\n  category?: ErrorCategory;\r\n}\r\n\r\n/**\r\n * Monaco severity constants (match monaco.MarkerSeverity enum).\r\n */\r\nexport const MonacoSeverity = {\r\n  Hint: 1,\r\n  Info: 2,\r\n  Warning: 4,\r\n  Error: 8,\r\n} as const;\r\n\r\n/**\r\n * Map error category to Monaco severity.\r\n */\r\nexport function categoryToSeverity(category: ErrorCategory): number {\r\n  switch (category) {\r\n    case 'syntax':\r\n      return MonacoSeverity.Error; // Red squiggles\r\n    case 'validation':\r\n      return MonacoSeverity.Warning; // Orange squiggles\r\n    case 'runtime':\r\n      return MonacoSeverity.Error; // Red squiggles\r\n    default:\r\n      return MonacoSeverity.Error;\r\n  }\r\n}\r\n\r\n/**\r\n * JSON decoration metadata for highlighting error objects in output.\r\n * Emitted by the parser alongside the JSON output to avoid brace-scanning.\r\n */\r\nexport interface JsonDecoration {\r\n  /** Error category for styling (syntax, validation, runtime) */\r\n  category: ErrorCategory;\r\n\r\n  /** Character offset in JSON string where error object starts */\r\n  startOffset: number;\r\n\r\n  /** Character offset in JSON string where error object ends (exclusive) */\r\n  endOffset: number;\r\n\r\n  /** Optional: matching ErrorItem.id for correlation */\r\n  errorId?: string;\r\n}\r\n\r\n/**\r\n * Generate stable error ID from range and message.\r\n */\r\nexport function generateErrorId(range: ErrorRange, message: string): string {\r\n  return `${range.startLine}:${range.startColumn}-${range.endLine}:${range.endColumn}:${message.substring(0, 20)}`;\r\n}\r\n","/**\r\n * Web Worker for parsing Internet Object documents.\r\n * Offloads parsing to prevent UI blocking on large documents.\r\n */\r\n\r\nimport type { IODefinitions } from 'internet-object';\r\nimport { parse, parseDefinitions } from 'internet-object';\r\nimport { IOError, IOSyntaxError, IOValidationError } from 'internet-object';\r\nimport { Decimal } from 'internet-object';\r\nimport type { ErrorItem, EditorMarker, ErrorRange, ErrorCategory } from '../types/errors';\r\nimport { categoryToSeverity, generateErrorId } from '../types/errors';\r\n\r\nexport interface ParseRequest {\r\n  type: 'parse';\r\n  id: string;\r\n  documentText: string;\r\n  schemaText: string | null;\r\n  skipErrors: boolean;\r\n  minifiedOutput: boolean;\r\n}\r\n\r\nexport interface ParseResponse {\r\n  type: 'result' | 'error';\r\n  id: string;\r\n  result?: {\r\n    errorMessages: string[];\r\n    errorItems: ErrorItem[];\r\n    docMarkers: EditorMarker[];\r\n    defsMarkers: EditorMarker[];\r\n    jsonText: string;\r\n    error: boolean;\r\n  };\r\n  error?: string;\r\n}\r\n\r\n// Type guard for ParseRequest\r\nfunction isParseRequest(data: any): data is ParseRequest {\r\n  return data && data.type === 'parse' && typeof data.id === 'string';\r\n}\r\n\r\n// Worker message handler\r\nself.addEventListener('message', (event: MessageEvent) => {\r\n  const data = event.data;\r\n\r\n  if (!isParseRequest(data)) {\r\n    console.error('Invalid message received by parser worker:', data);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const result = parseIO(\r\n      data.documentText,\r\n      data.schemaText,\r\n      data.skipErrors,\r\n      data.minifiedOutput\r\n    );\r\n\r\n    const response: ParseResponse = {\r\n      type: 'result',\r\n      id: data.id,\r\n      result,\r\n    };\r\n\r\n    self.postMessage(response);\r\n  } catch (error: any) {\r\n    const response: ParseResponse = {\r\n      type: 'error',\r\n      id: data.id,\r\n      error: error?.message || String(error),\r\n    };\r\n\r\n    self.postMessage(response);\r\n  }\r\n});\r\n\r\n// Parsing logic (same as compiler.ts but returns serializable result)\r\nfunction parseIO(\r\n  document: string,\r\n  defs: string | null,\r\n  skipErrors: boolean,\r\n  minifiedOutput: boolean\r\n): NonNullable<ParseResponse['result']> {\r\n  if (!defs) {\r\n    return parseDoc(document, null, skipErrors, minifiedOutput);\r\n  }\r\n\r\n  const defsResult = tryParse(defs, parseDefinitions, true, skipErrors);\r\n  if (defsResult.errorMessages.length > 0) {\r\n    return {\r\n      ...defsResult,\r\n      jsonText: '',\r\n      error: true,\r\n    };\r\n  }\r\n\r\n  return parseDoc(document, defsResult.defs, skipErrors, minifiedOutput);\r\n}\r\n\r\ninterface ParseIntermediateResult {\r\n  errorMessages: string[];\r\n  errorItems: ErrorItem[];\r\n  defs: IODefinitions | null;\r\n  output: any | null;\r\n  defsMarkers: EditorMarker[];\r\n  docMarkers: EditorMarker[];\r\n}\r\n\r\nfunction tryParse<T>(\r\n  input: string,\r\n  fn: (input: string, defs?: any) => T,\r\n  isDefs = false,\r\n  skipErrors = false\r\n): ParseIntermediateResult {\r\n  try {\r\n    const result = fn(input, null);\r\n\r\n    let accumulatedErrors: Error[] = [];\r\n    if (result && typeof (result as any).getErrors === 'function') {\r\n      accumulatedErrors = (result as any).getErrors();\r\n    }\r\n\r\n    const output = isDefs ? null : (result as any).toJSON({ skipErrors });\r\n    const defs = isDefs ? (result as IODefinitions) : null;\r\n\r\n    if (accumulatedErrors.length > 0) {\r\n      const source = isDefs ? 'defs' : 'doc';\r\n      const errorItems = accumulatedErrors\r\n        .map((e) => errorToErrorItem(e, source))\r\n        .filter((item): item is ErrorItem => item !== null);\r\n\r\n      return {\r\n        errorMessages: accumulatedErrors.map((e) => getErrorMessage(e)),\r\n        errorItems,\r\n        defs,\r\n        output,\r\n        defsMarkers: isDefs ? accumulatedErrors.flatMap(getErrorMarkers) : [],\r\n        docMarkers: isDefs ? [] : accumulatedErrors.flatMap(getErrorMarkers),\r\n      };\r\n    }\r\n\r\n    return {\r\n      errorMessages: [],\r\n      errorItems: [],\r\n      defs,\r\n      output,\r\n      defsMarkers: [],\r\n      docMarkers: [],\r\n    };\r\n  } catch (e: any) {\r\n    const source = isDefs ? 'defs' : 'doc';\r\n    const errorItem = errorToErrorItem(e, source);\r\n\r\n    return {\r\n      errorMessages: [getErrorMessage(e)],\r\n      errorItems: errorItem ? [errorItem] : [],\r\n      defs: null,\r\n      output: null,\r\n      defsMarkers: isDefs ? getErrorMarkers(e) : [],\r\n      docMarkers: isDefs ? [] : getErrorMarkers(e),\r\n    };\r\n  }\r\n}\r\n\r\nfunction parseDoc(\r\n  doc: string,\r\n  defs: IODefinitions | null,\r\n  skipErrors: boolean,\r\n  minifiedOutput: boolean\r\n): NonNullable<ParseResponse['result']> {\r\n  const intermediate = tryParse(doc, (d) => parse(d, defs), false, skipErrors);\r\n\r\n  const hasErrors = intermediate.errorMessages.length > 0;\r\n  let jsonText = '';\r\n  let error = false;\r\n\r\n  if (intermediate.output) {\r\n    jsonText = JSON.stringify(\r\n      intermediate.output,\r\n      function (k, v: any) {\r\n        if (typeof v === 'bigint') return `io:big:${v.toString()}`;\r\n        if (typeof v === 'number' && isNaN(v)) return 'io:number:NaN';\r\n        if (v instanceof Decimal) return `io:decimal:${v.toString()}`;\r\n        if (v === Infinity) return 'io:number:Inf';\r\n        if (v === -Infinity) return 'io:number:-Inf';\r\n        if (typeof v === 'undefined') return 'io:undefined';\r\n        return v;\r\n      },\r\n      minifiedOutput ? 0 : 2\r\n    );\r\n    error = hasErrors;\r\n  } else if (hasErrors) {\r\n    jsonText = '';\r\n    error = true;\r\n  }\r\n\r\n  return {\r\n    errorMessages: intermediate.errorMessages,\r\n    errorItems: intermediate.errorItems,\r\n    docMarkers: intermediate.docMarkers,\r\n    defsMarkers: intermediate.defsMarkers,\r\n    jsonText,\r\n    error,\r\n  };\r\n}\r\n\r\n// Helper functions\r\nfunction getErrorMessage(e: any): string {\r\n  if (e instanceof IOSyntaxError) return 'SYNTAX_ERROR: ' + (e?.message || String(e));\r\n  if (e instanceof IOValidationError) return 'VALIDATION_ERROR: ' + (e?.message || String(e));\r\n  return 'ERROR: ' + (e?.message || String(e));\r\n}\r\n\r\nfunction getErrorCategory(e: any): ErrorCategory {\r\n  if (e instanceof IOSyntaxError) return 'syntax';\r\n  if (e instanceof IOValidationError) return 'validation';\r\n  return 'runtime';\r\n}\r\n\r\nfunction errorToRange(e: any): ErrorRange | null {\r\n  if (!(e instanceof IOError)) return null;\r\n  const startPos: any = e.positionRange?.getStartPos();\r\n  const endPos: any = e.positionRange?.getEndPos();\r\n  if (!startPos || !endPos) return null;\r\n\r\n  return {\r\n    startLine: startPos.row,\r\n    startColumn: startPos.col,\r\n    endLine: endPos.row,\r\n    endColumn: endPos.col,\r\n  };\r\n}\r\n\r\nfunction errorToErrorItem(e: any, source: 'doc' | 'defs'): ErrorItem | null {\r\n  const range = errorToRange(e);\r\n  if (!range) return null;\r\n\r\n  const category = getErrorCategory(e);\r\n  const message = e?.message || String(e);\r\n\r\n  return {\r\n    id: generateErrorId(range, message),\r\n    code: (e as any).code,\r\n    category,\r\n    message,\r\n    range,\r\n    source,\r\n  };\r\n}\r\n\r\nfunction getErrorMarkers(e: any): EditorMarker[] {\r\n  if (!(e instanceof IOError)) return [];\r\n  const range = errorToRange(e);\r\n  if (!range) return [];\r\n\r\n  const category = getErrorCategory(e);\r\n  const severity = categoryToSeverity(category) as 1 | 2 | 4 | 8;\r\n  const message = e?.message || String(e);\r\n\r\n  const marker: EditorMarker = {\r\n    message,\r\n    severity,\r\n    startLineNumber: range.startLine,\r\n    startColumn: range.startColumn,\r\n    endLineNumber: range.endLine,\r\n    endColumn: range.endColumn,\r\n    id: generateErrorId(range, message),\r\n    category,\r\n  };\r\n  return [marker];\r\n}\r\n\r\n// Export empty object to satisfy TypeScript module requirements\r\nexport {};\r\n"],"names":["IODocument","header","sections","errors","options","_a","_b","_c","sectionsLen","data","i","section","headerObject","GeneralErrorCodes","TokenizationErrorCodes","ParsingErrorCodes","ValidationErrorCodes","ErrorCodes","__classPrivateFieldGet","receiver","state","kind","f","__classPrivateFieldSet","value","_IOError_positionRange","IOError","errorCode","fact","positionRange","isEof","ssf","errorMsg","pr","startPos","IOValidationError","InternetObjectError","posRange","TokenType","Token","pos","row","col","token","type","subType","t","text","lines","lastLine","TokenNode","defs","valueFound","Schema","name","o","item","key","SchemaBuilder","memberObjects","def","open","schema","n","IODefinitions","index","k","positionParam","ValidationError","v","dv","isSchema","isVariable","other","override","obj","keysCount","IOHeader","assertNever","x","message","IOObject","items","entry","array","io","newItems","newKeyMap","callbackfn","thisArg","selector","predicate","result","IOCollection","callback","mappedItems","filteredItems","initialValue","skipErrors","getAbsoluteValue","coefficient","POW10_CACHE","getPow10","exponent","scaleUp","scaleFactor","roundHalfUp","currentScale","targetScale","scaleDiff","divisor","quotient","remainder","halfDivisor","ceilRound","floorRound","formatBigIntAsDecimal","scale","precision","sign","coeffStr","integerPart","fractionalPart","validatePrecisionScale","alignOperands","aCoefficient","aScale","bCoefficient","bScale","maxScale","roundingMode","aAdjustment","bAdjustment","adjustedA","adjustedB","DecimalError","calculateAdditionResultPrecisionScale","precision1","scale1","precision2","scale2","resultScale","integerDigits1","integerDigits2","calculateMultiplicationResultPrecisionScale","calculateDivisionResultPrecisionScale","minScale","calculatedScale","validateAndAdjustPrecisionScale","maxPrecision","effectiveMaxScale","adjustedPrecision","adjustedScale","calculateRdbmsArithmeticResult","operation","Decimal","decimalInit","regex","match","adjustedInteger","adjustedFractional","rounded","normalizedInteger","combinedNormalized","roundedCombined","coeff","fromScale","fromCoefficient","targetIntegerDigits","actualIntegerDigits","scaleDifference","newCoefficient","roundedCoefficient","_precision","intRaw","fracRaw","adjusted","formatted","str","trimmed","mantissa","exponentPart","integerPartRaw","fractionalPartRaw","absExp","absCoeffStr","numberStr","numberValue","targetPrecision","error","roundedCoeff","decimalStr","ceiledCoeff","flooredCoeff","aCoeff","bCoeff","q","remainderCoeff","digits","finalPrecision","resultStr","calcPrecision","calcScale","sumCoeff","diffCoeff","resultCoeff","intermediateScale","adjustedCoeff","resultDigits","exponentAdjustment","numerator","down","denominator","absDen","isNegative","IOSection","_schemaName","IOSectionCollection","proxy","nameOrIndex","target","property","IOSyntaxError","ContainerNode","children","child","ArrayNode","openBracket","closeBracket","MemberNode","ObjectNode","InternetObject","member","keyStr","valueStr","keys","TypedefRegistry","enable","typeDefConstructors","Constructor","typeDef","typeName","processMember","memberDef","valueNode","processObject","collectionIndex","schemaName","_processObject","positional","processedNames","val","SyntaxError","m","err","memberNode","ErrorNode","position","endPosition","errorName","SchemaResolver","resolved","processCollection","errorCollector","resolvedSchema","collection","Collection","length","errorNode","CollectionNode","ValidationUtils","hasCtorName","processSchema","validData","validSchema","doCommonTypeCheck","node","isUndefined","isNull","_default","InternetObjectValidationError","_valueRequired","msg","found","choice","_invlalidChoice","of","AnyDef","changed","anyOf","getMemberDef","e","ArrayDef","_processNode","arrayMemberDef","_BooleanDef_instances","_BooleanDef_validate","BooleanDef","datetimeExp","datetimePlainExp","parseDateTime","year","month","date","hour","minute","second","milisecond","tz","dateStr","parseDate","parseTime","dateToDatetimeString","noSep","zuluTime","dateToDateString","dateToTimeString","dateToSmartString","dateToIOString","_DateTimeDef_instances","_DateTimeDef_type","_DateTimeDef_validate","DATETIME_TYPES","DateTimeDef","dt.dateToIOString","dateType","min","dt.dateToSmartString","max","NUMBER_TYPES","NUMBER_MAP","acc","throwError","code","memberPath","getIntegerDigits","decimal","bigintSchema","BigIntDef","valueType","decimalSchema","DecimalDef","requiredPrecision","requiredScale","valD","hasRequiredPrecision","hasRequiredScale","actualScale","actualPrecision","intDigits","maxIntDigits","minD","valIntDigits","minIntDigits","normalizedVal","normalizedMin","maxD","normalizedMax","numberSchema","NumberDef","typeBoundMin","typeBoundMax","effectiveMin","effectiveMax","ObjectDef","compileObject","reStructuralChars","escapeChars","reNewLine","toOpenString","escapeLines","toRegularString","encloser","toRawString","toAutoString","STRING_TYPES","emailExp","urlExp","StringDef","_process","strings.toAutoString","strings.toOpenString","strings.toRegularString","strings.toRawString","_validatePattern","len","maxLen","minLen","re","pattern","flags","registered","registerTypes","createMemberDef","input","opts","allowNameless","out","canonicalizeAdditionalProps","path","firstChild","typeToken","normalizeKeyToken","keyNode","parseObjectDef","parseObjectOrTypeDef","firstNode","parseMemberDef","typeNode","parseArrayOrTypeDef","a","additionalDef","addMemberDef","keyToken","fieldInfo","parseName","_","optionalExp","nullExp","optNullExp","objectDef","arrayDef","tokenSpanRange","startToken","endToken","unclosedConstructRange","currentPos","createPosition","Symbols","isSpecialSymbol","char","isDigit","WHITESPACE_LOOKUP","isWhitespace","hspacesOnly","isValidOpenStringChar","Literals","REGEX_CACHE","CHAR_CODES","isDigitFast","charCode","WHITESPACE_LOOKUP_FAST","isWhitespaceFast","regexHex4","regexHex2","reFloatDigit","reIntDigit","reHex","reOctal","reBinary","NON_DECIMAL_PREFIXES","reSectionSchemaName","nonDecimalPrefixes","reAnotatedStrStart","Tokenizer","startRow","startCol","tokenText","is.isWhitespace","is.isSpecialSymbol","step","start","needToNormalize","escapeChar","openingToken","hex","hexByte","getPos","annotation","fullTokenText","fn","dtParser.parseDateTime","dtParser.parseDate","dtParser.parseTime","dt","rawValue","base","hasDecimal","hasExponent","prefix","infLiteral","is.isDigit","tokenType","normalizeString","is.isValidOpenStringChar","first","spaces","estimatedTokens","tokens","tokenIndex","ch","nextToken","sep","schema2","DocumentNode","SectionCollection","Document","SectionNode","nameNode","schemaNode","Section","ASTParser","members","errorEndToken","checkIndex","range","originalName","suffix","objects","lastToken","isCollectionContext","firstMember","isOpenObject","done","leftToken","arr","currentToken","curerntCommaToken","steps","types","prevToken","parse","source","externalDefs","Header","docNode","doc","parseDefs","parseDataWithSchema","parseData","sectionNode","validationErrors","cols","schemaDefs","schemaDef","parseDefinitions","MonacoSeverity","categoryToSeverity","category","generateErrorId","isParseRequest","event","parseIO","response","document","minifiedOutput","parseDoc","defsResult","tryParse","isDefs","accumulatedErrors","output","errorItems","errorToErrorItem","getErrorMessage","getErrorMarkers","errorItem","intermediate","d","hasErrors","jsonText","getErrorCategory","errorToRange","endPos","severity"],"mappings":"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"}