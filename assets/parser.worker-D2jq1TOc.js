class dt{constructor(t,e,n=[]){this._errors=[],this._header=t,this._sections=e,this._errors=n}get header(){return this._header}get sections(){return this._sections}getErrors(){return[...this._errors]}addErrors(t){t.length>0&&this._errors.push(...t)}toJSON(t){var r,o,a;const e=((r=this._sections)==null?void 0:r.length)||0;let n=null;if(e===1)n=((o=this._sections)==null?void 0:o.get(0)).toJSON(t);else if(e>1){n={};for(let l=0;l<e;l++){const c=(a=this._sections)==null?void 0:a.get(l);n[c.name]=c.toJSON(t)}}const s=this.header.toJSON();return s&&Object.keys(s).length>0?{header:s,data:n}:n}toObject(t){return this.toJSON(t)}}var gt;(function(i){i.invalidType="invalid-type",i.invalidValue="invalid-value",i.valueRequired="value-required",i.nullNotAllowed="null-not-allowed"})(gt||(gt={}));var mt;(function(i){i.stringNotClosed="string-not-closed",i.invalidEscapeSequence="invalid-escape-sequence",i.unsupportedAnnotation="unsupported-annotation",i.invalidDateTime="invalid-datetime"})(mt||(mt={}));var yt;(function(i){i.unexpectedToken="unexpected-token",i.expectingBracket="expecting-bracket",i.unexpectedPositionalMember="unexpected-positional-member",i.invalidKey="invalid-key",i.invalidSchema="invalid-schema",i.schemaNotFound="schema-not-found",i.schemaMissing="schema-missing",i.emptyMemberDef="empty-memberdef",i.invalidDefinition="invalid-definition",i.invalidMemberDef="invalid-memberdef",i.invalidSchemaName="invalid-schema-name",i.variableNotDefined="variable-not-defined",i.schemaNotDefined="schema-not-defined"})(yt||(yt={}));var wt;(function(i){i.invalidObject="invalid-object",i.unknownMember="unknown-member",i.duplicateMember="duplicate-member",i.additionalValuesNotAllowed="additional-values-not-allowed",i.invalidArray="invalid-array",i.notAnArray="not-an-array",i.notAString="not-a-string",i.invalidEmail="invalid-email",i.invalidUrl="invalid-url",i.invalidLength="invalid-length",i.invalidMinLength="invalid-min-length",i.invalidMaxLength="invalid-max-length",i.invalidPattern="invalid-pattern",i.unsupportedNumberType="unsupported-number-type",i.notANumber="not-a-number",i.notAnInteger="not-an-integer",i.outOfRange="out-of-range",i.invalidRange="invalid-range",i.invalidScale="invalid-scale",i.invalidPrecision="invalid-precision",i.notABool="not-a-bool",i.invalidChoice="invalid-choice"})(wt||(wt={}));const f={...gt,...mt,...yt,...wt};var it=function(i,t,e,n){if(e==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?i!==t||!n:!t.has(i))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?n:e==="a"?n.call(i):n?n.value:t.get(i)},kt=function(i,t,e,n,s){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof t=="function"?i!==t||!s:!t.has(i))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?s.call(i,e):s?s.value=e:t.set(i,e),e},B;class C extends Error{get positionRange(){return it(this,B,"f")}set positionRange(t){kt(this,B,t,"f"),this.updateMessage()}get code(){return this.errorCode}get position(){return it(this,B,"f")}constructor(t,e,n,s=!1,r){super(),B.set(this,void 0),this.errorCode=t,this.fact=e,kt(this,B,n,"f"),this.isEof=s,this.name="IOError",this.updateMessage(),this.__proto__=new.target.prototype}updateMessage(){let t=`"${this.errorCode}" `;if(this.fact&&(t+=`"${this.fact}" `),this.isEof)t+="at EOF";else if(it(this,B,"f")){const e=it(this,B,"f");if(typeof e.getStartPos=="function"){const n=e.getStartPos();t+=`at ${n.row}:${n.col}`}else typeof e.row=="number"&&typeof e.col=="number"&&(t+=`at ${e.row}:${e.col}`)}this.message=t}}B=new WeakMap;class y extends C{constructor(t,e,n,s=!1,r){super(t,e,n,s,r),this.name="InternetObject(ValidationError)"}}var u;(function(i){i.CURLY_OPEN="CURLEY_OPEN",i.CURLY_CLOSE="CURLY_CLOSE",i.BRACKET_OPEN="BRACKET_OPEN",i.BRACKET_CLOSE="BRACKET_CLOSE",i.COLON="COLON",i.COMMA="COMMA",i.STRING="STRING",i.BINARY="BINARY",i.NUMBER="NUMBER",i.BIGINT="BIGINT",i.DECIMAL="DECIMAL",i.BOOLEAN="BOOLEAN",i.NULL="NULL",i.UNDEFINED="UNDEFINED",i.DATETIME="DATETIME",i.DATE="DATE",i.TIME="TIME",i.WHITESPACE="WHITESPACE",i.SECTION_SEP="SECTION_SEP",i.SECTION_SCHEMA="SECTION_SCHEMA",i.SECTION_NAME="SECTION_NAME",i.COLLECTION_START="COLLECTION_START",i.UNKNOWN="UNKNOWN",i.ERROR="ERROR"})(u||(u={}));class S{constructor(){this.pos=-1,this.row=-1,this.col=-1,this.token="",this.value=void 0,this.type="",this.subType=""}static init(t,e,n,s,r,o,a){const l=new S;return l.pos=t,l.row=e,l.col=n,l.token=s,l.value=r,l.type=o,a&&(l.subType=a),l}clone(){const t=new S;return t.pos=this.pos,t.row=this.row,t.col=this.col,t.token=this.token,t.value=this.value,t.type=this.type,t.subType=this.subType,t}getStartPos(){return{row:this.row,col:this.col,pos:this.pos}}getEndPos(){const t=this.token.trimEnd(),e=t.split(`
`),n=e[e.length-1],s=this.row+e.length-1,r=e.length>1?n.length:this.col+n.length,o=this.pos+t.length;return{row:s,col:r,pos:o}}}class w extends S{constructor(t){super(),Object.assign(this,t)}toValue(t){if((this.type==="string"||this.type===u.STRING)&&t!==void 0){const e=t.getV(this.value);return e===void 0?this.value:e}return this.value}}class N{constructor(t,...e){this.names=[],this.defs={},this.open=!1,this.name=t,e&&e.length>0&&e.forEach(n=>{const s=Object.keys(n)[0],r=n[s];r.path===void 0&&(r.path=s),this.names.push(s),this.defs[s]=r})}get(t){return this.defs[t]}has(t){return this.defs[t]!==void 0}get memberCount(){return this.names.length}static create(t){return new we(t)}static fromLegacy(t,...e){return new N(t,...e)}}class we{constructor(t){this.name=t,this.names=[],this.defs={},this.isOpen=!1}addMember(t,e){if(this.defs[t])throw new Error(`Member '${t}' already exists in schema '${this.name}'`);return this.names.push(t),this.defs[t]={...e,path:e.path||t},this}setOpen(t){return this.isOpen=t,this}build(){const t=new N(this.name);for(const e of this.names)t.names.push(e),t.defs[e]=this.defs[e];return t.open=this.isOpen,Object.freeze(t.names),Object.freeze(t.defs),t}}class ve{constructor(){this._defaultSchema=null,this._definitions={}}get length(){return Object.keys(this._definitions).length}get keys(){return Object.keys(this._definitions)}at(t){const e=this.keys[t];return{key:e,value:this._definitions[e]}}get defaultSchema(){var t;return this._defaultSchema||((t=this._definitions.$schema)==null?void 0:t.value)||null}get defaultSchemaOnly(){const t=Object.keys(this._definitions);return t.length===1&&t[0]==="$schema"}get(t){var e;return(e=this._definitions[t])==null?void 0:e.value}getV(t){let e="";if((t||{}).type===u.STRING||(t||{}).type==="string")e=t.value;else if(typeof t=="string")e=t;else return;const n=this._definitions[e];if(!n){if(e.startsWith("$")||e.startsWith("@")){const s=typeof t=="string"?void 0:t;throw e.startsWith("$")?new y(f.schemaNotDefined,`Schema ${e} is not defined.`,s):new y(f.variableNotDefined,`Variable ${e} is not defined.`,s)}return}if(n.isVariable)return n.value;if(n.value instanceof w){const s=this.getV(n.value);if(s instanceof N)return this.set(e,s),s}return n.value}set(t,e){const n={isSchema:t.startsWith("$"),isVariable:t.startsWith("@"),value:e};this._definitions[t]=n,this._defaultSchema=null}delete(t){return t in this._definitions?(delete this._definitions[t],t==="$schema"&&(this._defaultSchema=null),!0):!1}push(t,e,n=!1,s=!1){this._definitions[t]={isSchema:n,isVariable:s,value:e},t==="$schema"&&(this._defaultSchema=e)}merge(t,e=!1){for(let n=0;n<t.length;n++){const{key:s,value:r}=t.at(n);(e||!this._definitions[s])&&this.push(s,r.value,r.isSchema,r.isVariable)}}toJSON(){var n;const t={};let e=0;for(let s=0;s<this.length;s++){const r=this.at(s);r.value.isSchema||r.value.isVariable||(e++,t[r.key]=(n=r.value.value)!=null&&n.toObject?r.value.value.toObject():r.value.value)}return e?t:null}*keyIterator(){for(const t of Object.keys(this._definitions))yield t}*entries(){for(const t of this.keyIterator())yield[t,this._definitions[t]]}*[Symbol.iterator](){yield*this.entries()}}class $t{constructor(){this._schema=null,this._definitions=new ve}get schema(){return this._schema||this._definitions.defaultSchema}set schema(t){this._schema=t}get definitions(){return this._definitions}merge(t,e=!1){e&&t.schema&&(this._schema=t.schema),t.definitions&&this._definitions.merge(t.definitions,e)}toJSON(){return this._definitions.toJSON()}}function R(i,t){let e="Assert never";throw i!=null&&(e=`Assert never: ${i.toString()}`),t&&(e+=` at ${t.toString()}`),new Error(e)}class H{constructor(t){if(Object.defineProperty(this,"items",{value:[],writable:!0,enumerable:!1,configurable:!1}),Object.defineProperty(this,"keyMap",{value:new Map,writable:!0,enumerable:!1,configurable:!1}),t)for(const[e,n]of Object.entries(t))this.set(e,n)}set(t,e){if(this.keyMap.has(t)){const n=this.keyMap.get(t);this.items[n]=[t,e]}else{const n=this.items.length;this.items.push([t,e]),this.keyMap.set(t,n)}return t!=="items"&&t!=="keyMap"&&Object.defineProperty(this,t,{value:e,writable:!0,enumerable:!0,configurable:!0}),this}push(...t){for(const e of t)if(Array.isArray(e)){const[n,s]=e;if(this.has(n))throw new Error(`Key '${n}' already exists`);const r=this.items.length;this.items.push([n,s]),this.keyMap.set(n,r)}else this.items.push([void 0,e])}get(t){const e=this.keyMap.get(t);if(e!==void 0){const n=this.items[e];return n?n[1]:void 0}}getAt(t){if(t<0||t>=this.items.length)return;const e=this.items[t];return e?e[1]:void 0}keyAt(t){if(t<0||t>=this.items.length)return;const e=this.items[t];return e?e[0]:void 0}has(t){return this.keyMap.has(t)}delete(t){const e=this.keyMap.get(t);return e!==void 0&&this.items[e]?(this.items[e]=void 0,this.keyMap.delete(t),delete this[t],!0):!1}deleteAt(t){if(t<0||t>=this.items.length)throw new Error("Index out of range");const e=this.items[t];if(e){const n=e[0];return n!==void 0&&this.keyMap.delete(n),this.items[t]=void 0,!0}return!1}setAt(t,e){if(t<0||t>=this.items.length)throw new Error("Index out of range");const n=this.items[t];return n?(this.items[t]=[n[0],e],!0):!1}indexOfKey(t){return this.keyMap.get(t)??-1}indexOf(t){return this.items.findIndex(e=>e!==void 0&&Object.is(e[1],t))}isEmpty(){return this.length===0}static fromArray(t){const e=new H;for(const n of t)Array.isArray(n)?e.set(n[0],n[1]):e.push(n);return e}get length(){return this.items.length}clear(){for(const t of this.keysArray())delete this[t];this.items=[],this.keyMap.clear()}compact(){const t=[],e=new Map;for(const n of this.items)if(n!==void 0){t.push(n);const s=n[0];s!==void 0&&e.set(s,t.length-1)}this.items=t,this.keyMap=e}forEach(t,e){for(let n=0;n<this.items.length;n++){const s=this.items[n];s!==void 0&&t.call(e,s[1],s[0],n)}}entries(){return this._createIterator(t=>t)}keysArray(){return this.items.filter(t=>t!==void 0&&t[0]!==void 0).map(t=>t[0])}keys(){return(function*(t){for(const e of t)e!==void 0&&e[0]!==void 0&&(yield e[0])})(this.items)}values(){return(function*(t){for(const e of t)e!==void 0&&(yield e[1])})(this.items)}valuesArray(){return this.items.filter(t=>t!==void 0).map(t=>t[1])}*_createIterator(t){for(const e of this.items)e!==void 0&&(yield t(e))}[Symbol.iterator](){return this.entries()}get[Symbol.toStringTag](){return"IOObject"}find(t){let e=0;for(const n of this.items){if(n!==void 0&&t(n[1],n[0],e))return n[1];e++}}findIndex(t){let e=0;for(const n of this.items){if(n!==void 0&&t(n[1],n[0],e))return e;e++}return-1}map(t,e){const n=[];let s=0;for(const r of this.items)r!==void 0&&n.push(t.call(e,r[1],r[0],s)),s++;return n}toJSON(){const t={};return this.forEach((e,n,s)=>{typeof e>"u"||(t[n||s]=typeof e=="object"&&typeof(e==null?void 0:e.toJSON)=="function"?e.toJSON():e)}),t}}class q{constructor(t=[]){this._items=t}push(...t){return this._items.push(...t),this}getAt(t){if(t<0||t>=this._items.length)throw new Error("Index out of range");return this._items[t]}setAt(t,e){if(t<0)throw new Error("Index cannot be negative.");return t>=this._items.length?this._items.push(e):this._items[t]=e,this}deleteAt(t){if(t<0||t>=this._items.length)throw new Error("Index out of range");return this._items.splice(t,1),this}get length(){return this._items.length}get isEmpty(){return this.length===0}map(t){const e=this._items.map(t);return new q(e)}filter(t){const e=this._items.filter(t);return new q(e)}reduce(t,e){return this._items.reduce(t,e)}forEach(t){this._items.forEach(t)}some(t){return this._items.some(t)}every(t){return this._items.every(t)}find(t){return this._items.find(t)}findIndex(t){return this._items.findIndex(t)}insert(t,...e){return this._items.splice(t,0,...e),this._items.length}pop(){return this._items.pop()}toJSON(t){const e=(t==null?void 0:t.skipErrors)??!1;return this._items.filter(n=>{if(e&&typeof n=="object"&&n!==null&&typeof n.toValue=="function"){const s=n.toValue();if(s&&s.__error===!0)return!1}return!0}).map(n=>n instanceof H?n.toJSON():typeof n=="object"&&n!==null?typeof n.toValue=="function"?n.toValue():typeof n.toJSON=="function"?n.toJSON():JSON.stringify(n):n)}getErrors(){const t=[];for(const e of this._items)e&&typeof e=="object"&&e.error instanceof Error&&t.push(e.error);return t}*[Symbol.iterator](){yield*this._items}*entries(){for(let t=0;t<this._items.length;t++)yield[t,this._items[t]]}*keys(){for(let t=0;t<this._items.length;t++)yield t}*values(){yield*this._items}}function Ee(i){return i<0n?-i:i}const ht=new Map;function z(i){if(i<0)throw new Error("Exponent must be non-negative");return ht.has(i)||ht.set(i,10n**BigInt(i)),ht.get(i)}function U(i,t){if(t<0)throw new Error(`Scale factor must be non-negative, got ${t}`);return t===0?i:i*z(t)}function W(i,t,e){if(t<0||e<0)throw new Error("Scales must be non-negative");if(t<=e)return U(i,e-t);const n=t-e,s=z(n),r=i/s,o=i%s,a=s/2n;return(o<0n?-o:o)>=a?r+(i>=0n?1n:-1n):r}function vt(i,t,e){if(t<0||e<0)throw new Error("Scales must be non-negative");if(t<=e)return U(i,e-t);const n=t-e,s=z(n),r=i/s;return i%s!==0n&&i>0n?r+1n:r}function Et(i,t,e){if(t<0||e<0)throw new Error("Scales must be non-negative");if(t<=e)return U(i,e-t);const n=t-e,s=z(n),r=i/s;return i%s!==0n&&i<0n?r-1n:r}function A(i,t,e){if(i===0n)return t>0?`0.${"0".repeat(t)}`:"0";const n=i<0n?"-":"";let r=(i<0n?-i:i).toString();for(;r.length<=t;)r="0"+r;const o=r.slice(0,r.length-t)||"0",a=t>0?r.slice(-t):"";return n+o+(t>0?"."+a:"")}function Se(i,t,e){if(t<=0)return{valid:!1,reason:"Precision must be positive"};if(e<0)return{valid:!1,reason:"Scale must be non-negative"};if(e>t)return{valid:!1,reason:"Scale must be less than or equal to precision"};if(i===0n)return{valid:!0};const s=Ee(i).toString();return s.length>t?{valid:!1,reason:`Coefficient has ${s.length} digits, exceeding precision of ${t}`}:s.length-e<0?{valid:!0}:{valid:!0}}function ft(i,t,e,n,s,r="round"){if(i===0n)return{a:0n,b:e,targetScale:n,scaleAdjustment:0};if(e===0n)return{a:i,b:0n,targetScale:t,scaleAdjustment:0};let o=Math.max(t,n);s!==void 0&&o>s&&(o=s);const a=o-t,l=o-n;let c=i,h=e;if(a>0&&(c=U(i,a)),l>0&&(h=U(e,l)),s!==void 0){if(t>s)switch(r){case"round":c=W(i,t,s);break;case"ceil":c=vt(i,t,s);break;case"floor":c=Et(i,t,s);break;default:throw new d(`Invalid rounding mode: ${r}`)}if(n>s)switch(r){case"round":h=W(e,n,s);break;case"ceil":h=vt(e,n,s);break;case"floor":h=Et(e,n,s);break;default:throw new d(`Invalid rounding mode: ${r}`)}}return{a:c,b:h,targetScale:o,scaleAdjustment:Math.max(a,l)}}function be(i,t,e,n){if(i<=0||e<=0)throw new d("Precision must be positive");if(t<0||n<0)throw new d("Scale must be non-negative");if(t>i||n>e)throw new d("Scale must not exceed precision");const s=Math.max(t,n),r=i-t,o=e-n;return{precision:Math.max(r,o)+s+1,scale:s}}function Ne(i,t,e,n){if(i<=0||e<=0)throw new d("Precision must be positive");if(t<0||n<0)throw new d("Scale must be non-negative");if(t>i||n>e)throw new d("Scale must not exceed precision");const s=t+n;return{precision:i+e+1,scale:s}}function Te(i,t,e,n,s=6){if(i<=0||e<=0)throw new d("Precision must be positive");if(t<0||n<0)throw new d("Scale must be non-negative");if(t>i||n>e)throw new d("Scale must not exceed precision");if(s<0)throw new d("Minimum scale must be non-negative");const r=t+e+1,o=Math.max(s,r);return{precision:i-t+n+o,scale:o}}function Oe(i,t,e=38,n){const s=n??e;if(i<=0)throw new d("Precision must be positive");if(t<0)throw new d("Scale must be non-negative");if(t>i)throw new d("Scale must not exceed precision");if(i<=e&&t<=s)return{precision:i,scale:t};let r=Math.min(i,e),o=Math.min(t,s);return o>r&&(o=Math.max(0,r-1)),o>=r&&(o=Math.max(0,r-1)),{precision:r,scale:o}}function Ct(i,t,e,n,s,r){let o;switch(i){case"add":case"subtract":o=be(t,e,n,s);break;case"multiply":o=Ne(t,e,n,s);break;case"divide":o=Te(t,e,n,s,r==null?void 0:r.divisionMinScale);break;default:throw new d(`Unsupported operation: ${i}`)}return Oe(o.precision,o.scale,r==null?void 0:r.maxPrecision,r==null?void 0:r.maxScale)}class d extends Error{constructor(t){super(t),this.name="DecimalError"}}class v{constructor(t,e,n){this.coefficient=0n,this.exponent=0,[e,n]=this.resolvePrecisionAndScale(t,e,n),this.precision=e,this.scale=n,this.validatePrecisionAndScale(e,n);let s;if(typeof t=="string")s=this.initFromString(t,e,n);else if(typeof t=="number")s=this.initFromNumber(t,e,n);else if(t instanceof v)s=this.initFromDecimal(t,e,n);else throw new d("Unsupported value type for Decimal constructor.");this.coefficient=s.coefficient,this.exponent=s.exponent}resolvePrecisionAndScale(t,e,n){if(typeof t=="number"){if(e===void 0||n===void 0)throw new d("Precision and scale must be provided for number type.");return[e,n]}if(t instanceof v)return(e===void 0||n===void 0)&&(e=t.getPrecision(),n=t.getScale()),[e,n];if(typeof t=="string"){if(e===void 0||n===void 0){const s=/^-?(\d+)(?:\.(\d+))?$/,r=t.trim().match(s);if(!r)throw new d("Invalid decimal string format.");const o=r[1],a=r[2]||"";e=(o.replace(/^0+/,"").length||0)+a.length,n=a.length,e===0&&(e=1)}return[e,n]}throw new d("Unsupported value type for Decimal constructor.")}validatePrecisionAndScale(t,e){const n=Se(1n,t,e);if(!n.valid)throw new d(n.reason||"Invalid precision or scale")}initFromString(t,e,n){if(!v.isValidDecimal(t))throw new d("Invalid decimal string format.");const{sign:s,integerPart:r,fractionalPart:o}=v.parseString(t);let a=r,l=o;if(o.length>n){const T=v.roundForDecimal(r+"."+o,e,n);a=T.integerPart,l=T.fractionalPart}else l=o.padEnd(n,"0");const c=a.replace(/^0+/,"")||"0",p=(c+l).replace(/^0+/,"")||"0";if(p.length>e){const T=v.roundForDecimal(c+"."+l,e,n),j=T.integerPart+T.fractionalPart;if(j.replace(/^0+/,"").length>e)throw new d(`Value '${t}' exceeds specified precision (${e}) after rounding.`);const k=BigInt(j);return{coefficient:s==="-"?-k:k,exponent:n}}const g=BigInt(p);return{coefficient:s==="-"?-g:g,exponent:n}}initFromNumber(t,e,n){return this.initFromString(t.toString(),e,n)}initFromDecimal(t,e,n){t.getPrecision();const s=t.getScale(),r=t.getCoefficient(),o=e-n,l=t.toString().split(".")[0].replace("-","").length;if(l>o)throw new d(`Cannot adjust precision: integer part needs ${l} digits, but target precision-scale only allows ${o}.`);return n>s?this.increaseScaleForDecimal(t,e,n,s,r):n<s?this.decreaseScaleForDecimal(t,e,n,s,r):this.sameScaleForDecimal(t,e,n,r)}increaseScaleForDecimal(t,e,n,s,r){const o=n-s,a=U(r,o);if(a.toString().replace("-","").length>e)throw new d(`Value exceeds the specified precision (${e}) after scaling.`);return{coefficient:a,exponent:n}}decreaseScaleForDecimal(t,e,n,s,r){const o=W(r,s,n);return o.toString().replace("-","").length,{coefficient:o,exponent:n}}sameScaleForDecimal(t,e,n,s){if(t.getTotalDigits()>e)throw new d(`Value exceeds the specified precision (${e}).`);return{coefficient:s,exponent:n}}static roundForDecimal(t,e,n){const[s="0",r=""]=t.split("."),o=r.length,a=BigInt((s||"0")+(r||"")),l=W(a,o,n),c=A(l,n),[h,p=""]=c.split(".");return{integerPart:h,fractionalPart:p}}getTotalDigits(){return this.coefficient.toString().replace("-","").length}static isValidDecimal(t){let e=t.trim();return e.endsWith("m")&&(e=e.slice(0,-1)),/^[+\-]?\d+(\.\d+)?([eE][+-]?\d+)?$/.test(e)}static parseString(t){let e=t.trim();e.endsWith("m")&&(e=e.slice(0,-1));let n="";e.startsWith("-")?(n="-",e=e.slice(1)):e.startsWith("+")&&(e=e.slice(1));const[s,r]=e.split(/[eE]/),o=r?parseInt(r,10):0,[a,l=""]=s.split(".");let c=a||"0",h=l;if(o>0)h.length>o?(c+=h.slice(0,o),h=h.slice(o)):(c+=h.padEnd(o,"0"),h="");else if(o<0){const p=Math.abs(o);c.length>p?(h=c.slice(-p)+h,c=c.slice(0,-p)):(h=c.padStart(p,"0")+h,c="0")}return{sign:n,integerPart:c,fractionalPart:h}}static ensureDecimal(t){if(t instanceof v)return t;if(typeof t=="number")return new v(t.toString());if(typeof t=="string")return new v(t);throw new d(`Unsupported value type for Decimal conversion: ${typeof t}`)}toNumber(){const t=this.coefficient<0n?"-":"";let e=(this.coefficient<0n?-this.coefficient:this.coefficient).toString();if(this.exponent===0)return+`${t}${e}`;for(;e.length<=this.exponent;)e="0"+e;const n=e.slice(0,-this.exponent)||"0",s=e.slice(-this.exponent),r=`${t}${n}.${s}`,o=Number(r);if(!isFinite(o))throw new d("Conversion to Number results in Infinity.");return o}compareTo(t){if(this.precision!==t.precision||this.scale!==t.scale)throw new d("Decimals must have the same precision and scale for comparison.");return this.coefficient===t.coefficient?0:this.coefficient>t.coefficient?1:-1}compareStructure(t){return this.precision===t.precision&&this.scale===t.scale}equals(t){return this.compareTo(t)===0}lessThan(t){return this.compareTo(t)===-1}greaterThan(t){return this.compareTo(t)===1}lessThanOrEqual(t){return this.compareTo(t)<=0}greaterThanOrEqual(t){return this.compareTo(t)>=0}toString(){return A(this.coefficient,this.scale)}getPrecision(){return this.precision}getScale(){return this.scale}getExponent(){return this.exponent}getCoefficient(){return this.coefficient}getFormatPattern(){const t="x".repeat(this.precision-this.scale),e="x".repeat(this.scale);return this.scale>0?`${t}.${e}`:`${t}`}convert(t,e){if(e>t)throw new d("Scale must be less than or equal to precision.");try{return new v(this,t,e)}catch(n){throw n instanceof d?n:new d(`Conversion failed: ${n instanceof Error?n.message:String(n)}`)}}round(t,e){if(e>t)throw new d("Scale must be less than or equal to precision.");if(t<1)throw new d("Precision must be at least 1.");if(e<0)throw new d("Scale must be non-negative.");const n=W(this.coefficient,this.scale,e),s=A(n,e);return new v(s,t,e)}ceil(t,e){if(e>t)throw new d("Scale must be less than or equal to precision.");if(t<1)throw new d("Precision must be at least 1.");if(e<0)throw new d("Scale must be non-negative.");const n=vt(this.coefficient,this.scale,e),s=A(n,e);return new v(s,t,e)}floor(t,e){if(e>t)throw new d("Scale must be less than or equal to precision.");if(t<1)throw new d("Precision must be at least 1.");if(e<0)throw new d("Scale must be non-negative.");const n=Et(this.coefficient,this.scale,e),s=A(n,e);return new v(s,t,e)}mod(t){if(!(t instanceof v))throw new d("Invalid operand");if(t.coefficient===0n)throw new d("Division by zero");const{a:e,b:n,targetScale:s}=ft(this.coefficient,this.scale,t.coefficient,t.scale),r=e/n,o=e-r*n,a=o.toString().replace("-","").length,l=Math.max(a,this.precision,t.precision),c=A(o,s);return new v(c,l,s)}add(t){if(!(t instanceof v))throw new d("Invalid operand");const{precision:e,scale:n}=Ct("add",this.precision,this.scale,t.precision,t.scale,{maxPrecision:1e4,maxScale:1e4}),{a:s,b:r}=ft(this.coefficient,this.scale,t.coefficient,t.scale,n,"round"),o=s+r,a=o.toString().replace("-","").length,l=Math.max(e,a),c=A(o,n);return new v(c,l,n)}sub(t){if(!(t instanceof v))throw new d("Invalid operand");const{precision:e,scale:n}=Ct("subtract",this.precision,this.scale,t.precision,t.scale,{maxPrecision:1e4,maxScale:1e4}),{a:s,b:r}=ft(this.coefficient,this.scale,t.coefficient,t.scale,n,"round"),o=s-r,a=o.toString().replace("-","").length,l=Math.max(e,a),c=A(o,n);return new v(c,l,n)}mul(t){if(!(t instanceof v))throw new d("Invalid operand");const e=this.coefficient*t.coefficient,n=this.scale+t.scale,s=Math.max(this.scale,t.scale);let r=e;n>s?r=W(e,n,s):n<s&&(r=U(e,s-n));const o=r.toString().replace("-","").length;let a=Math.max(this.precision,t.precision,o);o>a&&(a=o);const l=A(r,s);return new v(l,a,s)}div(t){if(!(t instanceof v))throw new d("Invalid operand");if(t.coefficient===0n)throw new d("Division by zero");const e=t.scale,n=e+t.scale-this.scale;let s;if(n>=0)s=this.coefficient*z(n);else{const T=z(-n);s=this.coefficient/T}const r=t.coefficient;let o=s/r,a=s%r;const l=r<0n?-r:r;if((a<0n?-a:a)*2n>=l){const T=s<0n!=r<0n;o+=T?-1n:1n}const h=A(o,e),p=(o<0n?(-o).toString():o.toString()).length,g=Math.max(this.precision,t.precision,p);return new v(h,g,e)}}class St{constructor(t,e,n){this._data=t,this._name=e,this._schemaName=n}get name(){return this._name}get schemaName(){return this._schemaName}get data(){return this._data}toJSON(t){return this._data instanceof H?this._data.toJSON():this._data instanceof q?this._data.toJSON(t):this._data&&typeof this._data=="object"?this._data:null}}class bt{constructor(){return this._sections=[],this._sectionNames={},new Proxy(this,xe)}get sections(){return this._sections}get length(){return this._sections.length}get(t){if(typeof t=="string"){const e=this._sectionNames[t];return e===void 0?void 0:this._sections[e]}return this._sections[t]}push(t){t.name!==void 0&&(this._sectionNames[t.name]=this._sections.length),this._sections.push(t)}*[Symbol.iterator](){for(const t of this._sections)yield t}}const xe={get:(i,t)=>{if(t in i)return Reflect.get(i,t);if(typeof t=="string")return/^[0-9]+$/.test(t)?i.get(Number(t)):i.get(t)},set:(i,t,e)=>{throw new Error("Cannot set a value on a IOSectionCollection")}};class m extends C{constructor(t,e,n,s=!1,r){super(t,e,n,s,r),this.name="InternetObject(SyntaxError)",this.updateMessage()}}class xt{constructor(t,e=[]){this.type=t,this.children=e}toValue(t){return this.children.map(e=>{if(e)return e.toValue(t)})}}class et extends xt{constructor(t=[],e,n){super("array",t),this.openBracket=e,this.closeBracket=n}toValue(t){return this.children.map(e=>e!=null&&e.toValue?e.toValue(t):e)}getStartPos(){return this.openBracket.getStartPos()}getEndPos(){return this.closeBracket.getEndPos()}}class Y{constructor(t,e){this.type="member",this.value=t,e&&(this.key=e)}toValue(t){return this.key?{[this.key.value]:this.value.toValue(t)}:this.value.toValue(t)}getStartPos(){return this.key?this.key.getStartPos():this.value.getStartPos()}getEndPos(){return this.value?this.value.getEndPos():this.key?this.key.getEndPos():{row:0,col:0,pos:0}}}class I extends xt{constructor(t=[],e,n){super("object",t),e&&(this.openBracket=e),n&&(this.closeBracket=n)}toObject(t){const e={};let n=0;for(const s of this.children)s&&s.value?s.key?e[s.key.value]=s.value.toValue(t):e[n]=s.value.toValue(t):e[n]=void 0,n++;return e}getStartPos(){var t;return this.openBracket?this.openBracket.getStartPos():((t=this.children[0])==null?void 0:t.getStartPos())??{row:0,col:0,pos:0}}getEndPos(){var t;return this.closeBracket?this.closeBracket.getEndPos():((t=this.children[this.children.length-1])==null?void 0:t.getEndPos())??{row:0,col:0,pos:0}}toValue(t){const e=new H;for(let n=0;n<this.children.length;n++){const s=this.children[n];s&&s.value&&(s.key?e.set(s.key.value,s.value.toValue(t)):e.set(n.toString(),s.value.toValue(t)))}return e}isEmpty(){return this.children.length===0||this.children.every(t=>t===void 0)}toDebugString(){return`ObjectNode { ${this.children.map((e,n)=>{if(!e)return`[${n}]: undefined`;const s=e,r=s.key?s.key.value:`[${n}]`,o=s.value?typeof s.value.toValue=="function"?JSON.stringify(s.value.toValue()):String(s.value):"undefined";return`${r}: ${o}`}).join(", ")} }`}hasKey(t){return this.children.some(e=>{if(!e)return!1;const n=e;return n.key&&n.key.value===t})}getKeys(){const t=[];return this.children.forEach((e,n)=>{if(e){const s=e;s.key?t.push(s.key.value):t.push(n.toString())}}),t}isValid(){return this.children.every(t=>{if(!t)return!0;const e=t;return!(e.value&&e.value.error!==void 0||e.key&&e.key.error!==void 0)})}}class x{static setWarnOnDuplicates(t){this.warnDuplicates=t}static register(...t){for(const e of t)for(const n of e.types){if(this.typeDefMap.has(n)){this.warnDuplicates&&!this.warnedDuplicateTypes.has(n)&&(console.warn(`TypeDef for '${n}' is already registered. Skipping.`),this.warnedDuplicateTypes.add(n));continue}this.typeDefMap.set(n,new e(n)),this.typeNames.add(n)}}static unregister(t){this.typeDefMap.has(t)&&(this.typeDefMap.delete(t),this.typeNames.delete(t))}static get types(){return Object.freeze(Array.from(this.typeNames))}static get(t){const e=this.typeDefMap.get(t);if(!e)throw new C(f.invalidType,`Type '${t}' is not registered`);return e}static isRegisteredType(t){return this.typeDefMap.has(t)}static clear(){this.typeDefMap.clear(),this.typeNames.clear(),this.warnedDuplicateTypes.clear()}static get count(){return this.typeDefMap.size}}x.typeDefMap=new Map;x.typeNames=new Set;x.warnDuplicates=!1;x.warnedDuplicateTypes=new Set;function F(i,t,e){const n=x.get(t.type);if(!n)throw new Error(`Type ${t.type} is not registered.`);let s=i==null?void 0:i.value;return n.parse(s,t,e)}function st(i,t){if(!i||!t)return i;const e={...i};return typeof e.default=="string"&&e.default.startsWith("@")&&(e.default=t.getV(e.default),e.default instanceof w&&(e.default=e.default.value)),Array.isArray(e.choices)&&(e.choices=e.choices.map(n=>{if(typeof n=="string"&&n.startsWith("@")){let s=t.getV(n);return s instanceof w?s.value:s}return n})),typeof e.min=="string"&&e.min.startsWith("@")&&(e.min=t.getV(e.min),e.min instanceof w&&(e.min=e.min.value)),typeof e.max=="string"&&e.max.startsWith("@")&&(e.max=t.getV(e.max),e.max instanceof w&&(e.max=e.max.value)),e}function tt(i,t,e,n){if(t instanceof w){const s=t.value;t=e==null?void 0:e.getV(s)}return t instanceof N||R("Invalid schema type"),_e(i,t,e)}function _e(i,t,e,n){const s=new H;let r=!0;const o=new Set;if(t.names.length===1&&i.children.length>0){const l=i.children[0];if(l!=null&&l.key&&l.key.value!==t.names[0]){const c=t.names[0],h=st(t.defs[c],e),g=F({value:i},h,e);return g!==void 0&&s.set(c,g),s}}let a=0;for(;a<t.names.length;a++){let l=i.children[a],c=t.names[a],h=st(t.defs[c],e);if(l){if(l.key){r=!1;break}const p=F(l,h,e);if(p!==void 0)o.add(c),s.set(c,p);else if(!h.optional&&h.default===void 0)throw new y(f.valueRequired,`Expecting a value for ${h.path}.`,i)}else{if(!h.optional&&h.default===void 0)throw new y(f.valueRequired,`Expecting a value for ${h.path}.`,i);const g=F({value:void 0},h,e);g!==void 0&&(o.add(c),s.set(c,g))}}if(r)for(;a<i.children.length;a++){const l=i.children[a];if(!t.open)throw new m(f.additionalValuesNotAllowed,`Additional values are not allowed in the ${t.name}. The ${t.name} schema is not open.`,l.value);if(l.key){r=!1;break}const c=l.value.toValue(e);s.push(c)}for(;a<i.children.length;a++){let l=i.children[a];if(!l.key)throw new m(f.unexpectedPositionalMember,"Positional members must not be allowed after the keyed member is found.",l);let c=l.key.value,h=st(t.defs[c],e);if(o.has(c))throw new m(f.duplicateMember,`Member ${c} is already defined.`,l);if(!h&&!t.open)throw new m(f.unknownMember,`The ${t.name?`${t.name} `:""}schema does not define a member named '${c}'.`,l.key);!h&&t.open&&(typeof t.open=="object"&&t.open.type?h={...t.open,path:c}:h={type:"any",path:c}),o.add(c);const p=F(l,h,e);s.set(c,p)}for(const l in t.defs){if(l==="*")continue;const c=st(t.defs[l],e);if(!o.has(l)){const h=i.children.find(p=>{var g;return((g=p.key)==null?void 0:g.value)===l});try{const p=F(h,c,e);p!==void 0&&s.set(l,p)}catch(p){throw p instanceof y&&(p.positionRange=i),p}}}if((t.open===!0||typeof t.open=="object"&&t.open.type)&&s.isEmpty()){for(const l of i.children){if(!l)continue;const c=l;let h=c.key?c.key.value:void 0;if(!h)continue;let p;typeof t.open=="object"&&t.open.type?p={...t.open,path:h}:p={type:"any",path:h};const g=F(c,p,e);s.set(h,g)}return s}return s}class K{constructor(t,e,n){this.error=t,this.position=e,this.endPosition=n}getErrorCategory(){const t=this.error.name;return t.includes("SyntaxError")?"syntax":t.includes("ValidationError")?"validation":"runtime"}toValue(t){const e={__error:!0,category:this.getErrorCategory(),message:this.error.message,name:this.error.name,position:this.position,...this.endPosition&&{endPosition:this.endPosition}},n=this.error;return n&&n.collectionIndex!==void 0&&(e.collectionIndex=n.collectionIndex),e}getStartPos(){return this.position}getEndPos(){return this.endPosition||this.position}}class Ie{static resolve(t,e){if(t instanceof w){const n=t.value,s=e==null?void 0:e.getV(n);if(!(s instanceof N))throw new Error(`Schema '${n}' not found or invalid`);return s}return t}static isSchemaVariable(t){return t instanceof w&&typeof t.value=="string"&&t.value.startsWith("$")}}function Re(i,t,e,n){const s=Ie.resolve(t,e),r=new q,o=i.children.length;for(let a=0;a<o;a++){const l=i.children[a];if(l instanceof K){try{l.error.collectionIndex=a}catch{}r.push(l)}else try{r.push(tt(l,s,e,a))}catch(c){if(c instanceof Error){c.collectionIndex=a;const h=new K(c,l.getStartPos(),l.getEndPos());n&&n.push(c),r.push(h)}else throw c}}return r}class ut extends xt{constructor(t=[]){super("collection",t)}toValue(t){const e=new q;for(const n of this.children)e.push(n==null?void 0:n.toValue(t));return e}getStartPos(){var t;return((t=this.children[0])==null?void 0:t.getStartPos())??{row:0,col:0,pos:0}}getEndPos(){var t;return((t=this.children[this.children.length-1])==null?void 0:t.getEndPos())??{row:0,col:0,pos:0}}isEmpty(){return this.children.length===0||this.children.every(t=>t===void 0)}toDebugString(){return`CollectionNode { ${this.children.map((e,n)=>{if(!e)return`[${n}]: undefined`;const s=typeof e.toValue=="function"?JSON.stringify(e.toValue()):String(e);return`[${n}]: ${s}`}).join(", ")} }`}size(){return this.children.length}hasValidItems(){return this.children.some(t=>t?t.error===void 0:!0)}getValidItems(){return this.children.filter(t=>t?t.error===void 0:!0)}isValid(){return this.children.every(t=>t?t.error===void 0:!0)}}class ct{static isValidDataNode(t){return t instanceof I||t instanceof ut}static isValidSchema(t){return t instanceof N||t instanceof w}static validateProcessingInputs(t,e){var n,s;if(!ct.isValidDataNode(t)){const r=(n=t==null?void 0:t.constructor)==null?void 0:n.name,o=t===null?"null":t===void 0||r===void 0?"undefined":r||"unknown";throw new Error(`Invalid data node type: ${o}`)}if(!ct.isValidSchema(e)){const r=(s=e==null?void 0:e.constructor)==null?void 0:s.name,o=e===null?"null":e===void 0||r===void 0?"undefined":r||"unknown";throw new Error(`Invalid schema type: ${o}`)}return{data:t,schema:e}}}function Yt(i,t,e,n){if(i===null)return null;const{data:s,schema:r}=ct.validateProcessingInputs(i,t);return s instanceof I?tt(s,r,e):Re(s,r,e,n)}function _(i,t,e,n,s){const r=t===void 0||t instanceof w&&t.type===u.UNDEFINED,o=e instanceof w?e.value===null:t===null;if(r){if(i.default!==void 0)return{value:ke(i.default,n),changed:!0};if(i.optional)return{value:void 0,changed:!0};throw new y(...$e(i,e))}if(o){if(i.null)return{value:null,changed:!0};const a=`Null is not allowed for ${i.path}`;throw new y(f.nullNotAllowed,a,e)}if(t=typeof t=="object"&&t.toValue?t.toValue(n):t,i.choices!==void 0){let a=t instanceof w?t.value:t,l=!1;for(let c of i.choices)if(typeof c=="string"&&c[0]==="@"&&(c=n==null?void 0:n.getV(c),c=c instanceof w?c.value:c),s?s(a,c):a===c){l=!0;break}if(!l)throw new y(...Ce(i,t,e))}return{value:t,changed:!1}}function ke(i,t){if(i instanceof w&&(typeof i.value=="string"&&i.value.startsWith("@")&&t?(i=t.getV(i),i=i instanceof w?i.value:i):i=i.value),typeof i=="string"&&i.startsWith("@")&&t&&(i=t.getV(i),i=i instanceof w?i.value:i),typeof i=="string"){if(i==="N")return null;if(i==="T"||i==="true")return!0;if(i==="F"||i==="false")return!1}return i}function $e(i,t){const e=`Value is required for ${i.path}`;return[f.valueRequired,e,t]}function Ce(i,t,e){if(!i.choices)throw Error("Choices not checked during NumberDef implementation.");t=t.toValue?t.toValue():t.toObject?t.toObject():t,t=JSON.stringify(t);let n=`The value of "${i.path}" must be one of the [${i.choices.join(", ")}]. Currently it is ${t}.`;return i.choices.length===1&&(n=`The value of "${i.path}" must be '${i.choices[0]}'. Currently it is ${t}.`),[f.invalidChoice,n,e]}const Ae={type:"any",__memberdef:!0},Le=new N("any",{type:{type:"string",optional:!1,null:!1,choices:["any"]}},{default:{type:"any",optional:!0,null:!0}},{choices:{type:"array",optional:!0,null:!1}},{anyOf:{type:"array",optional:!0,null:!1,of:Ae}},{isSchema:{type:"bool",optional:!0,null:!1,default:!1}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class Me{get type(){return"any"}get schema(){return Le}parse(t,e,n){const s=(n==null?void 0:n.getV(t))||t,{value:r,changed:o}=_(e,s,t,n);if(o)return r;const a=e.anyOf;if(!a)return e.__memberdef?ue(new Y(t),"",n):r;const l=[];for(let c=0;c<a.length;c++){const h=a[c];h.path=e.path;const p=x.get(h.type);if(!p)throw new C(f.invalidType,`Invalid type definition '${h.type}'`);try{return p.parse(t,h,n)}catch(g){l.push(g);continue}}if(l.length===a.length)throw new y(f.invalidValue,`None of the constraints defined for '${e.path}' matched.`,t);return s}static get types(){return["any"]}}const Pe=new N("array",{type:{type:"string",optional:!1,null:!1,choices:["array"]}},{default:{type:"array",optional:!0,null:!1}},{of:{type:"any",optional:!0,null:!1,__memberdef:!0}},{len:{type:"number",optional:!0,null:!1,min:0}},{minLen:{type:"number",optional:!0,null:!1,min:0}},{maxLen:{type:"number",optional:!0,null:!1,min:0}});class je{constructor(){this.parse=(t,e,n)=>Be(t,e,n)}get type(){return"array"}get schema(){return Pe}static get types(){return["array"]}}function Be(i,t,e){var h;const n=(e==null?void 0:e.getV(i))||i,{value:s,changed:r}=_(t,n,i,e);if(r)return s;if(!(n instanceof et))throw new y(f.notAnArray,`Expecting an array value for '${t.path}'`,i);let o,a={type:"any"};if(t.of instanceof N)o=x.get("object"),a.schema=t.of,a.path=t.path;else if((h=t.of)!=null&&h.type){if(o=x.get(t.of.type),!o)throw new y(f.invalidType,`Invalid type definition '${t.of.type}'`,i);a=t.of,a.path=t.path}else typeof t.of=="string"?R(t.of):o=x.get("any");const l=[];n.children.forEach(p=>{if(n!==i)try{l.push(o==null?void 0:o.parse(p,a,e))}catch(g){throw g instanceof y&&(g.positionRange=i),g}else l.push(o==null?void 0:o.parse(p,a,e))});const c=l.length;if(t.len!==void 0&&c!==t.len)throw new y(f.invalidLength,`The "${t.path||"array"}" must have exactly ${t.len} items, but has ${c}.`,n);if(t.minLen!==void 0&&c<t.minLen)throw new y(f.outOfRange,`The "${t.path||"array"}" must have at least ${t.minLen} items, but has ${c}.`,n);if(t.maxLen!==void 0&&c>t.maxLen)throw new y(f.outOfRange,`The "${t.path||"array"}" must have at most ${t.maxLen} items, but has ${c}.`,n);return l}var Ve=function(i,t,e,n){if(e==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?i!==t||!n:!t.has(i))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?n:e==="a"?n.call(i):n?n.value:t.get(i)},Nt,Kt;const Ue=new N("bool",{type:{type:"string",optional:!1,null:!1,choices:["bool"]}},{default:{type:"bool",optional:!0,null:!1}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class Fe{constructor(){Nt.add(this)}get type(){return"bool"}get schema(){return Ue}parse(t,e,n){return Ve(this,Nt,"m",Kt).call(this,t,e,n)}load(t,e,n){const{value:s,changed:r}=_(e,t);if(r)return s;if(typeof t!="boolean")throw new C(f.notABool,`Expecting a boolean value for '${e.path}' but found ${JSON.stringify(t)}.`);return t}stringify(t,e){return this.load(t,e),t?"T":"F"}static get types(){return["bool"]}}Nt=new WeakSet,Kt=function(t,e,n){const s=(n==null?void 0:n.getV(t))||t,{value:r,changed:o}=_(e,s,t,n);if(o)return r;if(!(s instanceof w)||s.type!==u.BOOLEAN)throw new C(f.notABool,`Expecting a boolean value for '${e.path}' but found ${s.toValue()}.`,t);return s.value};const _t={datetime:/^(?<dt>(?<year>\d{4})(?:\-(?<month>(?:1[0-2]|0[1-9]))(?:\-(?<date>[0-2][0-9]|3[0-1]))?)?(T(?<hour>[0-1][0-9]|2[0-3])(?:\:(?<minute>[0-5][0-9])(?:\:(?<sec>[0-5][0-9])(?:\.(?<milisecond>(?:\d{3})+))?)?)?)?(?<tz>(Z)|((?:\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:\:[0-5][0-9])?)))?)$/,date:/^(?<year>\d{4})(?:\-(?<month>(?:1[0-2]|0[1-9]))(?:\-(?<date>[0-2][0-9]|3[0-1]))?)?$/,time:/^(?<hour>[0-1][0-9]|2[0-3])(?:\:(?<minute>[0-5][0-9])(?:\:(?<second>[0-5][0-9])(?:\.(?<milisecond>(?:\d{3})+))?)?)?$/},It={datetime:/^(?<year>\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?(?:(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\d{3})+))?)?)?)?(?<tz>(Z)|((?:\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:[0-5][0-9])?)))?/,date:/^(?<year>\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?$/,time:/^(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\d{3})+))?)?)?$/},De=i=>{const e=(/[\-\:]/.test(i.substring(0,6))?_t.datetime:It.datetime).exec(i);if(!e)return null;const{year:n,month:s,date:r,hour:o,minute:a,second:l,milisecond:c,tz:h}=e.groups||{},g=`${n}-${s||"01"}-${r||"01"}T${o||"00"}:${a||"00"}:${l||"00"}.${c||"000"}${h||"Z"}`;return new Date(g)},We=i=>{const e=(/\-/.test(i.substring(0,5))?_t.date:It.date).exec(i);if(!e)return null;const{year:n,month:s,date:r}=e.groups||{},o=`${n}-${s||"01"}-${r||"01"}T00:00:00.000Z`;return new Date(o)},Ye=i=>{const e=(/\:/.test(i.substring(0,3))?_t.time:It.time).exec(i);if(!e)return null;const{hour:n,minute:s,second:r,milisecond:o}=e.groups||{},a=`1900-01-01T${n||"00"}:${s||"00"}:${r||"00"}.${o||"000"}Z`;return new Date(a)},Gt=(i,t=!1,e=!1)=>i===null?null:i.toISOString(),qt=(i,t=!1)=>i===null?null:i.toISOString().split("T")[0],zt=(i,t=!1)=>i===null?null:i.toISOString().split("T")[1].split(".")[0],At=(i,t,e=!1)=>{if(i===null)return null;switch(t){case"datetime":return Gt(i,e);case"date":return qt(i,e);case"time":return zt(i,e)}},Ke=(i,t,e=!1)=>{if(i===null)return"N";switch(t){case"datetime":return`dt"${Gt(i,e)}"`;case"date":return`d"${qt(i,e)}"`;case"time":return`t"${zt(i,e)}"`}};var L=function(i,t,e,n){if(e==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?i!==t||!n:!t.has(i))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?n:e==="a"?n.call(i):n?n.value:t.get(i)},Ge=function(i,t,e,n,s){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof t=="function"?i!==t||!s:!t.has(i))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?s.call(i,e):s?s.value=e:t.set(i,e),e},at,X,G,lt,Tt;const Ht=["datetime","date","time"],qe=new N("datetime",{type:{type:"string",optional:!1,null:!1,choices:Ht}},{default:{type:"datetime",optional:!0,null:!1}},{choices:{type:"array",optional:!0,null:!1,of:{type:"datetime"}}},{min:{type:"datetime",optional:!0,null:!1}},{max:{type:"datetime",optional:!0,null:!1}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class ze{get type(){return L(this,X,"f")}get schema(){return qe}constructor(t="datetime"){at.add(this),X.set(this,void 0),G.set(this,(e,n)=>{if(e){if(e instanceof Date)return e;if(e instanceof w){if(e.value instanceof Date)return e.value;if(n){const s=n.getV(e);if(s instanceof Date)return s;if(s instanceof w&&s.value instanceof Date)return s.value}}if(typeof e=="object"&&typeof e.toValue=="function"){const s=e.toValue(n);return L(this,G,"f").call(this,s,n)}}}),lt.set(this,(e,n)=>{const s=e instanceof Date?e:void 0,r=L(this,G,"f").call(this,n);return!s||!r?!1:s.getTime()===r.getTime()}),Ge(this,X,t,"f")}parse(t,e,n){const s=(n==null?void 0:n.getV(t))||t,{value:r,changed:o}=_(e,s,t,n,L(this,lt,"f"));if(o)return r;if(s.type!==u.DATETIME)throw new y(f.invalidDateTime,`Expecting a ${e.type.toUpperCase()} value for ${e.path}, currently ${s.value}, a ${s.type} value`,t);return L(this,at,"m",Tt).call(this,r,e,t,n),r}load(t,e,n){const{value:s,changed:r}=_(e,t,void 0,n,L(this,lt,"f"));if(r)return s;if(!(t instanceof Date))throw new y(f.invalidType,`Expecting a Date object for '${e.path}', got ${typeof t}`);return L(this,at,"m",Tt).call(this,t,e,void 0,n),t}stringify(t){return Ke(t,L(this,X,"f"))}static get types(){return Ht}}X=new WeakMap,G=new WeakMap,lt=new WeakMap,at=new WeakSet,Tt=function(t,e,n,s){const r=e.type;if(e.min){const o=L(this,G,"f").call(this,e.min,s);if(o&&t<o)throw new y(f.outOfRange,`Expecting the value ${e.path?`for '${e.path}'`:""} to be greater than or equal to '${At(o,r)}'`,n)}if(e.max){const o=L(this,G,"f").call(this,e.max,s);if(o&&t>o)throw new y(f.outOfRange,`Expecting the value ${e.path?`for '${e.path}'`:""} to be less than or equal to '${At(o,r)}'`,n)}};const nt=["bigint","decimal","int","uint","float","number","int8","int16","int32","uint8","uint16","uint32","uint64","float32","float64"],Jt=nt.reduce((i,t)=>(i[t]=!0,i),{});function P(i,t,e,n){let s;switch(i){case f.invalidType:s=`The '${t}' has an invalid type. ${e}`;break;case f.invalidRange:s=`The '${t}' must be within the specified range, Currently it is ${e}.`;break;case f.invalidScale:s=`The '${t}' has an invalid scale. ${e}`;break;case f.invalidPrecision:s=`The '${t}' has an invalid precision. ${e}`;break;default:s=`The '${t}' validation failed. ${e}`}throw new y(i,s,n)}function V(i){return i.toString().split(".")[0].replace("-","").length}const He=new N("bigint",{type:{type:"string",optional:!1,null:!1,choices:nt}},{default:{type:"bigint",optional:!0,null:!1}},{choices:{type:"array",optional:!0,null:!1,of:{type:"bigint"}}},{min:{type:"bigint",optional:!0,null:!1}},{max:{type:"bigint",optional:!0,null:!1}},{multipleOf:{type:"bigint",optional:!0,null:!1}},{format:{type:"string",optional:!0,null:!1,choices:["decimal","hex","octal","binary"],default:"decimal"}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class Je{constructor(){this._type="bigint"}get type(){return this._type}get schema(){return He}parse(t,e,n){const s=(n==null?void 0:n.getV(t))||t;typeof(s==null?void 0:s.toValue)=="function"&&s.toValue(n);let{value:r,changed:o}=_(e,s,t,n);return o||(r=this.validate(e,r,t)),r}load(t,e,n){const{value:s,changed:r}=_(e,t);return r?s:this.validate(e,t)}stringify(t,e){return this.validate(e,t),e.format==="hex"?t.toString(16):e.format==="octal"?t.toString(8):e.format==="binary"?t.toString(2):t.toString()}validate(t,e,n){const s=typeof e=="bigint"?"bigint":Jt[typeof e]?"number":"";if(s==="")throw new y(f.invalidType,`Expecting a value of type '${t.type}' for '${t.path}'`,n);if(s!=="bigint")throw new y(`not-a-${t.type}`,`Invalid value encountered for '${t.path}'`,n);const{min:r,max:o,multipleOf:a}=t;if((r!=null&&e<r||o!=null&&e>o)&&P(f.invalidRange,t.path,e,n),a!=null&&e%BigInt(a)!==0n)throw new y(f.invalidValue,`The value ${e} for '${t.path}' must be a multiple of ${a}`,n);return e}}const Ze=new N("decimal",{type:{type:"string",optional:!1,null:!1,choices:nt}},{default:{type:"decimal",optional:!0,null:!1}},{choices:{type:"array",optional:!0,null:!1,of:{type:"decimal"}}},{precision:{type:"number",optional:!0,null:!1}},{scale:{type:"number",optional:!0,null:!1}},{min:{type:"decimal",optional:!0,null:!1}},{max:{type:"decimal",optional:!0,null:!1}},{multipleOf:{type:"decimal",optional:!0,null:!1}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class Qe{constructor(){this._type="decimal"}get type(){return this._type}get schema(){return Ze}parse(t,e,n){const s=(n==null?void 0:n.getV(t))||t;let{value:r,changed:o}=_(e,s,t,n);return o||(typeof r=="number"&&P(f.invalidType,e.path,"Expected decimal value (with 'm' suffix), got number",t),r=this.validate(e,r,t)),r}load(t,e,n){const{value:s,changed:r}=_(e,t);return r?s:this.validate(e,t)}stringify(t,e){return this.validate(e,t),t.toString()}validate(t,e,n){let{min:s,max:r,precision:o,scale:a}=t;const l=v.ensureDecimal(e),c=o!=null,h=a!=null;if(h){const p=l.getScale();p!==a&&P(f.invalidScale,t.path,`Value has scale ${p}, expected ${a}`,n)}if(c){const p=l.getPrecision();if(h){const g=V(l),T=o-a;g>T&&P(f.invalidPrecision,t.path,`Integer part has ${g} digits, DECIMAL(${o},${a}) allows ${T}`,n)}else p>o&&P(f.invalidPrecision,t.path,`Value has precision ${p}, max allowed is ${o}`,n)}if(s!=null){const p=v.ensureDecimal(s),g=Math.max(l.getScale(),p.getScale()),T=V(l),j=V(p),k=Math.max(T,j)+g,J=l.convert(k,g),Z=p.convert(k,g);J.compareTo(Z)<0&&P(f.invalidRange,t.path,e,n)}if(r!=null){const p=v.ensureDecimal(r),g=Math.max(l.getScale(),p.getScale()),T=V(l),j=V(p),k=Math.max(T,j)+g,J=l.convert(k,g),Z=p.convert(k,g);J.compareTo(Z)>0&&P(f.invalidRange,t.path,e,n)}if(t.multipleOf!==void 0&&t.multipleOf!==null){const p=v.ensureDecimal(t.multipleOf),g=Math.max(l.getScale(),p.getScale()),T=V(l),j=V(p),k=Math.max(T,j)+g,J=l.convert(k,g),Z=p.convert(k,g),me=J.mod(Z),ye=new v(0,k,g);me.compareTo(ye)!==0&&P(f.invalidValue,t.path,`Value must be a multiple of ${p}`,n)}return l}}const Xe=new N("number",{type:{type:"string",optional:!1,null:!1,choices:nt}},{default:{type:"number",optional:!0,null:!1}},{choices:{type:"array",optional:!0,null:!1,of:{type:"number"}}},{min:{type:"number",optional:!0,null:!1}},{max:{type:"number",optional:!0,null:!1}},{multipleOf:{type:"number",optional:!0,null:!1}},{format:{type:"string",optional:!0,null:!1,choices:["decimal","hex","octal","binary","scientific"]}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class tn{get type(){return this._type}get schema(){return this._delegateTypeDef?this._delegateTypeDef.schema:Xe}constructor(t="number"){this._type=t,t==="bigint"?this._delegateTypeDef=new Je:t==="decimal"&&(this._delegateTypeDef=new Qe)}parse(t,e,n){if(this._delegateTypeDef)return this._delegateTypeDef.parse(t,e,n);const s=(n==null?void 0:n.getV(t))||t;typeof(s==null?void 0:s.toValue)=="function"&&s.toValue(n);let{value:r,changed:o}=_(e,s,t,n);return o||(r=this.validateInteger(e,r,t)),r}load(t,e,n){if(this._delegateTypeDef&&"load"in this._delegateTypeDef)return this._delegateTypeDef.load(t,e,n);const{value:s,changed:r}=_(e,t,void 0,n);return r?s:this.validateInteger(e,t)}stringify(t,e){return this.load(t,e),this._delegateTypeDef&&"stringify"in this._delegateTypeDef?this._delegateTypeDef.stringify(t,e):e.format==="scientific"?t.toExponential():e.format==="hex"?t.toString(16):e.format==="octal"?t.toString(8):e.format==="binary"?t.toString(2):t.toString()}validateInteger(t,e,n){const s=typeof e=="bigint"?"bigint":Jt[typeof e]?"number":"";if(s==="")throw new y(f.invalidType,`Expecting a value of type '${t.type}' for '${t.path}'`,n);if(s!=="number")throw new y(`not-a-${t.type}`,`Invalid value encountered for '${t.path}'`,n);const{min:r,max:o}=this.getTypeBounds(this._type),a=t.min!==void 0&&t.min!==null?t.min:r,l=t.max!==void 0&&t.max!==null?t.max:o;if((a!==null&&e<a||l!==null&&e>l)&&P(f.invalidRange,t.path,e,n),t.multipleOf!==void 0&&t.multipleOf!==null&&e%t.multipleOf!==0)throw new y(f.invalidValue,`The value ${e} for '${t.path}' must be a multiple of ${t.multipleOf}`,n);return e}getTypeBounds(t){switch(t){case"uint":return{min:0,max:null};case"int8":return{min:-128,max:2**7-1};case"uint8":return{min:0,max:2**8-1};case"int16":return{min:-32768,max:2**15-1};case"uint16":return{min:0,max:2**16-1};case"int32":return{min:-2147483648,max:2**31-1};case"uint32":return{min:0,max:2**32-1};case"uint64":case"int64":case"float32":case"float64":throw new C(f.unsupportedNumberType,`The number type '${t}' is not supported.`);default:return{min:null,max:null}}}static get types(){return nt}}const en=new N("object",{type:{type:"string",optional:!1,null:!1,choices:["object"]}},{default:{type:"object",optional:!0,null:!1}},{schema:{type:"object",optional:!0,null:!1,__schema:!0}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class nn{constructor(){this._names=null,this.parse=(t,e,n)=>this._process(t,e,n),this._process=(t,e,n)=>{const s=(n==null?void 0:n.getV(t))||t,{value:r,changed:o}=_(e,s,t,n);if(o)return r;let a=e.schema;if(!(s instanceof I))throw new y(f.invalidObject,`Expecting an object value for '${e.path}'`,t);if(s===t)return e.__schema?Rt(e.path||"",s,n):(a||(a=new N(e.path||""),a.open=!0),tt(s,a,n));try{return tt(s,a,n)}catch(l){throw l instanceof y&&(l.positionRange=t),l}return tt(s,a,n)}}get type(){return"object"}static get types(){return["object"]}get schema(){return en}}const Zt=/(?<structural>[\{\}\[\]\:\,\#\"\'\\\\~])/gm,Qt=/(?<escape>[\n\r\t])/gm,Xt=/(?<newlines>(\r\n?)|\n)/gm,te=(i,t)=>(i=i.replace(Zt,"\\$1"),t&&(i=i.replace(Xt,"\\n")),i),ee=(i,t,e='"')=>(i=i.replace(Qt,"\\$1"),t&&(i=i.replace(Xt,"\\n")),`${e}${i.replace(e,`\\${e}`)}${e}`),ne=(i,t='"')=>`r${t}${i.replace(t,t+t)}${t}`,sn=(i,t,e='"')=>Zt.test(i)?te(i,t):Qt.test(i)?ne(i,e):ee(i,t,e),ie=["string","url","email"],rn=/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/,on=/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/,an=new N("string",{type:{type:"string",optional:!1,null:!1,choices:ie}},{default:{type:"string",optional:!0,null:!1}},{choices:{type:"array",optional:!0,null:!1,of:{type:"string"}}},{pattern:{type:"string",optional:!0,null:!1}},{flags:{type:"string",optional:!0,null:!1}},{len:{type:"number",optional:!0,null:!1,min:0}},{minLen:{type:"number",optional:!0,null:!1,min:0}},{maxLen:{type:"number",optional:!0,null:!1,min:0}},{format:{type:"string",optional:!0,null:!1,choices:["auto","open","regular","raw"],default:"auto"}},{escapeLines:{type:"bool",optional:!0,null:!1,default:!1}},{encloser:{type:"string",optional:!0,null:!1,choices:['"',"'"],default:'"'}},{optional:{type:"bool",optional:!0}},{null:{type:"bool",optional:!0}});class ln{constructor(t="string"){this._type=t}get type(){return this._type}static get types(){return ie}get schema(){return an}parse(t,e,n){return cn(t,e,n)}load(t,e,n){const{value:s,changed:r}=_(e,t,void 0,n);if(r)return s;if(typeof t!="string")throw new y(f.notAString,`Expecting a string value for '${e.path}' but found ${JSON.stringify(t)}.`);se(e,t);const o=e.len;if(o!==void 0&&typeof o=="number"&&t.length!==o)throw new y(f.invalidLength,`Invalid length for ${e.path}.`);const a=e.maxLen;if(a!==void 0&&typeof a=="number"&&t.length>a)throw new y(f.invalidMaxLength,`Invalid maxLength for ${e.path}.`);const l=e.minLen;if(l!==void 0&&typeof l=="number"&&t.length<l)throw new y(f.invalidMinLength,`Invalid minLength for ${e.path}.`);return t}stringify(t,e){switch(this.load(t,e),e.format||"auto"){case"auto":return sn(t,e.escapeLines,e.encloser);case"open":return te(t,e.escapeLines);case"regular":return ee(t,e.escapeLines,e.encloser);default:return ne(t,e.encloser)}}}function cn(i,t,e){const n=(e==null?void 0:e.getV(i))||i,{value:s,changed:r}=_(t,n,i,e);if(r)return s;if(!(n instanceof w)||n.type!==u.STRING)throw new y(f.notAString,`Expecting a string value for '${t.path}' but found ${n.toValue()}.`,i);se(t,s,i);const o=t.len;if(o!==void 0&&typeof o=="number"&&s.length!==o)throw new y(f.invalidLength,`Invalid length for ${t.path}.`,n);const a=t.maxLen;if(a!==void 0&&typeof a=="number"&&s.length>a)throw new y(f.invalidMaxLength,`Invalid maxLength for ${t.path}.`,n);const l=t.minLen;if(l!==void 0&&typeof l=="number"&&s.length<l)throw new y(f.invalidMinLength,`Invalid minLen for ${t.path}.`,n);return s}function se(i,t,e){const n=i.type;if(n==="string"&&i.pattern!==void 0){let s=i.re;if(!s){let r=i.pattern,o=i.flags;try{o?s=i.re=new RegExp(r,o):s=i.re=new RegExp(r),i.re=s}catch{throw new y(f.invalidPattern,t,e)}}if(!s.test(t))throw new y(f.invalidPattern,`The value '${t}' does not match the pattern '${i.pattern}'.`,e)}else if(n==="email"){if(!rn.test(t))throw new y(f.invalidEmail,`Invalid email address: ${t}`,e)}else if(n==="url"&&!on.test(t))throw new y(f.invalidUrl,`Invalid URL: ${t}`,e)}let Lt=!1;function un(){Lt||(x.register(Me,je,Fe,tn,nn,ln,ze),Lt=!0)}function D(i,t){const e=(t==null?void 0:t.allowNameless)===!0;if(!i||typeof i!="object")throw new m(f.invalidMemberDef,"Invalid member definition input provided.");const{name:n,type:s}=i;if(!s||typeof s!="string")throw new m(f.invalidType,"MemberDef.type must be a non-empty string.");if(!e&&(!n||typeof n!="string"||n.trim()===""))throw new m(f.invalidMemberDef,"MemberDef must have a valid name.");if(s==="array"&&(!("of"in i)||typeof i.of!="object"||!i.of))throw new m(f.invalidDefinition,"Array MemberDef must include an 'of' definition.");const r={...i};return"optional"in r&&r.optional!==void 0&&(r.optional=!!r.optional),"null"in r&&r.null!==void 0&&(r.null=!!r.null),r}function hn(i,t="*"){if(i instanceof w){if(typeof i.value=="string"){if(x.isRegisteredType(i.value))return{type:i.value,path:t};if(i.value==="*")return{type:"any",path:t}}return{type:"any",path:t}}if(i instanceof I){if(i.children.length===0)return{type:"object",path:t,open:!0};const e=i.children[0];if(e&&!e.key&&e.value instanceof w){const n=e.value;if(typeof n.value=="string"&&x.isRegisteredType(n.value)){const s={type:n.value,path:t};for(let r=1;r<i.children.length;r++){const o=i.children[r];o&&o.key&&o.value instanceof w&&(s[o.key.value]=o.value.value)}return s}}return{type:"object",path:t}}if(i instanceof et){if(i.children.length===0)return{type:"array",path:t,of:{type:"any"}};const e=i.children[0];return e instanceof w&&typeof e.value=="string"?{type:"array",path:t,of:{type:e.value}}:{type:"array",path:t}}return typeof i=="object"&&i.type?{...i,path:t}:{type:"any",path:t}}function re(i){if(i||R("Key node must not be null in schema definition."),i instanceof w){if(i.type===u.STRING)return i}else if(i instanceof S&&i.type===u.STRING)return new w(i);throw new m(f.invalidKey,"The key must be a string.",i)}un();function Rt(i,t,e){if(t instanceof w&&t.type===u.STRING&&t.value.startsWith("$"))return t;if(!(t instanceof I))throw new m(f.invalidSchema,"Schema must be an object.",t);const n=new N(i);return le(t,n,"",e),n}function oe(i,t,e){if(i.children.length===0){const o=new N(t);return o.open=!0,{type:"object",path:t,schema:o}}const n=i.children[0];if(!n.key&&n.value instanceof w){const o=n.value;if(o.type===u.STRING){if(x.isRegisteredType(o.value))return Mt(o.value,i,e);if(typeof o.value=="string"&&o.value.startsWith("$"))return{type:"object",schema:o,path:t}}}let s="",r=null;for(let o=0;o<i.children.length;o++){const a=i.children[o];if(a instanceof Y&&a.key&&a.key.value==="type"&&a.value instanceof w&&a.value.type===u.STRING){s=a.value.value,r=a.value;break}}if(s!==""){if(typeof s=="string"&&s.startsWith("$"))return{type:"object",schema:r,path:t};if(x.isRegisteredType(s))return Mt(s,i,e);throw new m(f.invalidType,`The specified value '${s}' is not a valid type.`,r)}return{type:"object",schema:le(i,new N(t),t,e),path:t}}function ae(i,t,e){if(i.children.length>1)throw new m(f.invalidSchema,"The array definition must have only one child.",i.children[1]);if(i.children.length===0)return D({type:"array",of:{type:"any",path:t,null:!0},path:t},{allowNameless:!0});const n=i.children[0];if(n instanceof w){if(n.type===u.STRING){const s=n.value;if(x.isRegisteredType(s))return D({type:"array",of:{type:n.value,path:t},path:t},{allowNameless:!0});if(e&&s.startsWith("$"))return D({type:"array",of:{type:"object",schema:n,path:t},path:t},{allowNameless:!0})}throw new m(f.invalidType,`The specified value (${n.value}) is not a valid type`,n)}if(n instanceof I)return D({type:"array",of:oe(n,t,e),path:t},{allowNameless:!0});if(n instanceof et)return D({type:"array",of:ae(n,t,e),path:t},{allowNameless:!0});throw new m(f.invalidSchema,"The array of type definition must be a string or object.",n)}function le(i,t,e,n){for(let s=0;s<i.children.length;s++){const r=i.children[s];r===null&&R("Child value must not be null in schema definition.");const o=r;if(o.value instanceof w&&o.value.type===u.UNDEFINED)throw new m(f.emptyMemberDef,"The next member definition is empty.",o.value);if(o.key&&o.key.value==="*"){if(o.value){const a=hn(o.value,"*");t.defs["*"]=a,t.open=a}else t.open=!0;if(s!==i.children.length-1)throw new m(f.invalidSchema,"The * is only allowed at the last position.",o.value);continue}if(o.key){const a=ue(o,e,n);Pt(a,t,e)}else{if(o.value instanceof w&&o.value.type===u.STRING&&o.value.value==="*"){if(s!==i.children.length-1)throw new m(f.invalidSchema,"The * is only allowed at the last position.",o.value);t.open=!0;continue}const l=re(o.value),c=ce(l),h=D({...c,type:"any"});Pt(h,t,e)}}return t.names.length===0&&(t.open=!0),t}function fn(i,t){if(t)for(const e of i.children){if(!(e instanceof Y))continue;const n=e.value;if(n instanceof w&&typeof n.value=="string"&&n.value.startsWith("@")){const s=t.getV(n.value);s instanceof w?e.value=s:(n.value=s,typeof s=="number"?n.type=u.NUMBER:typeof s=="boolean"&&(n.type=u.BOOLEAN))}}}function Mt(i,t,e){fn(t,e);const n=x.get(i);return Yt(t,n.schema,e)}function Pt(i,t,e){if(t.defs[i.name])throw new m(f.duplicateMember,`Member ${i.name} is already defined in schema ${t.name}.`,t.defs[i.name]);i.path=Ot(e,i.name),t.names.push(i.name),t.defs[i.name]=i}const ce=i=>{if(i||R("Key node must not be null in schema definition."),!(i instanceof S))throw new m(f.invalidKey,"The key must be a string.",i);const t=i.value,e=/\?$/,n=/\*$/,s=/(\?\*)|(\*\?)$/;if(i.type!==u.STRING)throw new m(f.invalidKey,"The key must be a string.",i);return t.match(s)?{name:t.substring(0,t.length-2),optional:!0,null:!0}:t.match(n)?{name:t.substring(0,t.length-1),optional:!1,null:!0}:t.match(e)!==null?{name:t.substring(0,t.length-1),optional:!0,null:!1}:{name:t,optional:!1,null:!1}};function ue(i,t,e){const n=i.value;let s={name:""};if(i.key&&(s=ce(re(i.key))),n instanceof w&&n.type===u.STRING){const r=n.value;if(r.startsWith("$"))return{...s,type:"object",schema:n};if(x.isRegisteredType(r)===!1)throw new m(f.invalidType,`The type '${r}' is not supported.`,n);return{...s,type:r}}if(n instanceof I){const r=oe(n,Ot(t,s.name),e);return{...s,...r}}if(n instanceof et){const r=ae(n,Ot(t,s.name),e);return{...s,...r}}throw new m(f.invalidType,`Found '${n.toValue()}' but expecting a data type definition.`,n)}function Ot(i,t){return i===""?t:`${i}.${t}`}function pn(i,t){return{getStartPos:()=>i.getStartPos(),getEndPos:()=>t.getEndPos()}}function jt(i,t){return{getStartPos:()=>i.getStartPos(),getEndPos:()=>t}}function Bt(i,t,e){return{pos:i,row:t,col:e}}var b;(function(i){i.CURLY_OPEN="{",i.CURLY_CLOSE="}",i.BRACKET_OPEN="[",i.BRACKET_CLOSE="]",i.COLON=":",i.COMMA=",",i.HASH="#",i.DOUBLE_QUOTE='"',i.SINGLE_QUOTE="'",i.BACKSLASH="\\",i.TILDE="~",i.PLUS="+",i.MINUS="-",i.DOLLAR="$",i.DOT="."})(b||(b={}));const Vt=i=>[b.CURLY_OPEN,b.CURLY_CLOSE,b.BRACKET_OPEN,b.BRACKET_CLOSE,b.COLON,b.COMMA,b.TILDE,b.DOUBLE_QUOTE,b.SINGLE_QUOTE].includes(i),dn=i=>/[0-9]/.test(i),gn=new Set([5760,8232,8233,8239,8287,12288,65279]),Q=(i,t=!1)=>{if(t)return i===" "||i==="	";const e=i.codePointAt(0)||0;return e<=32?!0:e<=255?e===160:e>65279?!1:e>=8192&&e<=8202?!0:gn.has(e)},mn=i=>![b.CURLY_OPEN,b.CURLY_CLOSE,b.BRACKET_OPEN,b.BRACKET_CLOSE,b.COLON,b.COMMA,b.HASH,b.DOUBLE_QUOTE,b.SINGLE_QUOTE,b.TILDE].includes(i),yn=i=>i===u.COLLECTION_START||i===u.SECTION_SEP||i===u.COMMA||i===u.COLON||i===u.BRACKET_OPEN||i===u.BRACKET_CLOSE||i===u.CURLY_OPEN||i===u.CURLY_CLOSE;var $;(function(i){i.NULL="null",i.N="N",i.TRUE="true",i.T="T",i.FALSE="false",i.F="F",i.Inf="Inf",i.PositiveInf="+Inf",i.NegativeInf="-Inf",i.NaN="NaN"})($||($={}));const M={hex4:/^[0-9a-fA-F]{4}$/,hex2:/^[0-9a-fA-F]{2}$/,floatDigit:/^[0-9.]+$/,intDigit:/^[0-9]+$/,hex:/^[0-9a-fA-F]+$/,octal:/^[0-7]+$/,binary:/^[01]+$/,sectionSchemaName:/^(?:(?:(?<name>[\p{L}\p{M}\p{N}\-_]+)(?<sep>[ \t]*:[ \t]*)?)(?<schema>\$[\p{L}\p{M}\p{N}\-_]+)?|(?<schema2>\$[\p{L}\p{M}\p{N}\-_]+))/u,annotatedStrStart:/^(?<name>[a-zA-Z]{1,4})(?<quote>['"])/,base64:/^[A-Za-z0-9+/]*={0,2}$/},E={NEWLINE:10,DOUBLE_QUOTE:34,SINGLE_QUOTE:39,HASH:35,PLUS:43,MINUS:45,DOT:46,ZERO:48,NINE:57,COLON:58,COMMA:44,CURLY_OPEN:123,CURLY_CLOSE:125,BRACKET_OPEN:91,BRACKET_CLOSE:93,TILDE:126},wn=i=>i>=E.ZERO&&i<=E.NINE,vn=new Set([5760,8232,8233,8239,8287,12288,65279]),En=i=>i<=32?!0:i<=255?i===160:i>65279?!1:i>=8192&&i<=8202?!0:vn.has(i),Sn=M.hex4,bn=M.hex2,Nn=M.floatDigit,pt=M.intDigit,Tn=M.hex,On=M.octal,xn=M.binary,_n=["x","X","o","O","b","B"],In=M.sectionSchemaName,Rn=_n,kn=M.annotatedStrStart;class $n{constructor(t){this.pos=0,this.input="",this.row=1,this.col=1,this.reachedEnd=!1,this.inputLength=0,this.input=t,this.inputLength=t.length}isSpecialSymbolFast(t){return t===E.CURLY_OPEN||t===E.CURLY_CLOSE||t===E.BRACKET_OPEN||t===E.BRACKET_CLOSE||t===E.COMMA||t===E.COLON||t===E.TILDE}getSymbolTokenTypeFast(t){switch(t){case E.CURLY_OPEN:return u.CURLY_OPEN;case E.CURLY_CLOSE:return u.CURLY_CLOSE;case E.BRACKET_OPEN:return u.BRACKET_OPEN;case E.BRACKET_CLOSE:return u.BRACKET_CLOSE;case E.COMMA:return u.COMMA;case E.COLON:return u.COLON;case E.TILDE:return u.COLLECTION_START;default:return u.UNKNOWN}}createErrorToken(t,e,n,s,r){return S.init(e,n,s,r,{__error:!0,message:t.message,originalError:t},u.ERROR)}skipToNextTokenBoundary(){for(;!this.reachedEnd&&!Q(this.input[this.pos])&&!Vt(this.input[this.pos])&&this.input[this.pos]!==","&&this.input[this.pos]!==`
`;)this.advance()}advance(t=1){if(!this.reachedEnd){if(t===1){this.input.charCodeAt(this.pos)===E.NEWLINE?(this.row++,this.col=1):this.col++,this.pos++,this.pos>=this.inputLength&&(this.reachedEnd=!0);return}for(let e=0;e<t;e++)if(this.input.charCodeAt(this.pos)===E.NEWLINE?(this.row++,this.col=1):this.col++,this.pos++,this.pos>=this.inputLength){this.reachedEnd=!0;break}}}parseSingleLineComment(){for(;!this.reachedEnd&&this.input[this.pos]!==`
`;)this.advance()}parseRegularString(t){const e=this.pos,n=this.row,s=this.col;this.advance();let r="",o=!1;for(;!this.reachedEnd&&this.input[this.pos]!==t;){if(Q(this.input[this.pos])){r+=this.skipWhitespaces();continue}if(this.input[this.pos]===b.BACKSLASH)try{({value:r,needToNormalize:o}=this.escapeString(r,o))}catch{if(!this.reachedEnd){const c=this.input[this.pos];if(r+=c,c==="u"){this.advance();for(let h=0;h<4&&!this.reachedEnd;h++)r+=this.input[this.pos],this.advance();continue}else if(c==="x"){this.advance();for(let h=0;h<2&&!this.reachedEnd;h++)r+=this.input[this.pos],this.advance();continue}else this.advance()}continue}else r+=this.input[this.pos],this.advance()}if(this.reachedEnd){const l=this.input.substring(e,this.pos),c=S.init(e,n,s,'"','"',"STRING"),h=Bt(this.pos,this.row,this.col),p=new m(f.stringNotClosed,`Unterminated string literal. Expected closing quote '"' before end of input.`,jt(c,h),!0);return this.createErrorToken(p,e,n,s,l)}this.advance();const a=this.input.substring(e,this.pos);return o&&(r=r.normalize("NFC")),S.init(e,n,s,a,r,"STRING","REGULAR_STRING")}escapeString(t,e){if(this.advance(),this.reachedEnd)throw new m(f.invalidEscapeSequence,"Invalid escape sequence at end of input. Expected escape character after backslash.",this.currentPosition,!0);switch(this.input[this.pos]){case"b":t+="\b";break;case"f":t+="\f";break;case"n":t+=`
`;break;case"r":t+="\r";break;case"t":t+="	";break;case"u":const n=this.input.substring(this.pos+1,this.pos+5);if(Sn.test(n))t+=String.fromCharCode(parseInt(n,16)),this.advance(4),e=!0;else throw new m(f.invalidEscapeSequence,`Invalid Unicode escape sequence '\\u${n}'. Expected 4 hexadecimal digits (0-9, A-F).`,this.currentPosition);break;case"x":const s=this.input.substring(this.pos+1,this.pos+3);if(bn.test(s))t+=String.fromCharCode(parseInt(s,16)),this.advance(2),e=!0;else throw new m(f.invalidEscapeSequence,`Invalid hexadecimal escape sequence '\\x${s}'. Expected 2 hexadecimal digits (0-9, A-F).`,this.currentPosition);break;default:t+=this.input[this.pos],this.advance();break}return{value:t,needToNormalize:e}}get currentPosition(){const t=()=>({pos:this.pos,row:this.row,col:this.col});return{getStartPos:t,getEndPos:t}}checkIfAnotatedString(){const t=kn.exec(this.input.substring(this.pos,this.pos+5));return t?t.groups:null}parseAnotatedString(t){const e=this.pos,n=this.row,s=this.col;for(let l=0;l<t.name.length;l++)this.advance();if(this.reachedEnd){const l=this.input.substring(e,this.pos),c=S.init(e,n,s,t.name+t.quote,t.name,"STRING"),h=Bt(this.pos,this.row,this.col),p=new m(f.stringNotClosed,`Unterminated annotated string literal. Expected closing quote '${t.quote}' before end of input.`,jt(c,h),!0);return this.createErrorToken(p,e,n,s,l)}for(this.advance();!this.reachedEnd&&this.input[this.pos]!==t.quote;)this.advance();const r=this.input.substring(e,this.pos);let o;if(this.reachedEnd)o=r.substring(t.name.length+1);else{this.advance();const l=this.input.substring(e,this.pos);o=l.substring(t.name.length+1,l.length-1)}const a=new S;return a.pos=e,a.row=n,a.col=s,a.token=this.reachedEnd?r:this.input.substring(e,this.pos),a.value=o,a}parseRawString(t){const e=this.parseAnotatedString(t);return e.type===u.ERROR||(e.type=u.STRING,e.subType="RAW_STRING"),e}parseByteString(t){const e=this.parseAnotatedString(t);if(e.type===u.ERROR)return e;try{if(!M.base64.test(e.value))throw new Error("Invalid base64 format");return e.type=u.BINARY,e.subType="BINARY_STRING",e.value=Buffer.from(e.value,"base64"),e}catch(n){return this.createErrorToken(n,e.pos,e.row,e.col,e.token)}}parseDateTime(t){const e=this.parseAnotatedString(t);if(e.type===u.ERROR)return e;try{let n=r=>null;switch(t.name){case"dt":n=De,e.subType=u.DATETIME;break;case"d":n=We,e.subType=u.DATE;break;case"t":n=Ye,e.subType=u.TIME;break;default:R(t)}const s=n(e.value);if(!s){const r=new m(f.invalidDateTime,`Invalid ${t.name==="dt"?"datetime":t.name==="d"?"date":"time"} format '${e.value}'. Expected valid ISO 8601 format.`,e);return this.createErrorToken(r,e.pos,e.row,e.col,e.token)}return e.value=s,e.type=u.DATETIME,e}catch(n){return this.createErrorToken(n,e.pos,e.row,e.col,e.token)}}parseNumber(){const t=this.pos,e=this.row,n=this.col;let s="",r=10,o=!1,a=!1,l="",c;if(this.input[this.pos]==="+"||this.input[this.pos]==="-"){const g=this.input[this.pos];if(this.input.startsWith("Inf",this.pos+1)){const T=g+"Inf";return this.advance(4),S.init(t,e,n,T,g==="+"?1/0:-1/0,u.NUMBER)}if(dn(this.input[this.pos+1])||this.input[this.pos+1]===".")s+=g,this.advance();else return null}else if(this.input.startsWith("Inf",this.pos))return this.advance(3),S.init(t,e,n,"Inf",1/0,u.NUMBER);if(this.input[this.pos]==="."&&!Nn.test(this.input[this.pos+1]))return null;if(this.input[this.pos]==="0"&&Rn.includes(this.input[this.pos+1]))switch(this.input[this.pos+1]){case"X":case"x":for(r=16,c="HEX",l=this.input[this.pos]+this.input[this.pos+1],this.advance(2);Tn.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance();break;case"O":case"o":for(r=8,c="OCTAL",l=this.input[this.pos]+this.input[this.pos+1],this.advance(2);On.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance();break;case"B":case"b":for(r=2,c="BINARY",l=this.input[this.pos]+this.input[this.pos+1],this.advance(2);xn.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance();break;default:R(this.input[this.pos+1])}else{for(;pt.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance();if(this.input[this.pos]===".")for(o=!0,s+=".",this.advance();pt.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance();if(this.input[this.pos]==="e"||this.input[this.pos]==="E")for(a=!0,s+=this.input[this.pos],this.advance(),(this.input[this.pos]==="+"||this.input[this.pos]==="-")&&(s+=this.input[this.pos],this.advance());pt.test(this.input[this.pos]);)s+=this.input[this.pos],this.advance()}let h=u.NUMBER,p;return this.input[this.pos]==="n"?(h=u.BIGINT,p=BigInt(l+s),s+="n",this.advance()):this.input[this.pos]==="m"?(h=u.DECIMAL,p=new v(s),s+="f",this.advance()):r===10&&(o||a)?p=parseFloat(s):(p=parseInt(s,r),isNaN(p)&&R("Expected a number but got NaN",this.currentPosition.getStartPos())),S.init(t,e,n,l+s,p,h,c)}parseLiteralOrOpenString(){const t=this.pos,e=this.row,n=this.col;let s="",r=!1;for(;!this.reachedEnd&&mn(this.input[this.pos]);){let o=this.input[this.pos];if(Q(o)){s+=this.skipWhitespaces();continue}if(o===b.MINUS&&this.input.substring(this.pos,this.pos+3)==="---")break;if(o===b.BACKSLASH)try{({value:s,needToNormalize:r}=this.escapeString(s,r));continue}catch{if(s+="\\",!this.reachedEnd){const l=this.input[this.pos];if(s+=l,l==="u"){this.advance();for(let c=0;c<4&&!this.reachedEnd;c++)s+=this.input[this.pos],this.advance();continue}else if(l==="x"){this.advance();for(let c=0;c<2&&!this.reachedEnd;c++)s+=this.input[this.pos],this.advance();continue}else this.advance()}continue}else s+=o,this.advance()}if(s=s.trimEnd(),r&&(s=s.normalize("NFC")),s==="")return null;switch(s){case $.TRUE:case $.T:return S.init(t,e,n,s,!0,u.BOOLEAN);case $.FALSE:case $.F:return S.init(t,e,n,s,!1,u.BOOLEAN);case $.NULL:case $.N:return S.init(t,e,n,s,null,u.NULL);case $.Inf:case $.NaN:return S.init(t,e,n,s,s===$.Inf?1/0:NaN,u.NUMBER);default:return S.init(t,e,n,s,s,u.STRING,"OPEN_STRING")}}mergeTokens(t,e){const n=new S;return n.pos=t.pos,n.row=t.row,n.col=t.col,n.token=t.token+e.token,n.value=t.token+e.value.toString(),n.type=e.type,n.subType=e.subType,n}skipWhitespaces(t=!1){const e=this.pos;for(;!this.reachedEnd&&Q(this.input[this.pos],t);)this.input[this.pos]==="\r"?(this.input[this.pos+1]===`
`&&this.advance(),this.advance()):this.advance();if(e===this.pos)return"";let n=this.input.substring(e,this.pos);return n.includes("\r")&&(n=n.replace(/\r\n/g,`
`).replace(/\r/g,`
`)),n}tokenize(){const t=Math.max(10,Math.floor(this.inputLength/8)),e=new Array(t);let n=0;for(;this.pos<this.inputLength;){const s=this.input.charCodeAt(this.pos);if(En(s)){this.advance();continue}else if(s===E.HASH)this.parseSingleLineComment();else if(s===E.DOUBLE_QUOTE||s===E.SINGLE_QUOTE)e[n++]=this.parseRegularString(this.input[this.pos]);else if(this.isSpecialSymbolFast(s)){const r=this.row,o=this.col,a=this.input[this.pos];e[n++]=S.init(this.pos,r,o,a,a,this.getSymbolTokenTypeFast(s)),this.advance()}else if(s===E.PLUS||s===E.MINUS||s===E.DOT||wn(s)){if(s===E.MINUS&&this.input.substring(this.pos,this.pos+3)==="---"){n=this.parseSectionSeparator(e,n);continue}const r=this.parseNumber();if(r){const o=this.skipWhitespaces();if(this.reachedEnd)e[n++]=r;else if(!Vt(this.input[this.pos])&&!Q(this.input[this.pos])){const a=this.parseLiteralOrOpenString();a?(a.type=u.STRING,a.subType="OPEN_STRING",o.length>0&&(a.token=o+a.token,a.value=o+a.value),e[n++]=this.mergeTokens(r,a)):e[n++]=r}else e[n++]=r}else{const o=this.parseLiteralOrOpenString();o&&(e[n++]=o)}}else{const r=this.checkIfAnotatedString();if(r)switch(r.name){case"r":e[n++]=this.parseRawString(r);break;case"b":e[n++]=this.parseByteString(r);break;case"d":case"dt":case"t":e[n++]=this.parseDateTime(r);break;default:const o=new m(f.unsupportedAnnotation,`Unsupported annotation '${r.name}'. Supported annotations are: 'r' (raw string), 'b' (binary), 'dt' (datetime), 'd' (date), 't' (time).`,this.currentPosition),a=this.input.substring(this.pos,this.pos+r.name.length+1);e[n++]=this.createErrorToken(o,this.pos,this.row,this.col,a),this.skipToNextTokenBoundary()}else{const o=this.parseLiteralOrOpenString();o&&(e[n++]=o)}}}return e.length=n,e}parseSectionSeparator(t,e){var s;t[e++]=S.init(this.pos,this.row,this.col,"---","---",u.SECTION_SEP),this.advance(3),this.skipWhitespaces(!0);const n=In.exec(this.input.substring(this.pos));if(n){let r,o,a=(s=n.groups)==null?void 0:s.sep,l;if(n.groups&&(r=n.groups.schema,o=n.groups.name,l=n.groups.schema2),l)t[e++]=S.init(this.pos,this.row,this.col,l,l,u.STRING,u.SECTION_SCHEMA),this.advance(l.length),this.skipWhitespaces(!0);else if(o&&(t[e++]=S.init(this.pos,this.row,this.col,o,o,u.STRING,u.SECTION_NAME),this.advance(o.length),this.skipWhitespaces(!0),a)){if(this.advance(a.length),this.skipWhitespaces(!0),!r){const c=new m(f.schemaMissing,"Missing schema definition after section separator. Expected schema name starting with '$' (e.g., '$mySchema').",this.currentPosition);return t[e++]=this.createErrorToken(c,this.pos,this.row,this.col,""),e}t[e++]=S.init(this.pos,this.row,this.col,r,r,u.STRING,u.SECTION_SCHEMA),this.advance(r.length),this.skipWhitespaces(!0)}}return e}}class Cn{constructor(t,e=[],n=[]){this.header=null,this.children=[],this.errors=[],this.header=t,this.children=e,this.errors=n}get firstChild(){return this.children.length>0?this.children[0]:null}getErrors(){return this.errors}toValue(t){var s;const e=((s=this.header)==null?void 0:s.toValue(t))??null,n=new bt;for(let r=0;r<this.children.length;r++)n.push(this.children[r].toValue(t));return new dt(e,n)}getStartPos(){return this.header?this.header.getStartPos():this.children.length>0?this.children[0].getStartPos():{row:0,col:0,pos:0}}getEndPos(){return this.children.length>0?this.children[this.children.length-1].getEndPos():this.header?this.header.getEndPos():{row:0,col:0,pos:0}}}class An{constructor(t,e,n){this.type="section",this.child=t,this.nameNode=e,this.schemaNode=n}get name(){var t,e;return((t=this.nameNode)==null?void 0:t.value)||((e=this.schemaNode)==null?void 0:e.value.toString().substring(1))||"unnamed"}get schemaName(){var t;return((t=this.schemaNode)==null?void 0:t.value)||"$schema"}get firstChild(){return this.child}get firstChildObject(){return this.child instanceof I?this.child:this.child instanceof ut&&this.child.children.length>0?this.child.children[0]:null}getStartPos(){var t;return((t=this.child)==null?void 0:t.getStartPos())??{row:0,col:0,pos:0}}getEndPos(){var t;return((t=this.child)==null?void 0:t.getEndPos())??{row:0,col:0,pos:0}}toValue(t){let e=null;return this.child&&(e=this.child.toValue(t)),new St(e,this.name,this.schemaName)}}class O{constructor(t){this.sectionNames={},this.errors=[],this.tokens=t,this.current=0}parse(){return this.processDocument()}createUnclosedConstructError(t,e,n,s){let r=null,o=this.current-1;for(;o>=0;){const a=this.tokens[o];if(a&&a.type!==u.COLLECTION_START&&a.type!==u.SECTION_SEP){r=a;break}o--}if(n&&r){const a=pn(n,r);return new m(t,e,a,!1)}else return n?new m(t,e,n,!1):new m(t,e,void 0,!0)}processDocument(){const t=new Array;let e=null,n=this.peek(),s=!0;for(;;){s&&(n==null?void 0:n.type)===u.SECTION_SEP&&(s=!1);const r=this.processSection(s);if(n=this.peek(),!n){t.push(r);break}if(s?e=r:t.push(r),s&&(s=!1),n.type!==u.SECTION_SEP){const o=new m(f.unexpectedToken,`Expected section separator '---' but found '${n.token}'. Each section must be properly closed before starting a new one.`,n);this.errors.push(o);break}this.advance()}return new Cn(e,t,this.errors)}processSection(t){var l;let e=this.peek();(e==null?void 0:e.type)===u.SECTION_SEP&&this.advance();const[n,s]=this.parseSectionAndSchemaNames();let r=(s==null?void 0:s.value)||(n==null?void 0:n.value.toString().substring(1))||"unnamed";const o=r;if(r&&this.sectionNames[r]){const c=new m(f.unexpectedToken,`Duplicate section name '${r}'. Each section must have a unique name within the document.`,void 0,!1);this.errors.push(c);let h=2;for(;this.sectionNames[`${o}_${h}`];)h++;r=`${o}_${h}`,s&&(s.value=r)}(!t||t&&r!=="unnamed"&&((l=this.peek())==null?void 0:l.type)!==u.SECTION_SEP)&&(this.sectionNames[r]=!0);const a=this.parseSectionContent();return new An(a,s,n)}parseSectionAndSchemaNames(){let t=null,e=null,n=this.peek();return(n==null?void 0:n.subType)===u.SECTION_NAME?(e=n,this.advance(),n=this.peek(),(n==null?void 0:n.subType)===u.SECTION_SCHEMA&&(t=n,this.advance())):(n==null?void 0:n.subType)===u.SECTION_SCHEMA&&(t=n,this.advance(),n=this.peek()),[t,e]}parseSectionContent(){const t=this.peek();return!t||t.type===u.SECTION_SEP?null:t.type===u.COLLECTION_START?this.processCollection():this.processObject(!1)}processCollection(){const t=[];for(;this.match(O.COLLECTION_START_ARRAY);){this.advance(),this.current;const e=this.peek();if(e&&e.type===u.ERROR){const n=e.value,s=new K(n.originalError,e);this.errors.push(n.originalError),t.push(s),this.advance(),this.skipToNextCollectionItem();continue}try{t.push(this.processObject(!0))}catch(n){this.errors.push(n);let s={pos:-1,row:-1,col:-1},r;if(n&&typeof n=="object"&&"positionRange"in n){const o=n.positionRange;o&&o.getStartPos&&(s=o.getStartPos(),r=o.getEndPos?o.getEndPos():void 0)}if(s.pos===-1&&this.current>0&&this.current<=this.tokens.length){const o=this.tokens[this.current-1];o&&(s=o.getEndPos(),r=s)}t.push(new K(n,s,r)),this.skipToNextCollectionItem()}}return new ut(t)}skipToNextCollectionItem(){for(;this.peek()&&!this.match(O.COLLECTION_OR_SECTION_ARRAY);)this.advance()}skipToNextSyncPoint(){for(;this.peek();){const t=this.peek();if(!t||yn(t.type))break;this.advance()}}processObject(t){const e=this.parseObject(!0),n=this.peek();if(this.checkForPendingTokens(n,t),e.children.length===1){const s=e.children[0];if(s&&!s.key&&s.value&&s.value instanceof I)return s.value}return e}checkForPendingTokens(t,e){if(t&&t.type!==u.SECTION_SEP&&!(e&&t.type===u.COLLECTION_START))throw new m(f.unexpectedToken,`Unexpected token '${t.value}'. Expected end of section or start of new collection item '~'.`,t,!1)}parseObject(t){const e=[];let n=this.peek();t&&(n=null),!t&&!this.advanceIfMatch(O.CURLY_OPEN_ARRAY)&&R("The caller must ensure that this function is called only when the next token is {");let s=0,r=!1,o=!0;for(;!r;){const a=this.peek();if(!a||this.match([u.CURLY_CLOSE,u.COLLECTION_START,u.SECTION_SEP])){if(o){const l=this.tokens[this.current-1];l&&l.type===u.COMMA&&this.pushUndefinedMember(e,l)}r=!0;break}else if(a.type===u.COMMA){o&&this.pushUndefinedMember(e,a),this.advance(),o=!0;continue}else{if(s>0&&!this.matchPrev([u.COMMA,u.CURLY_OPEN]))throw new m(f.unexpectedToken,`Missing comma before '${a.value}'. Object members must be separated by commas.`,a,!1);const l=this.parseMember();e.push(l),s++,o=!1}}if(t)return new I(e);{if(!this.match(O.CURLY_CLOSE_ARRAY))throw this.createUnclosedConstructError(f.expectingBracket,"Missing closing brace '}'. Object must be properly closed.",n,e);let a=this.peek();return this.advance(),new I(e,n,a)}}parseMember(){const t=this.peek();if(t||R("The caller must ensure that this function is called only when the member has at least one token"),this.matchNext(O.COLON_ARRAY))if(O.VALID_KEY_TYPES.includes(t.type)){this.advance(2);const n=this.parseValue();return new Y(n,t)}else throw new m(f.invalidKey,`Invalid key '${t.token}'. Object keys must be strings, numbers, booleans, or null.`,t,!1);return new Y(this.parseValue())}parseArray(){const t=[],e=this.peek();if(!e||e.type!==u.BRACKET_OPEN)throw new m(f.expectingBracket,`Expected opening bracket '[' to start array but found '${(e==null?void 0:e.token)||"end of input"}'.`,e===null?void 0:e,e===null);for(this.advance();;){const s=this.peek();if(!s)throw this.createUnclosedConstructError(f.expectingBracket,"Unexpected end of input while parsing array. Expected closing bracket ']'.",e,t);if(s.type===u.BRACKET_CLOSE)break;if(s.type===u.COLLECTION_START||s.type===u.SECTION_SEP)throw this.createUnclosedConstructError(f.expectingBracket,"Missing closing bracket ']'. Array must be properly closed.",e,t);if(s.type===u.COMMA){if(this.matchNext([u.COMMA,u.BRACKET_CLOSE])){const o=this.tokens[this.current+1];throw new m(f.unexpectedToken,"Unexpected comma. Array elements cannot be empty - remove the extra comma or add a value.",o,!1)}this.advance();continue}const r=this.parseMember();r.key?t.push(new I([r])):t.push(r.value)}if(!this.match(O.BRACKET_CLOSE_ARRAY))throw this.createUnclosedConstructError(f.expectingBracket,"Missing closing bracket ']'. Array must be properly closed.",e,t);const n=this.peek();return this.advance(),new et(t,e,n)}parseValue(){const t=this.peek();if(!t)throw new m(f.valueRequired,"Unexpected end of input. Expected a value (string, number, boolean, null, array, or object).",void 0,!0);switch(t.type){case u.STRING:case u.NUMBER:case u.BIGINT:case u.DECIMAL:case u.BOOLEAN:case u.NULL:case u.DATETIME:{const e=new w(t);return this.advance(),e}case u.BRACKET_OPEN:return this.parseArray();case u.CURLY_OPEN:return this.parseObject(!1);case u.ERROR:{const e=t.value,n=new K(e.originalError,t);return this.errors.push(e.originalError),this.advance(),this.skipToNextSyncPoint(),n}default:throw new m(f.unexpectedToken,`Unexpected token '${t.value}'. Expected a valid value (string, number, boolean, null, array, or object).`,t,t===null)}}pushUndefinedMember(t,e){const n=e.clone();n.type=u.UNDEFINED,n.value=void 0;const s=new Y(new w(n));t.push(s)}isValidToken(t){return t!==null}peek(){return this.current<this.tokens.length?this.tokens[this.current]:null}advance(t=1){this.current+=t}match(t){const e=this.peek();return!!(this.isValidToken(e)&&t.includes(e.type))}matchPrev(t){const e=this.tokens[this.current-1];return!!(this.isValidToken(e)&&t.includes(e.type))}matchNext(t){if(this.current+1>=this.tokens.length)return!1;const e=this.tokens[this.current+1];return!!(this.isValidToken(e)&&t.includes(e.type))}advanceIfMatch(t){return this.match(t)?(this.advance(),!0):!1}}O.CURLY_OPEN_ARRAY=[u.CURLY_OPEN];O.CURLY_CLOSE_ARRAY=[u.CURLY_CLOSE];O.BRACKET_OPEN_ARRAY=[u.BRACKET_OPEN];O.BRACKET_CLOSE_ARRAY=[u.BRACKET_CLOSE];O.COLLECTION_START_ARRAY=[u.COLLECTION_START];O.SECTION_SEP_ARRAY=[u.SECTION_SEP];O.COMMA_ARRAY=[u.COMMA];O.COLON_ARRAY=[u.COLON];O.COLLECTION_OR_SECTION_ARRAY=[u.COLLECTION_START,u.SECTION_SEP];O.VALID_KEY_TYPES=[u.STRING,u.NUMBER,u.BOOLEAN,u.NULL];function he(i,t,e={}){var c;const s=new $n(i).tokenize();if(s.length===0)return new dt(new $t,new bt);const o=new O(s).parse(),a=o.getErrors(),l=new dt(new $t,new bt,a);if(o.header){if(o.header.child){if(o.header.child instanceof I){const h=Rt("schema",o.header.child);h instanceof N?((c=l.header.definitions)==null||c.push("$schema",h,!0),l.header.schema=h):R(h)}else o.header.child instanceof ut?Ln(l,o.header.child):R(o.header.child);t&&l.header.definitions.merge(t,!1)}else t&&l.header.definitions.merge(t,!1);Ut(o,l)}else t&&l.header.definitions.merge(t,!1),Ut(o,l);return l}function Ut(i,t){var s,r,o,a;const e=i.children.length;if(e===0)return;const n=[];for(let l=0;l<e;l++){const c=i.children[l],h=c.schemaName,p=h?h==="$schema"?t.header.schema:(s=t.header.definitions)==null?void 0:s.getV(c.schemaNode):t.header.schema;if(!p){(o=t.sections)==null||o.push(new St((r=c.child)==null?void 0:r.toValue(t.header.definitions||void 0),c.name));continue}const g=Yt(c.child,p,t.header.definitions||void 0,n);(a=t.sections)==null||a.push(new St(g,c.name,h))}n.length>0&&t.addErrors(n)}function Ln(i,t){const e=i.header.definitions;if(!e)throw new Error("Document header definitions not initialized. This is an internal error - please report this issue.");const n=[];for(let s=0;s<t.children.length;s++){const r=t.children[s];if(!r)continue;if(r instanceof K)throw new C(f.invalidDefinition,`Invalid definition: ${r.error.message}`,r);r instanceof I||R("Invalid definition, must be object");const o=r;o.children[0]===null&&R("Invalid definition"),o.children.length;const a=o.children[0];if(!a.key)throw new C(f.invalidDefinition,"Invalid definition: missing key. Each definition must have a key (e.g., '$schema: {...}' or '@variable: value').",a.value);const l=a.key;if(l.type!==u.STRING)throw new Error("Invalid typedef definition: key must be a string.");let c=l.value;if(c.startsWith("$")){e.push(c,a.value,!0),n.push({key:c,schemaDef:a.value});continue}if(c.startsWith("@")){e.push(c,a.value,!1,!0);continue}let h=o.children[0].value;e.push(c,h.toValue(i.header.definitions||void 0))}for(let s=0;s<n.length;s++){const{key:r,schemaDef:o}=n[s],a=Rt(r,o,e);e.set(r,a)}}function Mn(i,t,e){return i=i.trim(),i?(i.endsWith("---")||(i+=`
---`),he(i,t,e).header.definitions):null}const rt={Warning:4,Error:8};function Pn(i){switch(i){case"syntax":return rt.Error;case"validation":return rt.Warning;case"runtime":return rt.Error;default:return rt.Error}}function fe(i,t){return`${i.startLine}:${i.startColumn}-${i.endLine}:${i.endColumn}:${t.substring(0,20)}`}function jn(i){return i&&i.type==="parse"&&typeof i.id=="string"}self.addEventListener("message",i=>{const t=i.data;if(!jn(t)){console.error("Invalid message received by parser worker:",t);return}try{const e=Bn(t.documentText,t.schemaText,t.skipErrors,t.minifiedOutput),n={type:"result",id:t.id,result:e};self.postMessage(n)}catch(e){const n={type:"error",id:t.id,error:(e==null?void 0:e.message)||String(e)};self.postMessage(n)}});function Bn(i,t,e,n){if(!t)return Ft(i,null,e,n);const s=pe(t,Mn,!0,e);return s.errorMessages.length>0?{...s,jsonText:"",error:!0}:Ft(i,s.defs,e,n)}function pe(i,t,e=!1,n=!1){try{const s=t(i,null);let r=[];s&&typeof s.getErrors=="function"&&(r=s.getErrors());const o=e?null:s.toJSON({skipErrors:n}),a=e?s:null;if(r.length>0){const l=e?"defs":"doc",c=r.map(h=>Wt(h,l)).filter(h=>h!==null);return{errorMessages:r.map(h=>Dt(h)),errorItems:c,defs:a,output:o,defsMarkers:e?r.flatMap(ot):[],docMarkers:e?[]:r.flatMap(ot)}}return{errorMessages:[],errorItems:[],defs:a,output:o,defsMarkers:[],docMarkers:[]}}catch(s){const o=Wt(s,e?"defs":"doc");return{errorMessages:[Dt(s)],errorItems:o?[o]:[],defs:null,output:null,defsMarkers:e?ot(s):[],docMarkers:e?[]:ot(s)}}}function Ft(i,t,e,n){const s=pe(i,l=>he(l,t),!1,e),r=s.errorMessages.length>0;let o="",a=!1;return s.output?(o=JSON.stringify(s.output,function(l,c){return typeof c=="bigint"?`io:big:${c.toString()}`:typeof c=="number"&&isNaN(c)?"io:number:NaN":c instanceof v?`io:decimal:${c.toString()}`:c===1/0?"io:number:Inf":c===-1/0?"io:number:-Inf":typeof c>"u"?"io:undefined":c},n?0:2),a=r):r&&(o="",a=!0),{errorMessages:s.errorMessages,errorItems:s.errorItems,docMarkers:s.docMarkers,defsMarkers:s.defsMarkers,jsonText:o,error:a}}function Dt(i){return i instanceof m?"SYNTAX_ERROR: "+((i==null?void 0:i.message)||String(i)):i instanceof y?"VALIDATION_ERROR: "+((i==null?void 0:i.message)||String(i)):"ERROR: "+((i==null?void 0:i.message)||String(i))}function de(i){return i instanceof m?"syntax":i instanceof y?"validation":"runtime"}function ge(i){var n,s;if(!(i instanceof C))return null;const t=(n=i.positionRange)==null?void 0:n.getStartPos(),e=(s=i.positionRange)==null?void 0:s.getEndPos();return!t||!e?null:{startLine:t.row,startColumn:t.col,endLine:e.row,endColumn:e.col}}function Wt(i,t){const e=ge(i);if(!e)return null;const n=de(i),s=(i==null?void 0:i.message)||String(i);return{id:fe(e,s),code:i.code,category:n,message:s,range:e,source:t}}function ot(i){if(!(i instanceof C))return[];const t=ge(i);if(!t)return[];const e=de(i),n=Pn(e),s=(i==null?void 0:i.message)||String(i);return[{message:s,severity:n,startLineNumber:t.startLine,startColumn:t.startColumn,endLineNumber:t.endLine,endColumn:t.endColumn,id:fe(t,s),category:e}]}
//# sourceMappingURL=parser.worker-D2jq1TOc.js.map
