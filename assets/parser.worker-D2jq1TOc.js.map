{"version":3,"file":"parser.worker-D2jq1TOc.js","sources":["../../io-js2/dist/esm/core/document.js","../../io-js2/dist/esm/errors/general-error-codes.js","../../io-js2/dist/esm/errors/tokenization-error-codes.js","../../io-js2/dist/esm/errors/parsing-error-codes.js","../../io-js2/dist/esm/errors/validation-error-codes.js","../../io-js2/dist/esm/errors/io-error-codes.js","../../io-js2/dist/esm/errors/io-error.js","../../io-js2/dist/esm/errors/io-validation-error.js","../../io-js2/dist/esm/parser/tokenizer/token-types.js","../../io-js2/dist/esm/parser/tokenizer/tokens.js","../../io-js2/dist/esm/parser/nodes/tokens.js","../../io-js2/dist/esm/schema/schema.js","../../io-js2/dist/esm/core/definitions.js","../../io-js2/dist/esm/core/header.js","../../io-js2/dist/esm/errors/asserts/asserts.js","../../io-js2/dist/esm/core/internet-object.js","../../io-js2/dist/esm/core/collection.js","../../io-js2/dist/esm/core/decimal-utils.js","../../io-js2/dist/esm/core/decimal.js","../../io-js2/dist/esm/core/section.js","../../io-js2/dist/esm/core/section-collection.js","../../io-js2/dist/esm/errors/io-syntax-error.js","../../io-js2/dist/esm/parser/nodes/containers.js","../../io-js2/dist/esm/parser/nodes/array.js","../../io-js2/dist/esm/parser/nodes/members.js","../../io-js2/dist/esm/parser/nodes/objects.js","../../io-js2/dist/esm/schema/typedef-registry.js","../../io-js2/dist/esm/schema/processing/member-processor.js","../../io-js2/dist/esm/schema/object-processor.js","../../io-js2/dist/esm/parser/nodes/error.js","../../io-js2/dist/esm/schema/utils/schema-resolver.js","../../io-js2/dist/esm/schema/processing/collection-processor.js","../../io-js2/dist/esm/parser/nodes/collections.js","../../io-js2/dist/esm/schema/utils/validation-utils.js","../../io-js2/dist/esm/schema/processor.js","../../io-js2/dist/esm/schema/types/common-type.js","../../io-js2/dist/esm/schema/types/any.js","../../io-js2/dist/esm/schema/types/array.js","../../io-js2/dist/esm/schema/types/boolean.js","../../io-js2/dist/esm/utils/datetime.js","../../io-js2/dist/esm/schema/types/datetime.js","../../io-js2/dist/esm/schema/types/common-number.js","../../io-js2/dist/esm/schema/types/bigint.js","../../io-js2/dist/esm/schema/types/decimal.js","../../io-js2/dist/esm/schema/types/number.js","../../io-js2/dist/esm/schema/types/object.js","../../io-js2/dist/esm/utils/strings.js","../../io-js2/dist/esm/schema/types/string.js","../../io-js2/dist/esm/schema/types/index.js","../../io-js2/dist/esm/schema/types/memberdef-factory.js","../../io-js2/dist/esm/schema/utils/additional-props-canonicalizer.js","../../io-js2/dist/esm/schema/utils/member-utils.js","../../io-js2/dist/esm/schema/compile-object.js","../../io-js2/dist/esm/errors/error-range-utils.js","../../io-js2/dist/esm/parser/tokenizer/symbols.js","../../io-js2/dist/esm/parser/tokenizer/is.js","../../io-js2/dist/esm/parser/tokenizer/literals.js","../../io-js2/dist/esm/parser/tokenizer/index.js","../../io-js2/dist/esm/parser/nodes/document.js","../../io-js2/dist/esm/parser/nodes/section.js","../../io-js2/dist/esm/parser/ast-parser.js","../../io-js2/dist/esm/parser/index.js","../../io-js2/dist/esm/parser/parse-defs.js","../src/types/errors.ts","../src/workers/parser.worker.ts"],"sourcesContent":["class IODocument {\n    constructor(header, sections, errors = []) {\n        this._errors = []; // Accumulated errors during parsing\n        this._header = header;\n        this._sections = sections;\n        this._errors = errors;\n    }\n    get header() {\n        return this._header;\n    }\n    get sections() {\n        return this._sections;\n    }\n    /**\n     * Returns all errors accumulated during parsing and validation.\n     * This enables IDEs and tools to show all diagnostics in one pass.\n     *\n     * @returns A defensive copy of the errors array to prevent external mutation\n     */\n    getErrors() {\n        return [...this._errors];\n    }\n    /**\n     * Adds validation errors to the document.\n     * This method is package-private and should only be called by the parser.\n     *\n     * @internal\n     * @param errors - Array of validation errors to append\n     */\n    addErrors(errors) {\n        if (errors.length > 0) {\n            this._errors.push(...errors);\n        }\n    }\n    /**\n     * Converts the data sections into a JavaScript object.\n     * @param options Optional configuration for JSON conversion\n     * @param options.skipErrors If true, excludes error objects from collections (default: false)\n     */\n    toJSON(options) {\n        const sectionsLen = this._sections?.length || 0;\n        let data = null;\n        if (sectionsLen === 1) {\n            const section = this._sections?.get(0);\n            data = section.toJSON(options);\n        }\n        else if (sectionsLen > 1) {\n            data = {};\n            for (let i = 0; i < sectionsLen; i++) {\n                const section = this._sections?.get(i);\n                data[section.name] = section.toJSON(options);\n            }\n        }\n        // Only return header+data if header has non-empty definitions\n        const headerObject = this.header.toJSON();\n        if (headerObject && Object.keys(headerObject).length > 0) {\n            return {\n                header: headerObject,\n                data,\n            };\n        }\n        return data;\n    }\n    /**\n     * Alias for toJSON() method for backward compatibility\n     * @param options Optional configuration for JSON conversion\n     */\n    toObject(options) {\n        return this.toJSON(options);\n    }\n}\nexport default IODocument;\n","/**\n * General error codes that apply across different phases\n */\nvar GeneralErrorCodes;\n(function (GeneralErrorCodes) {\n    GeneralErrorCodes[\"invalidType\"] = \"invalid-type\";\n    GeneralErrorCodes[\"invalidValue\"] = \"invalid-value\";\n    GeneralErrorCodes[\"valueRequired\"] = \"value-required\";\n    GeneralErrorCodes[\"nullNotAllowed\"] = \"null-not-allowed\";\n})(GeneralErrorCodes || (GeneralErrorCodes = {}));\nexport default GeneralErrorCodes;\n","/**\n * Error codes specific to tokenization phase\n */\nvar TokenizationErrorCodes;\n(function (TokenizationErrorCodes) {\n    // String tokenization\n    TokenizationErrorCodes[\"stringNotClosed\"] = \"string-not-closed\";\n    TokenizationErrorCodes[\"invalidEscapeSequence\"] = \"invalid-escape-sequence\";\n    TokenizationErrorCodes[\"unsupportedAnnotation\"] = \"unsupported-annotation\";\n    // DateTime tokenization\n    TokenizationErrorCodes[\"invalidDateTime\"] = \"invalid-datetime\";\n})(TokenizationErrorCodes || (TokenizationErrorCodes = {}));\nexport default TokenizationErrorCodes;\n","/**\n * Error codes specific to parsing phase (AST construction)\n */\nvar ParsingErrorCodes;\n(function (ParsingErrorCodes) {\n    // General parsing\n    ParsingErrorCodes[\"unexpectedToken\"] = \"unexpected-token\";\n    ParsingErrorCodes[\"expectingBracket\"] = \"expecting-bracket\";\n    ParsingErrorCodes[\"unexpectedPositionalMember\"] = \"unexpected-positional-member\";\n    ParsingErrorCodes[\"invalidKey\"] = \"invalid-key\";\n    // Schema parsing\n    ParsingErrorCodes[\"invalidSchema\"] = \"invalid-schema\";\n    ParsingErrorCodes[\"schemaNotFound\"] = \"schema-not-found\";\n    ParsingErrorCodes[\"schemaMissing\"] = \"schema-missing\";\n    ParsingErrorCodes[\"emptyMemberDef\"] = \"empty-memberdef\";\n    ParsingErrorCodes[\"invalidDefinition\"] = \"invalid-definition\";\n    ParsingErrorCodes[\"invalidMemberDef\"] = \"invalid-memberdef\";\n    ParsingErrorCodes[\"invalidSchemaName\"] = \"invalid-schema-name\";\n    // Variables and definitions\n    ParsingErrorCodes[\"variableNotDefined\"] = \"variable-not-defined\";\n    ParsingErrorCodes[\"schemaNotDefined\"] = \"schema-not-defined\";\n})(ParsingErrorCodes || (ParsingErrorCodes = {}));\nexport default ParsingErrorCodes;\n","/**\n * Error codes specific to validation phase (schema validation)\n */\nvar ValidationErrorCodes;\n(function (ValidationErrorCodes) {\n    // Object validation\n    ValidationErrorCodes[\"invalidObject\"] = \"invalid-object\";\n    ValidationErrorCodes[\"unknownMember\"] = \"unknown-member\";\n    ValidationErrorCodes[\"duplicateMember\"] = \"duplicate-member\";\n    ValidationErrorCodes[\"additionalValuesNotAllowed\"] = \"additional-values-not-allowed\";\n    // Array validation\n    ValidationErrorCodes[\"invalidArray\"] = \"invalid-array\";\n    ValidationErrorCodes[\"notAnArray\"] = \"not-an-array\";\n    // String validation\n    ValidationErrorCodes[\"notAString\"] = \"not-a-string\";\n    ValidationErrorCodes[\"invalidEmail\"] = \"invalid-email\";\n    ValidationErrorCodes[\"invalidUrl\"] = \"invalid-url\";\n    ValidationErrorCodes[\"invalidLength\"] = \"invalid-length\";\n    ValidationErrorCodes[\"invalidMinLength\"] = \"invalid-min-length\";\n    ValidationErrorCodes[\"invalidMaxLength\"] = \"invalid-max-length\";\n    ValidationErrorCodes[\"invalidPattern\"] = \"invalid-pattern\";\n    // Number validation\n    ValidationErrorCodes[\"unsupportedNumberType\"] = \"unsupported-number-type\";\n    ValidationErrorCodes[\"notANumber\"] = \"not-a-number\";\n    ValidationErrorCodes[\"notAnInteger\"] = \"not-an-integer\";\n    ValidationErrorCodes[\"outOfRange\"] = \"out-of-range\";\n    ValidationErrorCodes[\"invalidRange\"] = \"invalid-range\";\n    ValidationErrorCodes[\"invalidScale\"] = \"invalid-scale\";\n    ValidationErrorCodes[\"invalidPrecision\"] = \"invalid-precision\";\n    // Boolean validation\n    ValidationErrorCodes[\"notABool\"] = \"not-a-bool\";\n    // Choice validation\n    ValidationErrorCodes[\"invalidChoice\"] = \"invalid-choice\";\n})(ValidationErrorCodes || (ValidationErrorCodes = {}));\nexport default ValidationErrorCodes;\n","import GeneralErrorCodes from './general-error-codes';\nimport TokenizationErrorCodes from './tokenization-error-codes';\nimport ParsingErrorCodes from './parsing-error-codes';\nimport ValidationErrorCodes from './validation-error-codes';\n/**\n * Consolidated error codes from all categories\n */\nconst ErrorCodes = {\n    ...GeneralErrorCodes,\n    ...TokenizationErrorCodes,\n    ...ParsingErrorCodes,\n    ...ValidationErrorCodes\n};\n// Export individual categories for specific use cases\nexport { GeneralErrorCodes, TokenizationErrorCodes, ParsingErrorCodes, ValidationErrorCodes };\nexport default ErrorCodes;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _IOError_positionRange;\n/**\n * Represents the base error class in InternetObject.\n */\nclass IOError extends Error {\n    get positionRange() { return __classPrivateFieldGet(this, _IOError_positionRange, \"f\"); }\n    set positionRange(value) {\n        __classPrivateFieldSet(this, _IOError_positionRange, value, \"f\");\n        this.updateMessage();\n    }\n    /**\n     * Backward-compat: some tests and callers expect `code` instead of `errorCode`.\n     */\n    get code() { return this.errorCode; }\n    /**\n     * Backward-compat: expose `position` alias for `positionRange` used by older tests.\n     */\n    get position() { return __classPrivateFieldGet(this, _IOError_positionRange, \"f\"); }\n    /**\n     * Initialize the new instance of `IOError`.\n     *\n     * @param errorCode {string} An error-code associated with this error\n     * @param fact {string} The  reason for the error\n     * @param pos {Position} The position object, for tracking line and columns. Optional\n     * @param isEof {boolean} Indicates whether the error is caused by EOF. Optional\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     */\n    constructor(errorCode, fact, positionRange, isEof = false, ssf) {\n        super();\n        /**\n         * A position object, for tracking line and columns.\n         */\n        _IOError_positionRange.set(this, void 0);\n        this.errorCode = errorCode;\n        this.fact = fact;\n        __classPrivateFieldSet(this, _IOError_positionRange, positionRange, \"f\");\n        this.isEof = isEof;\n        this.name = 'IOError';\n        // Format the error message\n        this.updateMessage();\n        // TODO: After stability, change the SSF class\n        // Error.captureStackTrace(this, IOError)\n        // Error.captureStackTrace(this, ssf || InternetObject)\n        this.__proto__ = new.target.prototype;\n    }\n    updateMessage() {\n        let errorMsg = `\"${this.errorCode}\" `;\n        if (this.fact) {\n            errorMsg += `\"${this.fact}\" `;\n        }\n        if (this.isEof) {\n            errorMsg += `at EOF`;\n        }\n        else if (__classPrivateFieldGet(this, _IOError_positionRange, \"f\")) {\n            // Handle both PositionRange (with getStartPos) and plain Position-like objects\n            const pr = __classPrivateFieldGet(this, _IOError_positionRange, \"f\");\n            if (typeof pr.getStartPos === 'function') {\n                const startPos = pr.getStartPos();\n                errorMsg += `at ${startPos.row}:${startPos.col}`;\n            }\n            else if (typeof pr.row === 'number' && typeof pr.col === 'number') {\n                errorMsg += `at ${pr.row}:${pr.col}`;\n            }\n        }\n        this.message = errorMsg;\n    }\n}\n_IOError_positionRange = new WeakMap();\nexport default IOError;\n","import InternetObjectError from \"./io-error\";\n/**\n * Represents the validation error in InternetObject. This error is thrown when a validation\n * issue is found while validating the internet-object data against the associated schema.\n */\nclass IOValidationError extends InternetObjectError {\n    /**\n     * Creates a new `IOValidationError` error.\n     *\n     * @param errorCode {string} An error-code associated with this error\n     * @param fact {string} The  reason for the error\n     * @param pos {Position} The position object, for tracking line and columns. Optional\n     * @param isEof {boolean} Indicates whether the error is caused by EOF. Optional\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     * @internal\n     */\n    constructor(errorCode, fact, posRange, isEof = false, ssf) {\n        super(errorCode, fact, posRange, isEof, ssf);\n        this.name = 'InternetObject(ValidationError)';\n    }\n}\nexport default IOValidationError;\n","/**\n* Enumeration representing types of tokens.\n*/\nvar TokenType;\n(function (TokenType) {\n    TokenType[\"CURLY_OPEN\"] = \"CURLEY_OPEN\";\n    TokenType[\"CURLY_CLOSE\"] = \"CURLY_CLOSE\";\n    TokenType[\"BRACKET_OPEN\"] = \"BRACKET_OPEN\";\n    TokenType[\"BRACKET_CLOSE\"] = \"BRACKET_CLOSE\";\n    TokenType[\"COLON\"] = \"COLON\";\n    TokenType[\"COMMA\"] = \"COMMA\";\n    TokenType[\"STRING\"] = \"STRING\";\n    TokenType[\"BINARY\"] = \"BINARY\";\n    TokenType[\"NUMBER\"] = \"NUMBER\";\n    TokenType[\"BIGINT\"] = \"BIGINT\";\n    TokenType[\"DECIMAL\"] = \"DECIMAL\";\n    TokenType[\"BOOLEAN\"] = \"BOOLEAN\";\n    TokenType[\"NULL\"] = \"NULL\";\n    TokenType[\"UNDEFINED\"] = \"UNDEFINED\";\n    TokenType[\"DATETIME\"] = \"DATETIME\";\n    TokenType[\"DATE\"] = \"DATE\";\n    TokenType[\"TIME\"] = \"TIME\";\n    TokenType[\"WHITESPACE\"] = \"WHITESPACE\";\n    TokenType[\"SECTION_SEP\"] = \"SECTION_SEP\";\n    TokenType[\"SECTION_SCHEMA\"] = \"SECTION_SCHEMA\";\n    TokenType[\"SECTION_NAME\"] = \"SECTION_NAME\";\n    TokenType[\"COLLECTION_START\"] = \"COLLECTION_START\";\n    TokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n    TokenType[\"ERROR\"] = \"ERROR\";\n})(TokenType || (TokenType = {}));\nexport default TokenType;\n","/**\n* Represents a parsed token.\n*/\nclass Token {\n    constructor() {\n        this.pos = -1;\n        this.row = -1;\n        this.col = -1;\n        this.token = '';\n        this.value = undefined;\n        this.type = '';\n        this.subType = '';\n    }\n    /**\n     * Create a token.\n     * @param pos - The starting position of the token in the input.\n     * @param row - The row number of the token's starting position.\n     * @param col - The column number of the token's starting position.\n     * @param token - The raw text of the token from the input.\n     * @param value - The parsed value of the token.\n     * @param type - A descriptive type name for the token.\n     * @param subType - Optional subtype for the token.\n     */\n    static init(pos, row, col, token, value, type, subType) {\n        const t = new Token();\n        t.pos = pos;\n        t.row = row;\n        t.col = col;\n        t.token = token;\n        t.value = value;\n        t.type = type;\n        if (subType) {\n            t.subType = subType;\n        }\n        return t;\n    }\n    clone() {\n        const t = new Token();\n        t.pos = this.pos;\n        t.row = this.row;\n        t.col = this.col;\n        t.token = this.token;\n        t.value = this.value;\n        t.type = this.type;\n        t.subType = this.subType;\n        return t;\n    }\n    getStartPos() {\n        return { row: this.row, col: this.col, pos: this.pos };\n    }\n    /**\n     * Returns the ending position (row, col, pos) of the token.\n     * Useful for debugging and generating error messages.\n     */\n    getEndPos() {\n        const text = this.token.trimEnd();\n        const lines = text.split('\\n');\n        const lastLine = lines[lines.length - 1];\n        const row = this.row + lines.length - 1;\n        const col = lines.length > 1 ? lastLine.length : this.col + lastLine.length;\n        const pos = this.pos + text.length;\n        return { row, col, pos };\n    }\n}\nexport default Token;\n","import TokenType from '../tokenizer/token-types';\nimport Token from '../tokenizer/tokens';\n/**\n * Represents a token node. It represents the leaf nodes in the AST.\n */\nclass TokenNode extends Token {\n    constructor(token) {\n        super();\n        Object.assign(this, token);\n    }\n    /**\n     * Returns the parsed value from the token.\n     * @param defs If the token is of type string, then check if it is a reference\n     *             and return the value from the definitions.\n     * @returns The parsed value.\n     */\n    toValue(defs) {\n        if ((this.type === 'string' || this.type === TokenType.STRING) && defs !== undefined) {\n            const valueFound = defs.getV(this.value);\n            return valueFound === undefined ? this.value : valueFound;\n        }\n        return this.value;\n    }\n}\nexport default TokenNode;\n","export default class Schema {\n    /**\n     * Creates a new instance of Internet Object Schema.\n     * Backward-compatible with legacy constructor usage that passes member objects.\n     * @param name The name of the schema\n     * @param o Optional member definition objects (legacy)\n     */\n    constructor(name, ...o) {\n        /** The names of the members (properties) in the schema */\n        this.names = [];\n        /** The definitions of the members (properties) in the schema */\n        this.defs = {};\n        /**\n         * Controls additional properties (dynamic fields) in the object.\n         * - false: No additional properties allowed\n         * - true: Any additional property allowed (no constraints)\n         * - MemberDef: Additional properties must match the given type/constraints\n         *   (e.g., string, array, object, or with constraints like {string, minLen: 10})\n         *\n         * If the schema uses *: type, *: {}, or *: [string], then open is set to the corresponding MemberDef.\n         * If the schema uses just *, then open is true.\n         * If no * is present, open is false.\n         */\n        this.open = false;\n        this.name = name;\n        // Legacy varargs support: new Schema('Name', { field: def }, { field2: def })\n        if (o && o.length > 0) {\n            o.forEach((item) => {\n                const key = Object.keys(item)[0];\n                const value = item[key];\n                if (value.path === undefined)\n                    value.path = key;\n                this.names.push(key);\n                this.defs[key] = value;\n            });\n        }\n    }\n    /** Returns the member definition of the given member name. */\n    get(name) {\n        return this.defs[name];\n    }\n    /** Checks if a member exists by name. */\n    has(name) {\n        return this.defs[name] !== undefined;\n    }\n    /** Returns the number of members in the schema. */\n    get memberCount() {\n        return this.names.length;\n    }\n    /** Builder entry for new, immutable-style construction while keeping runtime mutability */\n    static create(name) {\n        return new SchemaBuilder(name);\n    }\n    /** Legacy helper for creating from varargs member objects */\n    static fromLegacy(name, ...memberObjects) {\n        return new Schema(name, ...memberObjects);\n    }\n}\nexport class SchemaBuilder {\n    constructor(name) {\n        this.name = name;\n        this.names = [];\n        this.defs = {};\n        this.isOpen = false;\n    }\n    addMember(name, def) {\n        if (this.defs[name]) {\n            throw new Error(`Member '${name}' already exists in schema '${this.name}'`);\n        }\n        this.names.push(name);\n        this.defs[name] = { ...def, path: def.path || name };\n        return this;\n    }\n    setOpen(open) {\n        this.isOpen = open;\n        return this;\n    }\n    build() {\n        const schema = new Schema(this.name);\n        // Populate mutable structure to keep backward compatibility\n        for (const n of this.names) {\n            schema.names.push(n);\n            schema.defs[n] = this.defs[n];\n        }\n        schema.open = this.isOpen;\n        // Freeze names and defs for immutability\n        Object.freeze(schema.names);\n        Object.freeze(schema.defs);\n        return schema;\n    }\n}\n","import ErrorCodes from '../errors/io-error-codes';\nimport ValidationError from '../errors/io-validation-error';\nimport TokenNode from '../parser/nodes/tokens';\nimport TokenType from '../parser/tokenizer/token-types';\nimport Schema from '../schema/schema';\n/**\n * IODefinitions manages definitions (schemas, variables, and regular definitions) for Internet Object.\n *\n * Definitions are accessed by key, but the order in which they are defined is important:\n * - Variables and schema references defined earlier can be used in later definitions, but not vice versa.\n * - This follows the Internet Object specification (see 'the-definitions').\n *\n * The class provides key-based access, mutation, and iteration facilities, while ensuring definition order is respected for reference resolution.\n */\nclass IODefinitions {\n    constructor() {\n        /**\n         * The default schema, if defined. Reset when $schema is deleted or updated.\n         */\n        this._defaultSchema = null;\n        /**\n         * Internal storage for definitions. Order is preserved as per insertion sequence.\n         */\n        this._definitions = {};\n    }\n    /**\n     * Returns the number of definitions in the collection.\n     * @returns Number of definitions.\n     */\n    get length() {\n        return Object.keys(this._definitions).length;\n    }\n    /**\n     * Returns an array of definition keys, in insertion order.\n     * @returns Array of keys.\n     */\n    get keys() {\n        return Object.keys(this._definitions);\n    }\n    /**\n     * Returns the key-value pair at the specified index, preserving definition order.\n     * @param index Index of the definition.\n     * @returns Object with key and value.\n     */\n    at(index) {\n        const key = this.keys[index];\n        return { key, value: this._definitions[key] };\n    }\n    /**\n     * Returns the default schema, if defined.\n     * @returns The default Schema instance or null.\n     */\n    get defaultSchema() {\n        return this._defaultSchema || this._definitions[\"$schema\"]?.value || null;\n    }\n    /**\n     * Checks if there are any definitions beyond just the default $schema.\n     * Used to determine serialization format:\n     * - false: Output bare schema line (schema-only mode)\n     * - true: Output ~ definitions format (has variables, metadata, or multiple schemas)\n     * @returns True if there are any definitions other than a single $schema, false otherwise\n     */\n    get defaultSchemaOnly() {\n        const keys = Object.keys(this._definitions);\n        return keys.length === 1 && keys[0] === \"$schema\";\n    }\n    /**\n     * Gets a definition value by key, regardless of whether it's a variable, schema, or regular definition.\n     * @param key The definition key\n     * @returns The value associated with the key, or undefined if not found\n     */\n    get(key) {\n        return this._definitions[key]?.value;\n    }\n    /**\n     * Gets the variable value. This function is intended to be used internally\n     * for quickly fetching the variable value, hence it accepts any key to keep the\n     * consumer code free from type checking. The function validates the key and\n     * returns the associated value, if available. Otherwise returns undefined.\n     * @param key {any} The variable key starting with $\n     * @returns The value associated with the variable\n     */\n    getV(k) {\n        let key = \"\";\n        // Check if k is a TokenNode (can have lowercase 'string' or uppercase 'STRING' type)\n        if ((k || {}).type === TokenType.STRING || (k || {}).type === 'string') {\n            key = k.value;\n        }\n        else if (typeof k === 'string') {\n            key = k;\n        }\n        else {\n            return;\n        }\n        const def = this._definitions[key];\n        if (!def) {\n            // Only throw errors for variables and schemas\n            if (key.startsWith(\"$\") || key.startsWith(\"@\")) {\n                const positionParam = (typeof k === 'string') ? undefined : k;\n                if (key.startsWith(\"$\")) {\n                    throw new ValidationError(ErrorCodes.schemaNotDefined, `Schema ${key} is not defined.`, positionParam);\n                }\n                throw new ValidationError(ErrorCodes.variableNotDefined, `Variable ${key} is not defined.`, positionParam);\n            }\n            return undefined;\n        }\n        if (def.isVariable) {\n            return def.value;\n        }\n        // Check nested references. If yes, then resolve them and set in the\n        // place of the variable.\n        if (def.value instanceof TokenNode) {\n            const schema = this.getV(def.value);\n            if (schema instanceof Schema) {\n                this.set(key, schema);\n                return schema;\n            }\n        }\n        return def.value;\n    }\n    set(k, v) {\n        const dv = {\n            isSchema: k.startsWith(\"$\"),\n            isVariable: k.startsWith(\"@\"),\n            value: v\n        };\n        this._definitions[k] = dv;\n        this._defaultSchema = null;\n    }\n    /**\n     * Removes a definition by key.\n     * @param key The key of the definition to remove\n     * @returns True if the key existed and was deleted, false otherwise\n     */\n    delete(key) {\n        if (key in this._definitions) {\n            delete this._definitions[key];\n            // If the deleted key was $schema, reset _defaultSchema\n            if (key === \"$schema\") {\n                this._defaultSchema = null;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Pushes a new definition to the definitions list.\n     * @param key The key of the definition\n     * @param value The value of the definition\n     */\n    push(key, value, isSchema = false, isVariable = false) {\n        this._definitions[key] = { isSchema, isVariable, value };\n        if (key === \"$schema\") {\n            this._defaultSchema = value;\n        }\n    }\n    /**\n     * Merges the definitions with the other definitions.\n     * @param other     The other definitions to merge with\n     * @param override  If true, the other definitions will override the current\n     *                  definitions\n     */\n    merge(other, override = false) {\n        for (let i = 0; i < other.length; i++) {\n            const { key, value } = other.at(i);\n            if (override || !this._definitions[key]) {\n                this.push(key, value.value, value.isSchema, value.isVariable);\n            }\n        }\n    }\n    toJSON() {\n        const obj = {};\n        let keysCount = 0;\n        for (let i = 0; i < this.length; i++) {\n            const def = this.at(i);\n            // Skip schema and variable definitions\n            if (def.value.isSchema || def.value.isVariable) {\n                continue;\n            }\n            keysCount++;\n            obj[def.key] = def.value.value?.toObject ? def.value.value.toObject() : def.value.value;\n        }\n        if (keysCount) {\n            return obj;\n        }\n        return null;\n    }\n    /**\n     * Returns an iterator of definition keys.\n     */\n    /**\n     * Returns an iterator of definition keys (useful for for...of).\n     */\n    *keyIterator() {\n        for (const key of Object.keys(this._definitions)) {\n            yield key;\n        }\n    }\n    /**\n     * Returns an iterator of [key, value] pairs.\n     */\n    *entries() {\n        for (const key of this.keyIterator()) {\n            yield [key, this._definitions[key]];\n        }\n    }\n    /**\n     * Default iterator for [key, value] pairs.\n     */\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n}\nexport default IODefinitions;\n","import IODefinitions from './definitions';\nclass IOHeader {\n    constructor() {\n        this._schema = null;\n        this._definitions = new IODefinitions();\n    }\n    get schema() {\n        return this._schema || this._definitions.defaultSchema;\n    }\n    set schema(value) {\n        this._schema = value;\n    }\n    get definitions() {\n        return this._definitions;\n    }\n    merge(other, override = false) {\n        if (override && other.schema) {\n            this._schema = other.schema;\n        }\n        if (other.definitions) {\n            this._definitions.merge(other.definitions, override);\n        }\n    }\n    toJSON() {\n        return this._definitions.toJSON();\n    }\n}\nexport default IOHeader;\n","/**\n * Place this function to check and ensure the code where invoked must never\n * reach. This function is ueful to identify issues with the code by identifying\n * the code path which must have never reached.\n * @param x The object which needs to be asserted as never\n */\nfunction assertNever(x, pos) {\n    let message = \"Assert never\";\n    if (x !== undefined && x !== null) {\n        message = `Assert never: ${x.toString()}`;\n    }\n    if (pos) {\n        message += ` at ${pos.toString()}`;\n    }\n    throw new Error(message);\n}\nexport default assertNever;\n","class IOObject {\n    constructor(o) {\n        // Initialize private properties as non-enumerable to prevent conflicts with user keys\n        Object.defineProperty(this, 'items', {\n            value: [],\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        Object.defineProperty(this, 'keyMap', {\n            value: new Map(),\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        if (o) {\n            for (const [key, value] of Object.entries(o)) {\n                this.set(key, value);\n            }\n        }\n    }\n    /**\n     * Adds or updates a key-value pair in the IOObject.\n     * If the key exists, updates the value at its index.\n     * @param key The key to add or update.\n     * @param value The value associated with the key.\n     * @returns The IOObject instance.\n     */\n    set(key, value) {\n        if (this.keyMap.has(key)) {\n            const index = this.keyMap.get(key);\n            this.items[index] = [key, value];\n        }\n        else {\n            const index = this.items.length;\n            this.items.push([key, value]);\n            this.keyMap.set(key, index);\n        }\n        // Synchronize instance property (but skip if it's a reserved internal property)\n        if (key !== 'items' && key !== 'keyMap') {\n            Object.defineProperty(this, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        return this;\n    }\n    /**\n     * Appends values to the IOObject.\n     * Values can be with or without keys.\n     * @param items Variadic arguments of values or [key, value] pairs.\n     */\n    push(...items) {\n        for (const item of items) {\n            if (Array.isArray(item)) {\n                const [key, value] = item;\n                if (this.has(key)) {\n                    throw new Error(`Key '${key}' already exists`);\n                }\n                const index = this.items.length;\n                this.items.push([key, value]);\n                this.keyMap.set(key, index);\n            }\n            else {\n                this.items.push([undefined, item]);\n            }\n        }\n    }\n    /**\n     * Retrieves the value associated with the given key.\n     * @param key The key to look up.\n     * @returns The value if found, otherwise undefined.\n     */\n    get(key) {\n        const index = this.keyMap.get(key);\n        if (index !== undefined) {\n            const entry = this.items[index];\n            return entry ? entry[1] : undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Retrieves the value at the specified index.\n     * @param index The index to access.\n     * @returns The value if index is valid and entry exists, otherwise undefined.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            return undefined;\n        }\n        const entry = this.items[index];\n        return entry ? entry[1] : undefined;\n    }\n    /**\n     * Retrieves the key at the specified index.\n     * @param index The index to access.\n     * @returns The key if index is valid and exists, otherwise undefined.\n     */\n    keyAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            return undefined;\n        }\n        const entry = this.items[index];\n        return entry ? entry[0] : undefined;\n    }\n    /**\n     * Checks if the IOObject contains a given key.\n     * @param key The key to check.\n     * @returns True if the key exists, otherwise false.\n     */\n    has(key) {\n        return this.keyMap.has(key);\n    }\n    /**\n     * Deletes a key-value pair from the IOObject by key.\n     * @param key The key to delete.\n     * @returns True if the key was found and deleted, otherwise false.\n     */\n    delete(key) {\n        const index = this.keyMap.get(key);\n        if (index !== undefined && this.items[index]) {\n            this.items[index] = undefined;\n            this.keyMap.delete(key);\n            // Remove instance property\n            delete this[key];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Deletes a value at a specific index.\n     * Throws an error if the index is out of range.\n     * @param index The index to delete.\n     * @returns True if the value was deleted, otherwise false.\n     * @throws Error if the index is invalid.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.items.length) {\n            throw new Error('Index out of range');\n        }\n        const entry = this.items[index];\n        if (entry) {\n            const key = entry[0];\n            if (key !== undefined) {\n                this.keyMap.delete(key);\n            }\n            this.items[index] = undefined;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Updates the value at the specified index.\n     * Throws an error if the index is out of range.\n     * @param index The index to set.\n     * @param value The value to set.\n     * @returns True if the value was updated, otherwise false.\n     * @throws Error if the index is invalid.\n     */\n    setAt(index, value) {\n        if (index < 0 || index >= this.items.length) {\n            throw new Error('Index out of range');\n        }\n        const entry = this.items[index];\n        if (entry) {\n            this.items[index] = [entry[0], value];\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the index of the given key.\n     * @param key The key to find.\n     * @returns The index if found, otherwise -1.\n     */\n    indexOfKey(key) {\n        return this.keyMap.get(key) ?? -1;\n    }\n    /**\n     * Returns the index of the given value.\n     * @param value The value to find.\n     * @returns The index if found, otherwise -1.\n     */\n    indexOf(value) {\n        return this.items.findIndex((entry) => entry !== undefined && Object.is(entry[1], value));\n    }\n    /**\n     * Checks if the IOObject is empty.\n     * @returns True if empty, otherwise false.\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * Creates an IOObject from an array of values or [key, value] pairs.\n     * @param array The array to create from.\n     * @returns A new IOObject instance.\n     */\n    static fromArray(array) {\n        const io = new IOObject();\n        for (const item of array) {\n            if (Array.isArray(item)) {\n                io.set(item[0], item[1]);\n            }\n            else {\n                io.push(item);\n            }\n        }\n        return io;\n    }\n    /**\n     * Returns the number of entries in the IOObject, including undefined entries.\n     */\n    get length() {\n        return this.items.length;\n    }\n    /**\n     * Clears all key-value pairs from the IOObject.\n     */\n    clear() {\n        // Remove all instance properties for keys\n        for (const key of this.keysArray()) {\n            delete this[key];\n        }\n        this.items = [];\n        this.keyMap.clear();\n    }\n    /**\n     * Compacts the items array by removing undefined entries and updating the keyMap.\n     * Note: This operation is O(n) and may affect performance on large datasets.\n     * Use this method when you need to reduce memory usage or after multiple deletions.\n     */\n    compact() {\n        const newItems = [];\n        const newKeyMap = new Map();\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                newItems.push(entry);\n                const key = entry[0];\n                if (key !== undefined) {\n                    newKeyMap.set(key, newItems.length - 1);\n                }\n            }\n        }\n        this.items = newItems;\n        this.keyMap = newKeyMap;\n    }\n    /**\n     * Executes a provided function once for each key-value pair.\n     * @param callbackfn Function to execute for each element.\n     * @param thisArg Value to use as `this` when executing callback.\n     */\n    forEach(callbackfn, thisArg) {\n        for (let index = 0; index < this.items.length; index++) {\n            const entry = this.items[index];\n            if (entry !== undefined) {\n                callbackfn.call(thisArg, entry[1], entry[0], index);\n            }\n        }\n    }\n    /**\n     * Returns an iterable of key, value pairs for every entry in the IOObject.\n     */\n    entries() {\n        return this._createIterator((entry) => entry);\n    }\n    /**\n     * Returns an array of keys in the IOObject.\n     * Excludes entries without keys (i.e., where key is undefined).\n     * @returns An array of keys.\n     */\n    keysArray() {\n        return this.items\n            .filter((entry) => entry !== undefined && entry[0] !== undefined)\n            .map((entry) => entry[0]);\n    }\n    /**\n     * Returns an iterable of keys in the IOObject.\n     * Excludes entries without keys (i.e., where key is undefined).\n     */\n    keys() {\n        return (function* (items) {\n            for (const entry of items) {\n                if (entry !== undefined && entry[0] !== undefined) {\n                    yield entry[0];\n                }\n            }\n        })(this.items);\n    }\n    /**\n     * Returns an iterable of values in the IOObject.\n     */\n    values() {\n        return (function* (items) {\n            for (const entry of items) {\n                if (entry !== undefined) {\n                    yield entry[1];\n                }\n            }\n        })(this.items);\n    }\n    /**\n     * Returns an array of values in the IOObject.\n     * Includes all entries, even those without keys.\n     * @returns An array of values.\n     */\n    valuesArray() {\n        return this.items\n            .filter((entry) => entry !== undefined)\n            .map((entry) => entry[1]);\n    }\n    /**\n     * Creates an iterator based on a selector function.\n     * @param selector Function to select the output of the iterator.\n     */\n    *_createIterator(selector) {\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                yield selector(entry);\n            }\n        }\n    }\n    /**\n     * Returns an iterator over the entries in insertion order.\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Returns the default string representation of the object.\n     */\n    get [Symbol.toStringTag]() {\n        return 'IOObject';\n    }\n    /**\n     * Finds a value based on a predicate function.\n     * @param predicate Function to test each element.\n     * @returns The value if found, otherwise undefined.\n     */\n    find(predicate) {\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined && predicate(entry[1], entry[0], index)) {\n                return entry[1];\n            }\n            index++;\n        }\n        return undefined;\n    }\n    /**\n     * Finds the index of a value based on a predicate function.\n     * @param predicate Function to test each element.\n     * @returns The index if found, otherwise -1.\n     */\n    findIndex(predicate) {\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined && predicate(entry[1], entry[0], index)) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n    /**\n     * Creates a new array populated with the results of calling a provided function on every element.\n     * @param callbackfn Function that produces an element of the new Array.\n     * @param thisArg Value to use as `this` when executing callback.\n     * @returns A new array with each element being the result of the callback function.\n     */\n    map(callbackfn, thisArg) {\n        const result = [];\n        let index = 0;\n        for (const entry of this.items) {\n            if (entry !== undefined) {\n                result.push(callbackfn.call(thisArg, entry[1], entry[0], index));\n            }\n            index++;\n        }\n        return result;\n    }\n    /**\n     * Converts the InternetObject to a JSON object. If the items do not have keys,\n     * use the index as the key. If the value has toJSON method, it will be called.\n     * Used when calling JSON.stringify.\n     * @returns An array of entries.\n     */\n    toJSON() {\n        const obj = {};\n        this.forEach((value, key, index) => {\n            if (typeof value === \"undefined\")\n                return;\n            obj[key || index] =\n                typeof value === 'object' && typeof value?.toJSON === 'function'\n                    ? value.toJSON()\n                    : value;\n        });\n        return obj;\n    }\n}\nexport default IOObject;\n","import assertNever from '../errors/asserts/asserts';\nimport IOObject from \"./internet-object\";\n/**\n * IOCollection is a collection of IOObject instances.\n */\nclass IOCollection {\n    /**\n     * Constructs a new IOCollection instance.\n     * @param items - An optional array of items to initialize the collection with.\n     */\n    constructor(items = []) {\n        this._items = items;\n    }\n    /**\n     * Pushes one or more items to the IOCollection\n     * @param items - The items to push.\n     * @returns The updated IOCollection.\n     */\n    push(...items) {\n        this._items.push(...items);\n        return this;\n    }\n    /**\n     * Gets the item at the specified index.\n     * @param index - The index of the item to retrieve.\n     * @throws {Error} If the index is out of range.\n     * @returns The item at the specified index.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Index out of range');\n        }\n        return this._items[index];\n    }\n    /**\n     * Sets the item at the specified index.\n     * @param index - The index at which to set the item.\n     * @param item - The item to set.\n     * @throws {Error} If the index is negative.\n     * @returns The updated IOCollection.\n     */\n    setAt(index, item) {\n        if (index < 0) {\n            throw new Error('Index cannot be negative.');\n        }\n        if (index >= this._items.length) {\n            this._items.push(item);\n        }\n        else {\n            this._items[index] = item;\n        }\n        return this;\n    }\n    /**\n     * Deletes an item from the IOCollection at the specified index.\n     * @param index - The index of the item to delete.\n     * @throws {Error} If the index is out of range.\n     * @returns The updated IOCollection.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('Index out of range');\n        }\n        this._items.splice(index, 1);\n        return this;\n    }\n    /**\n     * Gets the length of the IOCollection.\n     * @returns The number of items in the IOCollection.\n     */\n    get length() {\n        return this._items.length;\n    }\n    /**\n     * Checks if the IOCollection is empty.\n     * @returns True if the IOCollection is empty, otherwise false.\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * Creates a new IOCollection with the results of calling a provided function on every element.\n     * @param callback - Function that produces an element of the new IOCollection.\n     * @returns A new IOCollection with each element being the result of the callback function.\n     */\n    map(callback) {\n        const mappedItems = this._items.map(callback);\n        return new IOCollection(mappedItems);\n    }\n    /**\n     * Creates a new IOCollection with all elements that pass the test implemented by the provided function.\n     * @param callback - Function to test each element of the IOCollection.\n     * @returns A new IOCollection with the elements that pass the test.\n     */\n    filter(callback) {\n        const filteredItems = this._items.filter(callback);\n        return new IOCollection(filteredItems);\n    }\n    /**\n     * Applies a function against an accumulator and each element in the IOCollection to reduce it to a single value.\n     * @param callback - Function to execute on each element in the IOCollection.\n     * @param initialValue - Initial value to start the reduction.\n     * @returns The single value that results from the reduction.\n     */\n    reduce(callback, initialValue) {\n        return this._items.reduce(callback, initialValue);\n    }\n    /**\n     * Executes a provided function once for each IOCollection element.\n     * @param callback - Function to execute on each element.\n     */\n    forEach(callback) {\n        this._items.forEach(callback);\n    }\n    /**\n     * Tests whether at least one element in the IOCollection passes the test implemented by the provided function.\n     * @param callback - Function to test each element.\n     * @returns True if the callback function returns a truthy value for at least one element, otherwise false.\n     */\n    some(callback) {\n        return this._items.some(callback);\n    }\n    /**\n     * Tests whether all elements in the IOCollection pass the test implemented by the provided function.\n     * @param callback - Function to test each element.\n     * @returns True if the callback returns a truthy value for all elements, otherwise false.\n     */\n    every(callback) {\n        return this._items.every(callback);\n    }\n    /**\n     * Returns the value of the first element in the IOCollection that satisfies the provided testing function.\n     * @param callback - Function to execute on each element.\n     * @returns The first element that satisfies the testing function, or undefined if no elements satisfy it.\n     */\n    find(callback) {\n        return this._items.find(callback);\n    }\n    /**\n     * Returns the index of the first element in the IOCollection that satisfies the provided testing function.\n     * @param callback - Function to execute on each element.\n     * @returns The index of the first element that satisfies the testing function, or -1 if no elements satisfy it.\n     */\n    findIndex(callback) {\n        return this._items.findIndex(callback);\n    }\n    /**\n     * Inserts one or more items into the IOCollection at the specified index.\n     * @param index - The index at which to insert the items.\n     * @param items - The items to insert.\n     * @returns The new length of the IOCollection.\n     */\n    insert(index, ...items) {\n        this._items.splice(index, 0, ...items);\n        return this._items.length;\n    }\n    /**\n     * Removes the last item from the IOCollection.\n     * @returns The removed item, or undefined if the IOCollection is empty.\n     */\n    pop() {\n        return this._items.pop();\n    }\n    /**\n     * Converts the IOCollection to a JSON-compatible representation.\n     * @param options Optional configuration for JSON conversion\n     * @param options.skipErrors If true, excludes error objects from output (default: false)\n     * @returns An array of JSON-compatible representations of the items.\n     */\n    toJSON(options) {\n        const skipErrors = options?.skipErrors ?? false;\n        return this._items\n            .filter((item) => {\n            // If skipErrors is true, filter out items with toValue that return __error\n            if (skipErrors && typeof item === 'object' && item !== null) {\n                if (typeof item.toValue === 'function') {\n                    const value = item.toValue();\n                    if (value && value.__error === true) {\n                        return false; // Skip this error item\n                    }\n                }\n            }\n            return true; // Keep this item\n        })\n            .map((item) => {\n            if (item instanceof IOObject) {\n                return item.toJSON();\n            }\n            else if (typeof item === 'object' && item !== null) {\n                // Check if item has toValue method (e.g., ErrorNode)\n                if (typeof item.toValue === 'function') {\n                    return item.toValue();\n                }\n                // Check if item has toJSON method\n                if (typeof item.toJSON === 'function') {\n                    return item.toJSON();\n                }\n                return JSON.stringify(item);\n            }\n            return item;\n        });\n    }\n    /**\n     * Returns all Error objects contained within this collection's ErrorNodes.\n     *\n     * Note: This method is primarily useful when working with collections directly.\n     * When using Document.getErrors(), all errors (parser + validation) are already\n     * aggregated at the document level.\n     *\n     * @returns Array of Error objects from ErrorNode items in this collection\n     */\n    getErrors() {\n        const errors = [];\n        for (const item of this._items) {\n            // ErrorNode-like shape: has an `error` property of type Error\n            if (item && typeof item === 'object' && item.error instanceof Error) {\n                errors.push(item.error);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Allows iteration over the IOCollection using for..of syntax.\n     * @returns An iterator for the IOCollection.\n     */\n    *[Symbol.iterator]() {\n        yield* this._items;\n    }\n    /**\n     * Returns an iterator of [index, item] pairs.\n     * @returns An iterator of index-item pairs.\n     */\n    *entries() {\n        for (let index = 0; index < this._items.length; index++) {\n            yield [index, this._items[index]];\n        }\n    }\n    /**\n     * Returns an iterator of item indices.\n     * @returns An iterator of item indices.\n     */\n    *keys() {\n        for (let index = 0; index < this._items.length; index++) {\n            yield index;\n        }\n    }\n    /**\n     * Returns an iterator of IOCollection items.\n     * @returns An iterator of IOCollection items.\n     */\n    *values() {\n        yield* this._items;\n    }\n}\nconst proxy = {\n    get: (target, property) => {\n        if (property in target) {\n            return Reflect.get(target, property);\n        }\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            return target.getAt(Number(property));\n        }\n        assertNever(property);\n    },\n    set: (target, property, value) => {\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            target.setAt(Number(property), value);\n            return true;\n        }\n        throw new Error('Cannot set a value on a Collection');\n    },\n    deleteProperty: (target, property) => {\n        if (typeof property === 'string' && /^[0-9]+$/.test(property)) {\n            const index = Number(property);\n            target.deleteAt(index);\n            return true;\n        }\n        throw new Error('Cannot delete a value on a Collection');\n    }\n};\nexport default IOCollection;\n","/**\n * Decimal Utility Functions\n *\n * Core utility functions for decimal arithmetic operations following KISS principles.\n * All functions use BigInt-only calculations and avoid JavaScript Number class.\n */\nimport { DecimalError } from './decimal';\n/**\n * Normalizes a BigInt coefficient by handling leading zeros and sign normalization.\n *\n * @param coefficient The BigInt coefficient to normalize\n * @returns Normalized coefficient and zero flag\n */\nexport function normalizeCoefficient(coefficient) {\n    // Handle zero case\n    if (coefficient === 0n) {\n        return {\n            coefficient: 0n,\n            isZero: true\n        };\n    }\n    // For non-zero values, BigInt already handles normalization\n    // No leading zeros exist in BigInt representation\n    return {\n        coefficient,\n        isZero: false\n    };\n}\n/**\n * Gets the absolute value of a BigInt coefficient.\n *\n * @param coefficient The BigInt coefficient\n * @returns The absolute value as BigInt\n */\nexport function getAbsoluteValue(coefficient) {\n    return coefficient < 0n ? -coefficient : coefficient;\n}\n/**\n * Gets the sign of a BigInt coefficient.\n *\n * @param coefficient The BigInt coefficient\n * @returns 1 for positive, -1 for negative, 0 for zero\n */\nexport function getSign(coefficient) {\n    if (coefficient === 0n)\n        return 0;\n    return coefficient > 0n ? 1 : -1;\n}\n/**\n * Cache for powers of 10\n */\nconst POW10_CACHE = new Map();\n/**\n * Gets a power of 10 as BigInt, using cache for performance.\n * @param exponent The exponent for the power of 10\n * @returns 10^exponent as BigInt\n */\nexport function getPow10(exponent) {\n    if (exponent < 0) {\n        throw new Error('Exponent must be non-negative');\n    }\n    if (!POW10_CACHE.has(exponent)) {\n        POW10_CACHE.set(exponent, 10n ** BigInt(exponent));\n    }\n    return POW10_CACHE.get(exponent);\n}\n/**\n * Scales up a coefficient by multiplying by powers of 10.\n * Effectively moves the decimal point to the right.\n *\n * @param coefficient The BigInt coefficient to scale up\n * @param scaleFactor The number of decimal places to scale up (must be non-negative)\n * @returns The scaled up coefficient\n * @throws Error if scaleFactor is negative\n */\nexport function scaleUp(coefficient, scaleFactor) {\n    if (scaleFactor < 0) {\n        throw new Error(`Scale factor must be non-negative, got ${scaleFactor}`);\n    }\n    if (scaleFactor === 0) {\n        return coefficient;\n    }\n    return coefficient * getPow10(scaleFactor);\n}\n/**\n * Scales down a coefficient by dividing by powers of 10 with basic truncation.\n * Effectively moves the decimal point to the left.\n *\n * @param coefficient The BigInt coefficient to scale down\n * @param scaleFactor The number of decimal places to scale down (must be non-negative)\n * @returns The scaled down coefficient (truncated, not rounded)\n * @throws Error if scaleFactor is negative\n */\nexport function scaleDown(coefficient, scaleFactor) {\n    if (scaleFactor < 0) {\n        throw new Error('Scale factor must be non-negative');\n    }\n    if (scaleFactor === 0) {\n        return coefficient;\n    }\n    return coefficient / getPow10(scaleFactor);\n}\n/**\n * Rounds a coefficient using round-half-up behavior when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function roundHalfUp(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with rounding\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Round half up logic\n    const halfDivisor = divisor / 2n;\n    const absRemainder = remainder < 0n ? -remainder : remainder;\n    if (absRemainder >= halfDivisor) {\n        return quotient + (coefficient >= 0n ? 1n : -1n);\n    }\n    return quotient;\n}\n/**\n * Rounds a coefficient using ceiling behavior (always round up) when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The ceiling rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function ceilRound(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with ceiling\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Ceiling logic: if there's any remainder and coefficient is positive, round up\n    // If coefficient is negative and there's remainder, don't round (towards zero)\n    if (remainder !== 0n && coefficient > 0n) {\n        return quotient + 1n;\n    }\n    return quotient;\n}\n/**\n * Rounds a coefficient using floor behavior (always round down) when scaling down.\n *\n * @param coefficient The BigInt coefficient to round\n * @param currentScale The current scale of the coefficient\n * @param targetScale The target scale after rounding\n * @returns The floor rounded coefficient\n * @throws Error if targetScale is negative or currentScale is negative\n */\nexport function floorRound(coefficient, currentScale, targetScale) {\n    if (currentScale < 0 || targetScale < 0) {\n        throw new Error('Scales must be non-negative');\n    }\n    if (currentScale <= targetScale) {\n        // Scale up by padding zeros\n        return scaleUp(coefficient, targetScale - currentScale);\n    }\n    // Scale down with floor\n    const scaleDiff = currentScale - targetScale;\n    const divisor = getPow10(scaleDiff);\n    const quotient = coefficient / divisor;\n    const remainder = coefficient % divisor;\n    // Floor logic: if there's any remainder and coefficient is negative, round down\n    // If coefficient is positive and there's remainder, don't round (towards zero)\n    if (remainder !== 0n && coefficient < 0n) {\n        return quotient - 1n;\n    }\n    return quotient;\n}\n/**\n * Formats a BigInt coefficient as a decimal string with the specified scale and precision.\n * Uses normalization utilities for proper coefficient handling and decimal point placement.\n *\n * @param coefficient The BigInt coefficient to format\n * @param scale The number of decimal places\n * @param precision Optional. The total number of significant digits. If provided, validates that the coefficient fits within precision.\n * @returns The formatted decimal string\n * @throws Error if the coefficient exceeds the specified precision\n */\nexport function formatBigIntAsDecimal(coefficient, scale, precision) {\n    // Handle zero case\n    if (coefficient === 0n) {\n        return scale > 0 ? `0.${'0'.repeat(scale)}` : '0';\n    }\n    // Validate precision and scale if precision is provided\n    if (precision !== undefined) {\n        const validationResult = validatePrecisionScale(coefficient, precision, scale);\n        if (!validationResult.valid) {\n            throw new DecimalError(`Coefficient validation failed: ${validationResult.reason}`);\n        }\n    }\n    // Extract sign and work with absolute value\n    const sign = coefficient < 0n ? '-' : '';\n    const absCoeff = coefficient < 0n ? -coefficient : coefficient;\n    let coeffStr = absCoeff.toString();\n    // Pad with leading zeros if needed\n    while (coeffStr.length <= scale) {\n        coeffStr = '0' + coeffStr;\n    }\n    // Split into integer and fractional parts\n    const integerPart = coeffStr.slice(0, coeffStr.length - scale) || '0';\n    const fractionalPart = scale > 0 ? coeffStr.slice(-scale) : '';\n    // Validate that the formatted number fits within precision constraints\n    // This is a check on the significant digits in the formatted result\n    if (precision !== undefined) {\n        // Count significant digits (ignore leading zeros in integer part)\n        const significantIntegerDigits = integerPart === '0' ? 0 : integerPart.replace(/^0+/, '').length;\n        // For fractional part, count all digits except trailing zeros if integer part is 0\n        let significantFractionalDigits = fractionalPart.length;\n        if (significantIntegerDigits === 0) {\n            // For values less than 1, ignore leading zeros in fractional part\n            const significantFractionalPart = fractionalPart.replace(/^0+/, '');\n            significantFractionalDigits = significantFractionalPart.length || 0;\n        }\n        const totalSignificantDigits = significantIntegerDigits + significantFractionalDigits;\n        if (totalSignificantDigits > precision) {\n            throw new DecimalError(`Formatted value exceeds specified precision (${precision}). Value has ${totalSignificantDigits} significant digits.`);\n        }\n    }\n    return sign + integerPart + (scale > 0 ? '.' + fractionalPart : '');\n}\n/**\n * Fits a coefficient to the specified precision by truncating and rounding if necessary.\n * Uses the specified rounding mode to handle precision overflow.\n *\n * @param coefficient The BigInt coefficient to fit to precision\n * @param precision The maximum number of significant digits allowed\n * @param scale The current scale of the coefficient\n * @param roundingMode The rounding mode to use ('round', 'ceil', 'floor')\n * @returns The coefficient fitted to the specified precision\n * @throws DecimalError if the coefficient cannot be fitted to the precision\n */\nexport function fitToPrecision(coefficient, precision, scale, roundingMode = 'round') {\n    // Handle zero coefficient\n    if (coefficient === 0n) {\n        return 0n;\n    }\n    // Get absolute value for digit counting\n    const absCoeff = getAbsoluteValue(coefficient);\n    const coeffStr = absCoeff.toString();\n    // If already fits within precision, return unchanged\n    if (coeffStr.length <= precision) {\n        return coefficient;\n    }\n    // Calculate how many digits to remove\n    const excessDigits = coeffStr.length - precision;\n    // If excess digits are more than scale, we can't fit without losing integer part\n    if (excessDigits > scale) {\n        // We would lose digits from the integer part, which is not allowed\n        throw new DecimalError(`Cannot fit coefficient to precision ${precision}. ` +\n            `Coefficient has ${coeffStr.length} digits with scale ${scale}. ` +\n            `Would lose ${excessDigits - scale} digits from integer part.`);\n    }\n    // Calculate target scale after truncation\n    const targetScale = scale - excessDigits;\n    // Apply appropriate rounding based on mode\n    let result;\n    switch (roundingMode) {\n        case 'round':\n            result = roundHalfUp(coefficient, scale, targetScale);\n            break;\n        case 'ceil':\n            result = ceilRound(coefficient, scale, targetScale);\n            break;\n        case 'floor':\n            result = floorRound(coefficient, scale, targetScale);\n            break;\n        default:\n            throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n    }\n    // Verify the result fits within precision\n    const resultStr = getAbsoluteValue(result).toString();\n    if (resultStr.length > precision) {\n        // This can happen with rounding (e.g., 999 rounded to 2 digits becomes 1000)\n        // In this case, we need to adjust scale again\n        if (targetScale > 0) {\n            // Use the same rounding mode for consistency\n            switch (roundingMode) {\n                case 'round':\n                    return roundHalfUp(result, targetScale, targetScale - 1);\n                case 'ceil':\n                    return ceilRound(result, targetScale, targetScale - 1);\n                case 'floor':\n                    return floorRound(result, targetScale, targetScale - 1);\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n        else {\n            // Special case for rounding that causes overflow (e.g., 9999 -> 10000)\n            // If the result ends with zeros, we can remove them to fit precision\n            if (result % 10n === 0n) {\n                // Count trailing zeros\n                let tempResult = result;\n                let zerosToRemove = 0;\n                while (tempResult % 10n === 0n && zerosToRemove < resultStr.length - precision) {\n                    tempResult = tempResult / 10n;\n                    zerosToRemove++;\n                }\n                if (getAbsoluteValue(tempResult).toString().length <= precision) {\n                    return tempResult;\n                }\n            }\n            throw new DecimalError(`Rounding resulted in precision overflow. ` +\n                `Result has ${resultStr.length} digits, but precision is ${precision}.`);\n        }\n    }\n    return result;\n}\n/**\n * Validates if a coefficient fits within the specified precision and scale constraints.\n *\n * @param coefficient The BigInt coefficient to validate\n * @param precision The maximum number of significant digits allowed\n * @param scale The number of decimal places\n * @returns A ValidationResult object indicating if the coefficient is valid and why if not\n */\nexport function validatePrecisionScale(coefficient, precision, scale) {\n    // Validate precision and scale parameters\n    if (precision <= 0) {\n        return { valid: false, reason: 'Precision must be positive' };\n    }\n    if (scale < 0) {\n        return { valid: false, reason: 'Scale must be non-negative' };\n    }\n    if (scale > precision) {\n        return { valid: false, reason: 'Scale must be less than or equal to precision' };\n    }\n    // Handle zero coefficient (always valid)\n    if (coefficient === 0n) {\n        return { valid: true };\n    }\n    // Get absolute value for digit counting\n    const absCoeff = getAbsoluteValue(coefficient);\n    const coeffStr = absCoeff.toString();\n    // Check if coefficient fits within precision\n    if (coeffStr.length > precision) {\n        return {\n            valid: false,\n            reason: `Coefficient has ${coeffStr.length} digits, exceeding precision of ${precision}`\n        };\n    }\n    // Calculate integer part digits\n    const integerDigits = coeffStr.length - scale;\n    // If integer part is negative, we have leading zeros in fractional part\n    if (integerDigits < 0) {\n        // This is valid, as it means we have leading zeros in fractional part\n        // For example: 0.001 with scale 3 has integerDigits = -2\n        return { valid: true };\n    }\n    // If we get here, the coefficient fits within precision and scale constraints\n    return { valid: true };\n}\n/**\n * Performs long division between two BigInt coefficients with specified scale and precision.\n * Handles repeating decimals and precision constraints.\n *\n * @param dividend The dividend coefficient\n * @param divisor The divisor coefficient (must not be zero)\n * @param scale The desired scale (decimal places) for the result\n * @param precision The maximum precision allowed for the result\n * @param maxIterations Maximum number of iterations to detect repeating decimals (default: 100)\n * @returns A DivisionResult object containing quotient, remainder, and flags for exactness and repeating digits\n * @throws DecimalError if divisor is zero or if precision constraints cannot be met\n */\nexport function performLongDivision(dividend, divisor, scale, precision, maxIterations = 100) {\n    // Validate inputs\n    if (divisor === 0n) {\n        throw new DecimalError(\"Division by zero\");\n    }\n    if (precision <= 0) {\n        throw new DecimalError(\"Precision must be positive\");\n    }\n    if (scale < 0) {\n        throw new DecimalError(\"Scale must be non-negative\");\n    }\n    if (scale > precision) {\n        throw new DecimalError(\"Scale must be less than or equal to precision\");\n    }\n    // Handle zero dividend case\n    if (dividend === 0n) {\n        return {\n            quotient: 0n,\n            remainder: 0n,\n            isExact: true\n        };\n    }\n    // Work with absolute values for division\n    const isNegative = (dividend < 0n) !== (divisor < 0n);\n    const absDividend = getAbsoluteValue(dividend);\n    const absDivisor = getAbsoluteValue(divisor);\n    // Scale up the dividend to get the desired decimal places (use cached pow10)\n    const scaledDividend = absDividend * getPow10(scale);\n    // Perform integer division\n    let quotient = scaledDividend / absDivisor;\n    const remainder = scaledDividend % absDivisor;\n    // Check if division is exact\n    const isExact = remainder === 0n;\n    // Apply sign to quotient\n    if (isNegative) {\n        quotient = -quotient;\n    }\n    // Check for repeating decimals if not exact\n    let repeatingDigits;\n    if (!isExact && scale > 0) {\n        repeatingDigits = detectRepeatingDecimals(absDividend, absDivisor, scale, maxIterations);\n    }\n    // Ensure the result fits within precision constraints\n    const quotientStr = getAbsoluteValue(quotient).toString();\n    if (quotientStr.length > precision) {\n        // For division, we should truncate excess digits rather than trying to round\n        // This is because division can produce an infinite number of digits\n        const excessDigits = quotientStr.length - precision;\n        if (excessDigits <= scale) {\n            // We can truncate from the fractional part\n            const divisor = 10n ** BigInt(excessDigits);\n            quotient = quotient / divisor;\n        }\n        else {\n            // Cannot fit within precision constraints\n            throw new DecimalError(`Division result exceeds precision limit (${precision}). ` +\n                `Result has ${quotientStr.length} digits, but precision is ${precision}.`);\n        }\n    }\n    return {\n        quotient,\n        remainder: isNegative ? -remainder : remainder,\n        isExact,\n        repeatingDigits\n    };\n}\n/**\n * Aligns two decimal operands to have the same scale for arithmetic operations.\n * Scales up the operand with the smaller scale to match the larger scale.\n *\n * @param aCoefficient First operand coefficient\n * @param aScale Scale of the first operand\n * @param bCoefficient Second operand coefficient\n * @param bScale Scale of the second operand\n * @param maxScale Optional maximum scale to limit the result scale (default: no limit)\n * @param roundingMode The rounding mode to use when scaling down ('round', 'ceil', 'floor')\n * @returns An AlignedOperands object with aligned coefficients and the target scale\n */\nexport function alignOperands(aCoefficient, aScale, bCoefficient, bScale, maxScale, roundingMode = 'round') {\n    // Handle zero operands\n    if (aCoefficient === 0n) {\n        return {\n            a: 0n,\n            b: bCoefficient,\n            targetScale: bScale,\n            scaleAdjustment: 0\n        };\n    }\n    if (bCoefficient === 0n) {\n        return {\n            a: aCoefficient,\n            b: 0n,\n            targetScale: aScale,\n            scaleAdjustment: 0\n        };\n    }\n    // Determine target scale (the larger of the two scales)\n    let targetScale = Math.max(aScale, bScale);\n    // Apply maximum scale constraint if provided\n    if (maxScale !== undefined && targetScale > maxScale) {\n        targetScale = maxScale;\n    }\n    // Calculate scale adjustments\n    const aAdjustment = targetScale - aScale;\n    const bAdjustment = targetScale - bScale;\n    // Scale up operands as needed\n    let adjustedA = aCoefficient;\n    let adjustedB = bCoefficient;\n    if (aAdjustment > 0) {\n        adjustedA = scaleUp(aCoefficient, aAdjustment);\n    }\n    if (bAdjustment > 0) {\n        adjustedB = scaleUp(bCoefficient, bAdjustment);\n    }\n    // If maxScale is less than either original scale, we need to scale down\n    if (maxScale !== undefined) {\n        if (aScale > maxScale) {\n            // Use the specified rounding mode\n            switch (roundingMode) {\n                case 'round':\n                    adjustedA = roundHalfUp(aCoefficient, aScale, maxScale);\n                    break;\n                case 'ceil':\n                    adjustedA = ceilRound(aCoefficient, aScale, maxScale);\n                    break;\n                case 'floor':\n                    adjustedA = floorRound(aCoefficient, aScale, maxScale);\n                    break;\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n        if (bScale > maxScale) {\n            // Use the specified rounding mode\n            switch (roundingMode) {\n                case 'round':\n                    adjustedB = roundHalfUp(bCoefficient, bScale, maxScale);\n                    break;\n                case 'ceil':\n                    adjustedB = ceilRound(bCoefficient, bScale, maxScale);\n                    break;\n                case 'floor':\n                    adjustedB = floorRound(bCoefficient, bScale, maxScale);\n                    break;\n                default:\n                    throw new DecimalError(`Invalid rounding mode: ${roundingMode}`);\n            }\n        }\n    }\n    return {\n        a: adjustedA,\n        b: adjustedB,\n        targetScale,\n        scaleAdjustment: Math.max(aAdjustment, bAdjustment)\n    };\n}\n/**\n * Detects repeating decimals in division operation.\n * Uses the standard long division algorithm to identify repeating patterns.\n *\n * @param dividend The dividend (absolute value)\n * @param divisor The divisor (absolute value)\n * @param scale The desired scale (decimal places)\n * @param maxIterations Maximum iterations to detect repeating pattern\n * @returns The repeating decimal digits as a string, or undefined if no repeating pattern found\n */\nfunction detectRepeatingDecimals(dividend, divisor, scale, maxIterations) {\n    // First, get the integer part out of the way\n    const integerPart = dividend / divisor;\n    let remainder = dividend % divisor;\n    // If remainder is zero, there's no repeating decimal\n    if (remainder === 0n) {\n        return undefined;\n    }\n    // Track remainders to detect cycles\n    const remainders = new Map();\n    let fractionalDigits = '';\n    let position = 0;\n    // Perform long division algorithm\n    while (remainder !== 0n && position < maxIterations) {\n        // Scale up remainder by 10\n        remainder = remainder * 10n;\n        // Store the current remainder and position\n        const remainderKey = remainder.toString();\n        if (remainders.has(remainderKey)) {\n            // Found a repeating pattern\n            const cycleStart = remainders.get(remainderKey);\n            return fractionalDigits.substring(cycleStart);\n        }\n        remainders.set(remainderKey, position);\n        // Calculate next digit and remainder\n        const digit = remainder / divisor;\n        remainder = remainder % divisor;\n        // Add digit to fractional part\n        fractionalDigits += digit.toString();\n        position++;\n    }\n    // If we've reached max iterations without finding a cycle,\n    // we can't determine if there's a repeating pattern\n    return undefined;\n} /**\n\n * RDBMS-compliant precision and scale calculation result\n */\n/**\n * Calculates the result precision and scale for addition/subtraction operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Addition/Subtraction:\n * - Result Scale = max(scale1, scale2)\n * - Result Precision = max(precision1 - scale1, precision2 - scale2) + result_scale + 1\n *\n * The +1 accounts for potential carry in addition or borrow in subtraction.\n *\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateAdditionResultPrecisionScale(precision1, scale1, precision2, scale2) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Calculate result scale (maximum of input scales)\n    const resultScale = Math.max(scale1, scale2);\n    // Calculate integer digits for each operand\n    const integerDigits1 = precision1 - scale1;\n    const integerDigits2 = precision2 - scale2;\n    // Calculate result precision\n    // max(integer_digits) + result_scale + 1 (for potential carry/borrow)\n    const maxIntegerDigits = Math.max(integerDigits1, integerDigits2);\n    const resultPrecision = maxIntegerDigits + resultScale + 1;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Calculates the result precision and scale for multiplication operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Multiplication:\n * - Result Scale = scale1 + scale2\n * - Result Precision = precision1 + precision2 + 1\n *\n * The +1 accounts for potential overflow in multiplication.\n *\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateMultiplicationResultPrecisionScale(precision1, scale1, precision2, scale2) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Calculate result scale (sum of input scales)\n    const resultScale = scale1 + scale2;\n    // Calculate result precision (sum of input precisions + 1 for overflow)\n    const resultPrecision = precision1 + precision2 + 1;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Calculates the result precision and scale for division operations\n * following RDBMS/SQL standards.\n *\n * RDBMS Standard for Division (varies by system, this follows common approach):\n * - Result Scale = max(6, scale1 + precision2 + 1)\n * - Result Precision = precision1 - scale1 + scale2 + max(6, scale1 + precision2 + 1)\n *\n * Different RDBMS systems handle division differently:\n * - SQL Server: Uses a complex formula with minimum scale of 6\n * - PostgreSQL: Uses configurable precision\n * - Oracle: Uses maximum available precision\n *\n * This implementation follows a conservative approach similar to SQL Server.\n *\n * @param precision1 Precision of dividend\n * @param scale1 Scale of dividend\n * @param precision2 Precision of divisor\n * @param scale2 Scale of divisor\n * @param minScale Minimum scale for result (default: 6, following SQL Server)\n * @returns RdbmsArithmeticResult with calculated precision and scale\n * @throws DecimalError if parameters are invalid\n */\nexport function calculateDivisionResultPrecisionScale(precision1, scale1, precision2, scale2, minScale = 6) {\n    // Validate input parameters\n    if (precision1 <= 0 || precision2 <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale1 < 0 || scale2 < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale1 > precision1 || scale2 > precision2) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    if (minScale < 0) {\n        throw new DecimalError('Minimum scale must be non-negative');\n    }\n    // Calculate result scale\n    const calculatedScale = scale1 + precision2 + 1;\n    const resultScale = Math.max(minScale, calculatedScale);\n    // Calculate result precision\n    const integerDigits1 = precision1 - scale1;\n    const resultPrecision = integerDigits1 + scale2 + resultScale;\n    return {\n        precision: resultPrecision,\n        scale: resultScale\n    };\n}\n/**\n * Validates that the calculated precision and scale are within reasonable limits\n * and adjusts them if necessary to prevent overflow or excessive memory usage.\n *\n * @param precision The calculated precision\n * @param scale The calculated scale\n * @param maxPrecision Maximum allowed precision (default: 38, SQL Server limit)\n * @param maxScale Maximum allowed scale (default: same as maxPrecision)\n * @returns Adjusted RdbmsArithmeticResult within limits\n * @throws DecimalError if the result cannot be represented within limits\n */\nexport function validateAndAdjustPrecisionScale(precision, scale, maxPrecision = 38, maxScale) {\n    const effectiveMaxScale = maxScale ?? maxPrecision;\n    // Validate basic constraints\n    if (precision <= 0) {\n        throw new DecimalError('Precision must be positive');\n    }\n    if (scale < 0) {\n        throw new DecimalError('Scale must be non-negative');\n    }\n    if (scale > precision) {\n        throw new DecimalError('Scale must not exceed precision');\n    }\n    // Check if within limits\n    if (precision <= maxPrecision && scale <= effectiveMaxScale) {\n        return { precision, scale };\n    }\n    // Adjust if exceeding limits\n    let adjustedPrecision = Math.min(precision, maxPrecision);\n    let adjustedScale = Math.min(scale, effectiveMaxScale);\n    // Ensure scale doesn't exceed adjusted precision\n    if (adjustedScale > adjustedPrecision) {\n        // Prioritize scale, but ensure we have at least 1 integer digit\n        adjustedScale = Math.max(0, adjustedPrecision - 1);\n    }\n    // Ensure we have at least 1 integer digit\n    if (adjustedScale >= adjustedPrecision) {\n        adjustedScale = Math.max(0, adjustedPrecision - 1);\n    }\n    return {\n        precision: adjustedPrecision,\n        scale: adjustedScale\n    };\n}\n/**\n * Determines the appropriate precision and scale for a decimal result\n * based on the operation type and operand characteristics.\n *\n * This is a convenience function that combines the specific calculation\n * functions with validation and adjustment.\n *\n * @param operation The arithmetic operation type\n * @param precision1 Precision of first operand\n * @param scale1 Scale of first operand\n * @param precision2 Precision of second operand\n * @param scale2 Scale of second operand\n * @param options Optional configuration for limits and division behavior\n * @returns RdbmsArithmeticResult with final precision and scale\n */\nexport function calculateRdbmsArithmeticResult(operation, precision1, scale1, precision2, scale2, options) {\n    let result;\n    // Calculate based on operation type\n    switch (operation) {\n        case 'add':\n        case 'subtract':\n            result = calculateAdditionResultPrecisionScale(precision1, scale1, precision2, scale2);\n            break;\n        case 'multiply':\n            result = calculateMultiplicationResultPrecisionScale(precision1, scale1, precision2, scale2);\n            break;\n        case 'divide':\n            result = calculateDivisionResultPrecisionScale(precision1, scale1, precision2, scale2, options?.divisionMinScale);\n            break;\n        default:\n            throw new DecimalError(`Unsupported operation: ${operation}`);\n    }\n    // Validate and adjust if necessary\n    return validateAndAdjustPrecisionScale(result.precision, result.scale, options?.maxPrecision, options?.maxScale);\n}\n","// Decimal.ts\n// A high-precision decimal number implementation with controlled rounding behaviors\nimport { alignOperands, formatBigIntAsDecimal, roundHalfUp, ceilRound, floorRound, validatePrecisionScale, calculateRdbmsArithmeticResult, scaleUp, getPow10 } from './decimal-utils';\nexport class DecimalError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DecimalError\";\n    }\n}\nclass Decimal {\n    /**\n     * Constructs a Decimal instance by parsing the input value.\n     *\n     * Constructor behavior varies based on input type:\n     *\n     * 1. String input:\n     *    - If precision/scale not provided: Infers from string format\n     *    - If precision/scale provided: Validates and formats according to specs\n     *    Example: new Decimal(\"123.45\") or new Decimal(\"123.45\", 5, 2)\n     *\n     * 2. Decimal input (conversion):\n     *    - If precision/scale not provided: Inherits from source Decimal\n     *    - If precision/scale provided: Adjusts value to match new precision/scale\n     *    Example: new Decimal(existingDecimal) or new Decimal(existingDecimal, 5, 2)\n     *\n     * 3. Number input:\n     *    - Always requires precision and scale parameters\n     *    Example: new Decimal(123.45, 5, 2)\n     *\n     * @param value The value to initialize the Decimal with (string, number, or Decimal)\n     * @param precision The total number of significant digits (M)\n     * @param scale The number of digits after the decimal point (D)\n     * @throws {DecimalError} If value format is invalid or precision/scale constraints are violated\n     */\n    constructor(value, precision, scale) {\n        // Initialize with default values to satisfy TypeScript\n        this.coefficient = 0n;\n        this.exponent = 0;\n        // Infer or validate precision and scale based on input type\n        [precision, scale] = this.resolvePrecisionAndScale(value, precision, scale);\n        // Store the precision and scale\n        this.precision = precision;\n        this.scale = scale;\n        // Validate scale and precision relationship\n        this.validatePrecisionAndScale(precision, scale);\n        // Initialize the decimal based on the input type\n        let decimalInit;\n        if (typeof value === 'string') {\n            decimalInit = this.initFromString(value, precision, scale);\n        }\n        else if (typeof value === 'number') {\n            decimalInit = this.initFromNumber(value, precision, scale);\n        }\n        else if (value instanceof Decimal) {\n            decimalInit = this.initFromDecimal(value, precision, scale);\n        }\n        else {\n            throw new DecimalError(\"Unsupported value type for Decimal constructor.\");\n        }\n        // Assign the computed coefficient and exponent\n        this.coefficient = decimalInit.coefficient;\n        this.exponent = decimalInit.exponent;\n    }\n    /**\n     * Resolves precision and scale values based on the input type.\n     * For strings, infers from the string if not provided.\n     * For Decimal instances, inherits from source if not provided.\n     * For numbers, ensures both are provided.\n     *\n     * @private\n     */\n    resolvePrecisionAndScale(value, precision, scale) {\n        if (typeof value === 'number') {\n            if (precision === undefined || scale === undefined) {\n                throw new DecimalError(\"Precision and scale must be provided for number type.\");\n            }\n            return [precision, scale];\n        }\n        if (value instanceof Decimal) {\n            if (precision === undefined || scale === undefined) {\n                precision = value.getPrecision();\n                scale = value.getScale();\n            }\n            return [precision, scale];\n        }\n        if (typeof value === 'string') {\n            if (precision === undefined || scale === undefined) {\n                // Infer precision and scale from string\n                const regex = /^-?(\\d+)(?:\\.(\\d+))?$/;\n                const match = value.trim().match(regex);\n                if (!match) {\n                    throw new DecimalError(\"Invalid decimal string format.\");\n                }\n                const integerPart = match[1];\n                const fractionalPart = match[2] || '';\n                // Calculate precision using significant digits rules:\n                // Leading zeros in the integer part are not counted as significant\n                // For values like \"0.12345\", only count the fractional part (5 digits)\n                // For values like \"123.45\", count all digits (5 digits)\n                const trimmedInteger = integerPart.replace(/^0+/, ''); // Remove leading zeros\n                const significantIntegerDigits = trimmedInteger.length || 0;\n                precision = significantIntegerDigits + fractionalPart.length;\n                scale = fractionalPart.length;\n                // Ensure precision is at least 1 (even for value \"0\")\n                if (precision === 0) {\n                    precision = 1;\n                }\n            }\n            return [precision, scale];\n        }\n        throw new DecimalError(\"Unsupported value type for Decimal constructor.\");\n    }\n    /**\n     * Validates that scale is less than or equal to precision.\n     * @private\n     */\n    validatePrecisionAndScale(precision, scale) {\n        // Use the utility function for validation\n        const result = validatePrecisionScale(1n, precision, scale); // Coefficient doesn't matter for parameter validation\n        if (!result.valid) {\n            throw new DecimalError(result.reason || \"Invalid precision or scale\");\n        }\n    }\n    /**\n     * Initializes a Decimal from a string value.\n     * @private\n     */\n    initFromString(value, precision, scale) {\n        // Validate string format\n        if (!Decimal.isValidDecimal(value)) {\n            throw new DecimalError(\"Invalid decimal string format.\");\n        }\n        // Parse the string into components\n        const { sign, integerPart, fractionalPart } = Decimal.parseString(value);\n        // Process the fractional part with potential rounding\n        let adjustedInteger = integerPart;\n        let adjustedFractional = fractionalPart;\n        // Process rounding if needed\n        if (fractionalPart.length > scale) {\n            const rounded = Decimal.roundForDecimal(integerPart + '.' + fractionalPart, precision, scale);\n            adjustedInteger = rounded.integerPart;\n            adjustedFractional = rounded.fractionalPart;\n        }\n        else {\n            // Pad with zeros if needed\n            adjustedFractional = fractionalPart.padEnd(scale, '0');\n        }\n        // Normalize integer part by removing leading zeros\n        const normalizedInteger = adjustedInteger.replace(/^0+/, '') || '0';\n        // Combine integer and fractional parts for coefficient\n        const combined = normalizedInteger + adjustedFractional;\n        // Remove leading zeros from combined (except when value is zero)\n        const combinedNormalized = combined.replace(/^0+/, '') || '0';\n        // Calculate total digits and validate precision\n        if (combinedNormalized.length > precision) {\n            // Try rounding to fit precision at the target scale\n            const rounded = Decimal.roundForDecimal(normalizedInteger + '.' + adjustedFractional, precision, scale);\n            const roundedCombined = rounded.integerPart + rounded.fractionalPart;\n            // If after rounding the significant digits still exceed precision, throw\n            if (roundedCombined.replace(/^0+/, '').length > precision) {\n                throw new DecimalError(`Value '${value}' exceeds specified precision (${precision}) after rounding.`);\n            }\n            const coeff = BigInt(roundedCombined);\n            return {\n                coefficient: sign === '-' ? -coeff : coeff,\n                exponent: scale\n            };\n        }\n        // Convert to BigInt with sign\n        const coeff = BigInt(combinedNormalized);\n        return {\n            coefficient: sign === '-' ? -coeff : coeff,\n            exponent: scale\n        };\n    }\n    /**\n     * Initializes a Decimal from a number value.\n     * @private\n     */\n    initFromNumber(value, precision, scale) {\n        // Convert number to string and reuse string initialization logic\n        return this.initFromString(value.toString(), precision, scale);\n    }\n    /**\n     * Initializes a Decimal from an existing Decimal instance.\n     * @private\n     */\n    initFromDecimal(value, precision, scale) {\n        const fromPrecision = value.getPrecision();\n        const fromScale = value.getScale();\n        const fromCoefficient = value.getCoefficient();\n        // Calculate integer part capacity\n        const targetIntegerDigits = precision - scale;\n        // Determine actual integer digits used\n        const valueStr = value.toString();\n        const actualIntegerDigits = valueStr.split('.')[0].replace('-', '').length;\n        // Ensure integer part fits in target precision-scale\n        if (actualIntegerDigits > targetIntegerDigits) {\n            throw new DecimalError(`Cannot adjust precision: integer part needs ${actualIntegerDigits} digits, ` +\n                `but target precision-scale only allows ${targetIntegerDigits}.`);\n        }\n        // Handle scale adjustments\n        if (scale > fromScale) {\n            return this.increaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient);\n        }\n        else if (scale < fromScale) {\n            return this.decreaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient);\n        }\n        else {\n            return this.sameScaleForDecimal(value, precision, scale, fromCoefficient);\n        }\n    }\n    /**\n     * Handles increasing the scale when converting from one Decimal to another.\n     * @private\n     */\n    increaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient) {\n        // Scale increase: pad with zeros using util\n        const scaleDifference = scale - fromScale;\n        const newCoefficient = scaleUp(fromCoefficient, scaleDifference);\n        // Verify the new coefficient fits within precision\n        const newCoeffStr = newCoefficient.toString().replace('-', '');\n        if (newCoeffStr.length > precision) {\n            throw new DecimalError(`Value exceeds the specified precision (${precision}) after scaling.`);\n        }\n        return {\n            coefficient: newCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Handles decreasing the scale when converting from one Decimal to another.\n     * @private\n     */\n    decreaseScaleForDecimal(value, precision, scale, fromScale, fromCoefficient) {\n        // Scale decrease: use util roundHalfUp\n        const roundedCoefficient = roundHalfUp(fromCoefficient, fromScale, scale);\n        // Update precision to match resultant digits\n        const roundedStr = roundedCoefficient.toString().replace('-', '');\n        precision = roundedStr.length;\n        return {\n            coefficient: roundedCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Handles keeping the same scale when converting from one Decimal to another.\n     * @private\n     */\n    sameScaleForDecimal(value, precision, scale, fromCoefficient) {\n        // Same scale, just verify precision\n        if (value.getTotalDigits() > precision) {\n            throw new DecimalError(`Value exceeds the specified precision (${precision}).`);\n        }\n        return {\n            coefficient: fromCoefficient,\n            exponent: scale\n        };\n    }\n    /**\n     * Special rounding implementation specifically for the Decimal constructor.\n     * Ensures correct rounding behavior for all cases including edge cases.\n     * @private\n     */\n    static roundForDecimal(value, _precision, targetScale) {\n        // Parse into parts (positive only; sign handled by caller)\n        const [intRaw = '0', fracRaw = ''] = value.split('.');\n        const currentScale = fracRaw.length;\n        // Build coefficient (no sign)\n        const coeff = BigInt((intRaw || '0') + (fracRaw || ''));\n        // Adjust scale using canonical roundHalfUp\n        const adjusted = roundHalfUp(coeff, currentScale, targetScale);\n        // Format via canonical formatter and split\n        const formatted = formatBigIntAsDecimal(adjusted, targetScale);\n        const [integerPart, fractionalPart = ''] = formatted.split('.');\n        return { integerPart, fractionalPart };\n    }\n    /**\n     * Returns the number of significant digits (excluding sign).\n     * @private\n     */\n    getTotalDigits() {\n        return this.coefficient.toString().replace('-', '').length;\n    }\n    /**\n     * Validates if a string is a valid decimal format.\n     * @param str The string to validate.\n     * @returns True if valid, else false.\n     */\n    static isValidDecimal(str) {\n        // Trim leading/trailing whitespace\n        let trimmed = str.trim();\n        // Remove trailing 'm' if present (like \"123.45m\")\n        if (trimmed.endsWith('m')) {\n            trimmed = trimmed.slice(0, -1);\n        }\n        // Match standard decimal formats including scientific notation\n        const regex = /^[+\\-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$/;\n        return regex.test(trimmed);\n    }\n    /**\n     * Parses the string into sign, integer part, and fractional part.\n     * Handles scientific notation and normalization.\n     * @param str The string to parse.\n     * @returns An object containing sign, integerPart, and fractionalPart.\n     */\n    static parseString(str) {\n        let trimmed = str.trim();\n        // Remove trailing 'm' if present (like \"123.45m\")\n        if (trimmed.endsWith('m')) {\n            trimmed = trimmed.slice(0, -1);\n        }\n        let sign = '';\n        // Handle sign\n        if (trimmed.startsWith('-')) {\n            sign = '-';\n            trimmed = trimmed.slice(1);\n        }\n        else if (trimmed.startsWith('+')) {\n            trimmed = trimmed.slice(1);\n        }\n        // Split into mantissa and exponent parts\n        const [mantissa, exponentPart] = trimmed.split(/[eE]/);\n        const exponent = exponentPart ? parseInt(exponentPart, 10) : 0;\n        // Split mantissa into integer and fractional parts\n        const [integerPartRaw, fractionalPartRaw = ''] = mantissa.split('.');\n        let integerPart = integerPartRaw || '0';\n        let fractionalPart = fractionalPartRaw;\n        // Adjust for exponent\n        if (exponent > 0) {\n            // Positive exponent moves decimal point right\n            if (fractionalPart.length > exponent) {\n                integerPart += fractionalPart.slice(0, exponent);\n                fractionalPart = fractionalPart.slice(exponent);\n            }\n            else {\n                integerPart += fractionalPart.padEnd(exponent, '0');\n                fractionalPart = '';\n            }\n        }\n        else if (exponent < 0) {\n            // Negative exponent moves decimal point left\n            const absExp = Math.abs(exponent);\n            if (integerPart.length > absExp) {\n                fractionalPart = integerPart.slice(-absExp) + fractionalPart;\n                integerPart = integerPart.slice(0, -absExp);\n            }\n            else {\n                fractionalPart = integerPart.padStart(absExp, '0') + fractionalPart;\n                integerPart = '0';\n            }\n        }\n        return { sign, integerPart, fractionalPart };\n    }\n    /**\n     * Converts the input value to a Decimal instance.\n     * @param value The value to convert to a Decimal.\n     * @returns A Decimal instance.\n     * @throws {DecimalError} If the value cannot be converted to a Decimal.\n     */\n    static ensureDecimal(value) {\n        if (value instanceof Decimal) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            return new Decimal(value.toString());\n        }\n        if (typeof value === 'string') {\n            return new Decimal(value);\n        }\n        throw new DecimalError(`Unsupported value type for Decimal conversion: ${typeof value}`);\n    }\n    /**\n     * Converts the Decimal instance to a JavaScript Number.\n     * @returns The numeric representation.\n     * @throws {DecimalError} If the conversion results in infinity.\n     */\n    toNumber() {\n        const sign = this.coefficient < 0n ? '-' : '';\n        let absCoeffStr = (this.coefficient < 0n ? -this.coefficient : this.coefficient).toString();\n        // For integers, directly convert\n        if (this.exponent === 0) {\n            return Number(`${sign}${absCoeffStr}`);\n        }\n        // For decimals, format appropriately\n        while (absCoeffStr.length <= this.exponent) {\n            absCoeffStr = '0' + absCoeffStr;\n        }\n        const integerPart = absCoeffStr.slice(0, -this.exponent) || '0';\n        const fractionalPart = absCoeffStr.slice(-this.exponent);\n        const numberStr = `${sign}${integerPart}.${fractionalPart}`;\n        const numberValue = Number(numberStr);\n        // Safe check for overflow\n        if (!isFinite(numberValue)) {\n            throw new DecimalError(\"Conversion to Number results in Infinity.\");\n        }\n        return numberValue;\n    }\n    /**\n     * Compares this Decimal instance with another.\n     * @param other The other Decimal to compare with.\n     * @returns 1 if greater, -1 if less, 0 if equal.\n     * @throws {DecimalError} If decimals have different precision or scale.\n     */\n    compareTo(other) {\n        // Ensure same precision and scale\n        if (this.precision !== other.precision || this.scale !== other.scale) {\n            throw new DecimalError(\"Decimals must have the same precision and scale for comparison.\");\n        }\n        if (this.coefficient === other.coefficient)\n            return 0;\n        return this.coefficient > other.coefficient ? 1 : -1;\n    }\n    /**\n     * Compares the structure of this Decimal with another.\n     * The structure is defined by precision and scale.\n     * @param other The other Decimal to compare.\n     * @returns True if the structure is the same, else false.\n     */\n    compareStructure(other) {\n        return this.precision === other.precision && this.scale === other.scale;\n    }\n    /**\n     * Checks if this Decimal is equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if equal, else false.\n     */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Checks if this Decimal is less than another.\n     * @param other The other Decimal to compare with.\n     * @returns True if less, else false.\n     */\n    lessThan(other) {\n        return this.compareTo(other) === -1;\n    }\n    /**\n     * Checks if this Decimal is greater than another.\n     * @param other The other Decimal to compare with.\n     * @returns True if greater, else false.\n     */\n    greaterThan(other) {\n        return this.compareTo(other) === 1;\n    }\n    /**\n     * Checks if this Decimal is less than or equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if less than or equal, else false.\n     */\n    lessThanOrEqual(other) {\n        return this.compareTo(other) <= 0;\n    }\n    /**\n     * Checks if this Decimal is greater than or equal to another.\n     * @param other The other Decimal to compare with.\n     * @returns True if greater than or equal, else false.\n     */\n    greaterThanOrEqual(other) {\n        return this.compareTo(other) >= 0;\n    }\n    /**\n     * Returns the string representation of the Decimal.\n     * @returns The normalized string representation.\n     */\n    toString() {\n        return formatBigIntAsDecimal(this.coefficient, this.scale);\n    }\n    /**\n     * Gets the total number of significant digits.\n     * @returns The precision value.\n     */\n    getPrecision() {\n        return this.precision;\n    }\n    /**\n     * Gets the number of fractional digits.\n     * @returns The scale value.\n     */\n    getScale() {\n        return this.scale;\n    }\n    /**\n     * Gets the exponent (same as scale for this implementation).\n     * @returns The exponent value.\n     */\n    getExponent() {\n        return this.exponent;\n    }\n    /**\n     * Gets the internal coefficient (scaled integer representation).\n     * @returns The coefficient as a BigInt.\n     */\n    getCoefficient() {\n        return this.coefficient;\n    }\n    /**\n     * Gets the format pattern representing the precision and scale.\n     * @returns A string representing the format pattern (e.g., \"xxx.xx\").\n     */\n    getFormatPattern() {\n        const precision = 'x'.repeat(this.precision - this.scale);\n        const scale = 'x'.repeat(this.scale);\n        return this.scale > 0 ? `${precision}.${scale}` : `${precision}`;\n    }\n    /**\n     * Converts this Decimal to a new Decimal with the specified precision and scale.\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale\n     * @throws {DecimalError} If conversion is not possible due to precision constraints\n     */\n    convert(targetPrecision, targetScale) {\n        // Validate that the target scale doesn't exceed the target precision\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        try {\n            // Use the existing constructor logic to handle precision and scale conversion\n            return new Decimal(this, targetPrecision, targetScale);\n        }\n        catch (error) {\n            // Re-throw the error for clarity\n            if (error instanceof DecimalError) {\n                throw error;\n            }\n            // Wrap any other unexpected errors\n            throw new DecimalError(`Conversion failed: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using round-half-up behavior.\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using round-half-up\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    round(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient to the target scale\n        const roundedCoeff = roundHalfUp(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(roundedCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using ceiling behavior (always round up).\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using ceiling\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    ceil(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient using ceiling behavior\n        const ceiledCoeff = ceilRound(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(ceiledCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Rounds this Decimal to the specified precision and scale using floor behavior (always round down).\n     * @param targetPrecision The total number of significant digits (M)\n     * @param targetScale The number of digits after the decimal point (D)\n     * @returns A new Decimal with the specified precision and scale, rounded using floor\n     * @throws {DecimalError} If targetScale > targetPrecision or if parameters are invalid\n     */\n    floor(targetPrecision, targetScale) {\n        // Use the utility function\n        // Validate parameters\n        if (targetScale > targetPrecision) {\n            throw new DecimalError(\"Scale must be less than or equal to precision.\");\n        }\n        if (targetPrecision < 1) {\n            throw new DecimalError(\"Precision must be at least 1.\");\n        }\n        if (targetScale < 0) {\n            throw new DecimalError(\"Scale must be non-negative.\");\n        }\n        // Round the coefficient using floor behavior\n        const flooredCoeff = floorRound(this.coefficient, this.scale, targetScale);\n        // Format as decimal string and create new Decimal\n        const decimalStr = formatBigIntAsDecimal(flooredCoeff, targetScale);\n        return new Decimal(decimalStr, targetPrecision, targetScale);\n    }\n    /**\n     * Computes the modulo (remainder) of this Decimal by another Decimal.\n     * Uses truncation toward zero for the quotient (RDBMS-like), so the remainder has the same sign as the dividend.\n     * Result scale is max(scale1, scale2).\n     * @param other The Decimal divisor\n     * @returns A new Decimal representing (this % other)\n     */\n    mod(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        if (other.coefficient === 0n)\n            throw new DecimalError('Division by zero');\n        // Align both operands to a common scale T = max(s1, s2) without losing precision\n        const { a: aCoeff, b: bCoeff, targetScale } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale);\n        // Integer division with truncation toward zero (BigInt division semantics)\n        const q = aCoeff / bCoeff;\n        const remainderCoeff = aCoeff - q * bCoeff;\n        // Determine precision from actual digits\n        const digits = remainderCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(digits, this.precision, other.precision);\n        const resultStr = formatBigIntAsDecimal(remainderCoeff, targetScale);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n    /**\n     * Adds this Decimal to another and returns a new Decimal.\n     * The result will match the scale of the first operand (this), and will be rounded if necessary.\n     * @param other The Decimal to add.\n     * @returns A new Decimal representing the sum, rounded to this.scale.\n     */\n    /**\n * Adds this Decimal to another and returns a new Decimal.\n * The result will match the scale of the first operand (this), and will be rounded if necessary.\n * @param other The Decimal to add.\n * @returns A new Decimal representing the sum, rounded to this.scale.\n */\n    /**\n * Adds this Decimal to another and returns a new Decimal.\n * The result will match the scale of the first operand (this), and will be rounded if necessary.\n * @param other The Decimal to add.\n * @returns A new Decimal representing the sum, rounded to this.scale.\n */\n    add(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // RDBMS addition: resultScale = max(s1, s2); resultPrecision per standard\n        const { precision: calcPrecision, scale: calcScale } = calculateRdbmsArithmeticResult('add', this.precision, this.scale, other.precision, other.scale, { maxPrecision: 10000, maxScale: 10000 });\n        // Align operands to calcScale\n        const { a: aCoeff, b: bCoeff } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale, calcScale, 'round');\n        // Add aligned coefficients\n        const sumCoeff = aCoeff + bCoeff;\n        // Determine final precision: accommodate actual digits if they exceed calcPrecision\n        const digits = sumCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(calcPrecision, digits);\n        // Format and construct\n        const resultStr = formatBigIntAsDecimal(sumCoeff, calcScale);\n        return new Decimal(resultStr, finalPrecision, calcScale);\n    }\n    /**\n     * Subtracts another Decimal from this and returns a new Decimal.\n     * The result will match the scale of the first operand (this), and will be rounded if necessary.\n     * @param other The Decimal to subtract.\n     * @returns A new Decimal representing the difference, rounded to this.scale.\n     */\n    sub(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // RDBMS subtraction: use utility to determine result precision/scale\n        const { precision: calcPrecision, scale: calcScale } = calculateRdbmsArithmeticResult('subtract', this.precision, this.scale, other.precision, other.scale, { maxPrecision: 10000, maxScale: 10000 });\n        // Align operands to calcScale\n        const { a: aCoeff, b: bCoeff } = alignOperands(this.coefficient, this.scale, other.coefficient, other.scale, calcScale, 'round');\n        // Subtract aligned coefficients\n        const diffCoeff = aCoeff - bCoeff;\n        // Determine final precision: accommodate actual digits if they exceed calcPrecision\n        const digits = diffCoeff.toString().replace('-', '').length;\n        const finalPrecision = Math.max(calcPrecision, digits);\n        // Format and construct\n        const resultStr = formatBigIntAsDecimal(diffCoeff, calcScale);\n        return new Decimal(resultStr, finalPrecision, calcScale);\n    }\n    /**\n     * Multiplies this Decimal by another and returns a new Decimal.\n     * Uses utility functions for scale operations and rounding.\n     * The result scale follows RDBMS standard: max(scale1, scale2).\n     * @param other The Decimal to multiply by.\n     * @returns A new Decimal representing the product with RDBMS-compliant scale.\n     */\n    mul(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        // Multiply coefficients directly using BigInt arithmetic\n        const resultCoeff = this.coefficient * other.coefficient;\n        const intermediateScale = this.scale + other.scale;\n        // Tests expect result scale to be max(s1, s2)\n        const targetScale = Math.max(this.scale, other.scale);\n        // Adjust result to target scale\n        let adjustedCoeff = resultCoeff;\n        if (intermediateScale > targetScale) {\n            adjustedCoeff = roundHalfUp(resultCoeff, intermediateScale, targetScale);\n        }\n        else if (intermediateScale < targetScale) {\n            adjustedCoeff = scaleUp(resultCoeff, targetScale - intermediateScale);\n        }\n        // Compute appropriate precision\n        const resultDigits = adjustedCoeff.toString().replace('-', '').length;\n        let finalPrecision = Math.max(this.precision, other.precision, resultDigits);\n        if (resultDigits > finalPrecision)\n            finalPrecision = resultDigits;\n        const resultStr = formatBigIntAsDecimal(adjustedCoeff, targetScale);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n    /**\n     * Divides this Decimal by another and returns a new Decimal.\n     * The result will match the scale of the dividend (this), and will be rounded if necessary.\n     * This behavior is consistent with industry standards and ensures predictable precision.\n     * @param other The Decimal to divide by.\n     * @returns A new Decimal representing the quotient, rounded to this.scale.\n     */\n    div(other) {\n        if (!(other instanceof Decimal))\n            throw new DecimalError('Invalid operand');\n        if (other.coefficient === 0n)\n            throw new DecimalError('Division by zero');\n        // Tests expect result scale to follow the divisor's scale\n        const targetScale = other.scale;\n        // Compute numerator scaling: coeffA * 10^(targetScale + sB - sA)\n        const exponentAdjustment = targetScale + other.scale - this.scale;\n        let numerator;\n        if (exponentAdjustment >= 0) {\n            numerator = this.coefficient * getPow10(exponentAdjustment);\n        }\n        else {\n            const down = getPow10(-exponentAdjustment);\n            numerator = this.coefficient / down;\n        }\n        const denominator = other.coefficient;\n        let quotient = numerator / denominator;\n        let remainder = numerator % denominator;\n        // Round half up from remainder using the true sign of the result\n        const absDen = denominator < 0n ? -denominator : denominator;\n        const absRem = remainder < 0n ? -remainder : remainder;\n        if (absRem * 2n >= absDen) {\n            const isNegative = (numerator < 0n) !== (denominator < 0n);\n            quotient += isNegative ? -1n : 1n;\n        }\n        const resultStr = formatBigIntAsDecimal(quotient, targetScale);\n        const digits = (quotient < 0n ? (-quotient).toString() : quotient.toString()).length;\n        const finalPrecision = Math.max(this.precision, other.precision, digits);\n        return new Decimal(resultStr, finalPrecision, targetScale);\n    }\n}\nexport default Decimal;\n","import IOCollection from \"./collection\";\nimport IOObject from \"./internet-object\";\nclass IOSection {\n    constructor(data, name, _schemaName) {\n        this._data = data;\n        this._name = name;\n        this._schemaName = _schemaName;\n    }\n    get name() {\n        return this._name;\n    }\n    get schemaName() {\n        return this._schemaName;\n    }\n    get data() {\n        return this._data;\n    }\n    toJSON(options) {\n        // IOObject\n        if (this._data instanceof IOObject) {\n            return this._data.toJSON();\n        }\n        // IOCollection\n        else if (this._data instanceof IOCollection) {\n            return this._data.toJSON(options);\n        }\n        // Plain object\n        else if (this._data && typeof this._data === 'object') {\n            return this._data;\n        }\n        return null;\n    }\n}\nexport default IOSection;\n","class IOSectionCollection {\n    constructor() {\n        this._sections = [];\n        this._sectionNames = {};\n        return new Proxy(this, proxy);\n    }\n    get sections() {\n        return this._sections;\n    }\n    get length() {\n        return this._sections.length;\n    }\n    get(nameOrIndex) {\n        if (typeof nameOrIndex === 'string') {\n            const index = this._sectionNames[nameOrIndex];\n            if (index === undefined) {\n                return undefined;\n            }\n            return this._sections[index];\n        }\n        return this._sections[nameOrIndex];\n    }\n    push(section) {\n        if (section.name !== undefined) {\n            this._sectionNames[section.name] = this._sections.length;\n        }\n        this._sections.push(section);\n    }\n    /**\n     * Makes the IOSectionCollection iterable, yielding key-value pairs.\n     */\n    *[Symbol.iterator]() {\n        for (const section of this._sections) {\n            yield section;\n        }\n    }\n}\nconst proxy = {\n    get: (target, property) => {\n        if (property in target) {\n            return Reflect.get(target, property);\n        }\n        if (typeof property === 'string') {\n            if (/^[0-9]+$/.test(property)) {\n                return target.get(Number(property));\n            }\n            return target.get(property);\n        }\n    },\n    set: (target, property, value) => {\n        throw new Error('Cannot set a value on a IOSectionCollection');\n    }\n};\nexport default IOSectionCollection;\n","import InternetObjectError from \"./io-error\";\n/**\n * Represents the syntax error in InternetObject. When this error is thrwon,\n * it suggests that a syntax in the associated object is is not correct.\n */\nclass IOSyntaxError extends InternetObjectError {\n    /**\n     * Creates a new `IOSyntaxError` error.\n     * @param errorCode {string} An errorCode associated with is error\n     * @param message {string} The message which needs to be displayed\n     * @param node {Node} The node object, required while parsing raw internet-object data or schema\n     * @param ssf {Function} The start statck function, removes the irrelavant frames from the stack trace\n     *\n     * @internal\n     */\n    constructor(errorCode, fact, posRange, isEof = false, ssf) {\n        super(errorCode, fact, posRange, isEof, ssf);\n        this.name = 'InternetObject(SyntaxError)';\n        this.updateMessage();\n    }\n}\nexport default IOSyntaxError;\n","class ContainerNode {\n    constructor(type, children = []) {\n        this.type = type;\n        this.children = children;\n    }\n    toValue(defs) {\n        return this.children.map((child) => {\n            if (child) {\n                return child.toValue(defs);\n            }\n            return undefined;\n        });\n    }\n}\nexport default ContainerNode;\n","import ContainerNode from \"./containers\";\nclass ArrayNode extends ContainerNode {\n    constructor(children = [], openBracket, closeBracket) {\n        super('array', children);\n        this.openBracket = openBracket;\n        this.closeBracket = closeBracket;\n    }\n    toValue(defs) {\n        return this.children.map((child) => {\n            if (child?.toValue) { // This is a Node\n                return child.toValue(defs);\n            }\n            return child; // other non-node values such null, undefined, etc.\n        });\n    }\n    getStartPos() {\n        return this.openBracket.getStartPos();\n    }\n    getEndPos() {\n        return this.closeBracket.getEndPos();\n    }\n}\nexport default ArrayNode;\n","class MemberNode {\n    constructor(value, key) {\n        this.type = 'member';\n        this.value = value;\n        if (key) {\n            this.key = key;\n        }\n    }\n    toValue(defs) {\n        if (this.key) {\n            return {\n                [this.key.value]: this.value.toValue(defs),\n            };\n        }\n        else {\n            return this.value.toValue(defs);\n        }\n    }\n    getStartPos() {\n        if (this.key) {\n            return this.key.getStartPos();\n        }\n        return this.value.getStartPos();\n    }\n    getEndPos() {\n        if (this.value) {\n            return this.value.getEndPos();\n        }\n        if (this.key) {\n            return this.key.getEndPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n}\nexport default MemberNode;\n","import InternetObject from '../../core/internet-object';\nimport ContainerNode from './containers';\nclass ObjectNode extends ContainerNode {\n    constructor(children = [], openBracket, closeBracket) {\n        super('object', children);\n        if (openBracket) {\n            this.openBracket = openBracket;\n        }\n        if (closeBracket) {\n            this.closeBracket = closeBracket;\n        }\n    }\n    toObject(defs) {\n        const value = {};\n        let index = 0;\n        for (const child of this.children) {\n            if (child && child.value) {\n                if (child.key) {\n                    value[child.key.value] = child.value.toValue(defs);\n                }\n                else {\n                    value[index] = child.value.toValue(defs);\n                }\n            }\n            else {\n                value[index] = undefined;\n            }\n            index++;\n        }\n        return value;\n    }\n    getStartPos() {\n        if (this.openBracket) {\n            return this.openBracket.getStartPos();\n        }\n        return this.children[0]?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        if (this.closeBracket) {\n            return this.closeBracket.getEndPos();\n        }\n        return this.children[this.children.length - 1]?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    toValue(defs) {\n        const o = new InternetObject();\n        for (let i = 0; i < this.children.length; i++) {\n            const member = this.children[i];\n            if (member && member.value) {\n                if (member.key) {\n                    // o[member.key.value] = member.value.toValue(defs);\n                    o.set(member.key.value, member.value.toValue(defs));\n                }\n                else {\n                    o.set(i.toString(), member.value.toValue(defs));\n                }\n            }\n        }\n        return o;\n    }\n    // Utility Methods\n    isEmpty() {\n        return this.children.length === 0 || this.children.every(child => child === undefined);\n    }\n    toDebugString() {\n        const memberStrings = this.children.map((child, index) => {\n            if (!child)\n                return `[${index}]: undefined`;\n            const member = child;\n            const keyStr = member.key ? member.key.value : `[${index}]`;\n            const valueStr = member.value ?\n                (typeof member.value.toValue === 'function' ?\n                    JSON.stringify(member.value.toValue()) :\n                    String(member.value)) :\n                'undefined';\n            return `${keyStr}: ${valueStr}`;\n        });\n        return `ObjectNode { ${memberStrings.join(', ')} }`;\n    }\n    hasKey(key) {\n        return this.children.some(child => {\n            if (!child)\n                return false;\n            const member = child;\n            return member.key && member.key.value === key;\n        });\n    }\n    getKeys() {\n        const keys = [];\n        this.children.forEach((child, index) => {\n            if (child) {\n                const member = child;\n                if (member.key) {\n                    keys.push(member.key.value);\n                }\n                else {\n                    keys.push(index.toString());\n                }\n            }\n        });\n        return keys;\n    }\n    isValid() {\n        // An object is valid if none of its members contain ErrorNodes\n        return this.children.every(child => {\n            if (!child)\n                return true; // undefined members are considered valid\n            const member = child;\n            // Check if the member value is an ErrorNode\n            if (member.value && member.value.error !== undefined) {\n                return false;\n            }\n            // Check if the member key is an ErrorNode (though this is less common)\n            if (member.key && member.key.error !== undefined) {\n                return false;\n            }\n            return true;\n        });\n    }\n}\nexport default ObjectNode;\n","import InternetObjectError from '../errors/io-error';\nimport ErrorCodes from '../errors/io-error-codes';\nclass TypedefRegistry {\n    /**\n     * Enable/disable console warnings on duplicate type registrations.\n     * Default is disabled to avoid noise and performance overhead in hot paths/tests.\n     */\n    static setWarnOnDuplicates(enable) {\n        this.warnDuplicates = enable;\n    }\n    /**\n     * Registers TypeDef constructors for the specified types.\n     * @param typeDefConstructors The TypeDef constructor classes\n     */\n    static register(...typeDefConstructors) {\n        for (const Constructor of typeDefConstructors) {\n            for (const type of Constructor.types) {\n                if (this.typeDefMap.has(type)) {\n                    if (this.warnDuplicates && !this.warnedDuplicateTypes.has(type)) {\n                        console.warn(`TypeDef for '${type}' is already registered. Skipping.`);\n                        this.warnedDuplicateTypes.add(type);\n                    }\n                    continue;\n                }\n                this.typeDefMap.set(type, new Constructor(type));\n                this.typeNames.add(type);\n            }\n        }\n    } /**\n     * Unregisters the specified type from the registry.\n     * @param type The type name to unregister\n     */\n    static unregister(type) {\n        if (this.typeDefMap.has(type)) {\n            this.typeDefMap.delete(type);\n            this.typeNames.delete(type);\n        }\n    }\n    /**\n     * Gets the array of registered type names.\n     */\n    static get types() {\n        return Object.freeze(Array.from(this.typeNames));\n    }\n    /**\n     * Returns the associated TypeDef object for the specified type.\n     * @param type The registered type name\n     * @throws {InternetObjectError} When the type is not registered\n     */\n    static get(type) {\n        const typeDef = this.typeDefMap.get(type);\n        if (!typeDef) {\n            throw new InternetObjectError(ErrorCodes.invalidType, `Type '${type}' is not registered`);\n        }\n        return typeDef;\n    }\n    /**\n     * Checks if the specified type is registered.\n     * @param typeName The type name to check\n     */\n    static isRegisteredType(typeName) {\n        return this.typeDefMap.has(typeName);\n    }\n    /**\n     * Clears all registered types. Primarily for testing.\n     */\n    static clear() {\n        this.typeDefMap.clear();\n        this.typeNames.clear();\n        this.warnedDuplicateTypes.clear();\n    }\n    /**\n     * Gets the count of registered types.\n     */\n    static get count() {\n        return this.typeDefMap.size;\n    }\n}\nTypedefRegistry.typeDefMap = new Map();\nTypedefRegistry.typeNames = new Set();\nTypedefRegistry.warnDuplicates = false;\nTypedefRegistry.warnedDuplicateTypes = new Set();\nexport default TypedefRegistry;\n","import TypedefRegistry from '../typedef-registry';\nexport function processMember(member, memberDef, defs) {\n    const typeDef = TypedefRegistry.get(memberDef.type);\n    if (!typeDef) {\n        throw new Error(`Type ${memberDef.type} is not registered.`);\n    }\n    let valueNode = member?.value;\n    return typeDef.parse(valueNode, memberDef, defs);\n}\n","import InternetObject from '../core/internet-object';\nimport ErrorCodes from '../errors/io-error-codes';\nimport SyntaxError from '../errors/io-syntax-error';\nimport ValidationError from '../errors/io-validation-error';\nimport TokenNode from '../parser/nodes/tokens';\nimport assertNever from '../errors/asserts/asserts';\nimport Schema from './schema';\nimport { processMember } from './processing/member-processor';\n/**\n * Resolves variable references in memberDef fields like default, min, max, choices.\n * Variables are strings starting with @ that reference definitions.\n */\nfunction _resolveMemberDefVariables(memberDef, defs) {\n    if (!memberDef || !defs)\n        return memberDef;\n    const resolved = { ...memberDef };\n    // Resolve default value if it's a variable reference\n    if (typeof resolved.default === 'string' && resolved.default.startsWith('@')) {\n        resolved.default = defs.getV(resolved.default);\n        // Unwrap TokenNode if needed\n        if (resolved.default instanceof TokenNode) {\n            resolved.default = resolved.default.value;\n        }\n    }\n    // Resolve choices if they contain variable references\n    if (Array.isArray(resolved.choices)) {\n        resolved.choices = resolved.choices.map(choice => {\n            if (typeof choice === 'string' && choice.startsWith('@')) {\n                let resolved = defs.getV(choice);\n                return resolved instanceof TokenNode ? resolved.value : resolved;\n            }\n            return choice;\n        });\n    }\n    // Resolve min/max if they're variable references\n    if (typeof resolved.min === 'string' && resolved.min.startsWith('@')) {\n        resolved.min = defs.getV(resolved.min);\n        if (resolved.min instanceof TokenNode) {\n            resolved.min = resolved.min.value;\n        }\n    }\n    if (typeof resolved.max === 'string' && resolved.max.startsWith('@')) {\n        resolved.max = defs.getV(resolved.max);\n        if (resolved.max instanceof TokenNode) {\n            resolved.max = resolved.max.value;\n        }\n    }\n    return resolved;\n}\nexport default function processObject(data, schema, defs, collectionIndex) {\n    if (schema instanceof TokenNode) {\n        const schemaName = schema.value;\n        schema = defs?.getV(schemaName);\n    }\n    if (schema instanceof Schema === false) {\n        assertNever(\"Invalid schema type\");\n    }\n    return _processObject(data, schema, defs, collectionIndex);\n}\nfunction _processObject(data, schema, defs, collectionIndex) {\n    const o = new InternetObject();\n    let positional = true;\n    const processedNames = new Set();\n    // Special case: if schema has exactly one field and first data member has a key that doesn't match,\n    // treat the entire data object as the value for that single schema field\n    if (schema.names.length === 1 && data.children.length > 0) {\n        const firstMember = data.children[0];\n        if (firstMember?.key && firstMember.key.value !== schema.names[0]) {\n            const name = schema.names[0];\n            const memberDef = _resolveMemberDefVariables(schema.defs[name], defs);\n            // Create a synthetic member with the entire data ObjectNode as its value\n            const syntheticMember = { key: null, value: data };\n            const val = processMember(syntheticMember, memberDef, defs);\n            if (val !== undefined)\n                o.set(name, val);\n            return o;\n        }\n    }\n    // Process positional schema members\n    let i = 0;\n    for (; i < schema.names.length; i++) {\n        let member = data.children[i];\n        let name = schema.names[i];\n        let memberDef = _resolveMemberDefVariables(schema.defs[name], defs);\n        if (member) {\n            if (member.key) {\n                positional = false;\n                break;\n            }\n            const val = processMember(member, memberDef, defs);\n            // Only mark as processed if we actually obtained a value (or a default was applied)\n            if (val !== undefined) {\n                processedNames.add(name);\n                o.set(name, val);\n            }\n            else {\n                // If optional and no default, allow later keyed assignment without triggering duplicate-member\n                if (!memberDef.optional && memberDef.default === undefined) {\n                    // Required but undefined value  throw\n                    throw new ValidationError(ErrorCodes.valueRequired, `Expecting a value for ${memberDef.path}.`, data);\n                }\n                // Optional missing: skip adding to processedNames now so a later keyed value may fill it.\n            }\n        }\n        else {\n            // Member node entirely missing\n            if (!memberDef.optional && memberDef.default === undefined) {\n                throw new ValidationError(ErrorCodes.valueRequired, `Expecting a value for ${memberDef.path}.`, data);\n            }\n            const dummyMember = { key: null, value: undefined };\n            const val = processMember(dummyMember, memberDef, defs);\n            if (val !== undefined) {\n                processedNames.add(name);\n                o.set(name, val);\n            }\n            // If val is undefined and optional with no default, deliberately do not mark processedNames\n        }\n    }\n    // Process remaining positional members\n    if (positional) {\n        for (; i < data.children.length; i++) {\n            const member = data.children[i];\n            if (!schema.open) {\n                throw new SyntaxError(ErrorCodes.additionalValuesNotAllowed, `Additional values are not allowed in the ${schema.name}. The ${schema.name} schema is not open.`, member.value);\n            }\n            if (member.key) {\n                positional = false;\n                break;\n            }\n            const val = member.value.toValue(defs);\n            o.push(val);\n        }\n    }\n    // Process remaining keyed members\n    for (; i < data.children.length; i++) {\n        let member = data.children[i];\n        if (!member.key) {\n            throw new SyntaxError(ErrorCodes.unexpectedPositionalMember, \"Positional members must not be allowed after the keyed member is found.\", member);\n        }\n        let name = member.key.value;\n        let memberDef = _resolveMemberDefVariables(schema.defs[name], defs);\n        if (processedNames.has(name)) {\n            throw new SyntaxError(ErrorCodes.duplicateMember, `Member ${name} is already defined.`, member);\n        }\n        // When the member is not found check if the schema is open to allow\n        // additional properties. If not throw an error.\n        if (!memberDef && !schema.open) {\n            throw new SyntaxError(ErrorCodes.unknownMember, `The ${schema.name ? `${schema.name} ` : ''}schema does not define a member named '${name}'.`, member.key);\n        }\n        // In an open schema, the memberDef is not found. Use schema.open constraints if available, else type 'any'.\n        if (!memberDef && schema.open) {\n            if (typeof schema.open === 'object' && schema.open.type) {\n                memberDef = { ...schema.open, path: name };\n            }\n            else {\n                memberDef = { type: 'any', path: name };\n            }\n        }\n        processedNames.add(name);\n        const val = processMember(member, memberDef, defs);\n        o.set(name, val);\n    }\n    // Check for missing required members and if the missing member has a\n    // default value, then set the default value. Otherwise, throw an error.\n    // But before throwing an error reset the position to the data node.\n    for (const name in schema.defs) {\n        // Skip the wildcard additional property definition ('*').\n        // It's not an actual member and must not participate in required checks.\n        if (name === '*')\n            continue;\n        const memberDef = _resolveMemberDefVariables(schema.defs[name], defs);\n        if (!processedNames.has(name)) {\n            const member = data.children.find((m) => m.key?.value === name);\n            try {\n                const val = processMember(member, memberDef, defs);\n                if (val !== undefined) {\n                    o.set(name, val);\n                }\n            }\n            catch (err) {\n                if (err instanceof ValidationError) {\n                    // in case of missing member, set the position to the parent object.\n                    err.positionRange = data;\n                }\n                throw err;\n            }\n        }\n    }\n    // Fallback: if schema is open and result is empty, process all data members as type 'any' or using schema.open constraints\n    if ((schema.open === true || (typeof schema.open === 'object' && schema.open.type)) && o.isEmpty()) {\n        for (const member of data.children) {\n            if (!member)\n                continue;\n            const memberNode = member;\n            let name = memberNode.key ? memberNode.key.value : undefined;\n            if (!name)\n                continue;\n            let memberDef;\n            if (typeof schema.open === 'object' && schema.open.type) {\n                memberDef = { ...schema.open, path: name };\n            }\n            else {\n                memberDef = { type: 'any', path: name };\n            }\n            const val = processMember(memberNode, memberDef, defs);\n            o.set(name, val);\n        }\n        return o;\n    }\n    return o;\n}\n","/**\n * ErrorNode represents a parsing error that occurred during AST construction.\n * This allows the parser to continue processing and collect multiple errors\n * instead of stopping at the first error encountered.\n */\nclass ErrorNode {\n    constructor(error, position, endPosition) {\n        this.error = error;\n        this.position = position;\n        this.endPosition = endPosition;\n    }\n    /**\n     * Determines the error category based on the error type.\n     * This enables UI to apply different styling (e.g., red for syntax, orange for validation).\n     *\n     * @returns 'syntax' for parser/syntax errors, 'validation' for schema validation errors, 'runtime' for others\n     */\n    getErrorCategory() {\n        const errorName = this.error.name;\n        // Check for InternetObject error types\n        if (errorName.includes('SyntaxError')) {\n            return 'syntax';\n        }\n        if (errorName.includes('ValidationError')) {\n            return 'validation';\n        }\n        // Fallback to runtime for unknown error types\n        return 'runtime';\n    }\n    /**\n     * Returns error information as a value object.\n     * This allows ErrorNodes to be serialized alongside valid nodes.\n     * Includes error category for UI styling.\n     */\n    toValue(defs) {\n        const base = {\n            __error: true,\n            category: this.getErrorCategory(),\n            message: this.error.message,\n            name: this.error.name,\n            position: this.position,\n            ...(this.endPosition && { endPosition: this.endPosition })\n        };\n        // Include collectionIndex if the original error carries it (boundary context)\n        const anyErr = this.error;\n        if (anyErr && anyErr.collectionIndex !== undefined) {\n            base.collectionIndex = anyErr.collectionIndex;\n        }\n        return base;\n    }\n    /**\n     * Returns the starting position of the error.\n     */\n    getStartPos() {\n        return this.position;\n    }\n    /**\n     * Returns the ending position of the error.\n     * If no end position was provided, returns the start position.\n     */\n    getEndPos() {\n        return this.endPosition || this.position;\n    }\n}\nexport default ErrorNode;\n","import TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../schema';\nexport class SchemaResolver {\n    static resolve(schema, defs) {\n        if (schema instanceof TokenNode) {\n            const schemaName = schema.value;\n            // Match existing behavior: defer to definitions.getV for resolution and error semantics\n            const resolved = defs?.getV(schemaName);\n            if (!(resolved instanceof Schema)) {\n                // Safety net; typically getV would throw for missing/invalid refs\n                throw new Error(`Schema '${schemaName}' not found or invalid`);\n            }\n            return resolved;\n        }\n        return schema;\n    }\n    static isSchemaVariable(value) {\n        return value instanceof TokenNode && typeof value.value === 'string' && value.value.startsWith('$');\n    }\n}\n","import Collection from '../../core/collection';\nimport ErrorNode from '../../parser/nodes/error';\nimport processObject from '../object-processor';\nimport { SchemaResolver } from '../utils/schema-resolver';\nexport default function processCollection(data, schema, defs, errorCollector) {\n    // Pre-resolve schema once for better performance\n    const resolvedSchema = SchemaResolver.resolve(schema, defs);\n    // Pre-allocate collection with known size\n    const collection = new Collection();\n    const length = data.children.length;\n    // Process items; include ErrorNode so UI can surface error info objects\n    for (let i = 0; i < length; i++) {\n        const item = data.children[i];\n        // If parsing produced an ErrorNode, preserve it in the collection\n        // so that downstream consumers (toJSON/UI) can render error info.\n        // NOTE: Parser errors are already in document._errors, so we don't add them to errorCollector.\n        if (item instanceof ErrorNode) {\n            // Push ErrorNode directly; IOCollection.toJSON handles toValue()\n            // which serializes error details with positions.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            // Also annotate the underlying error with collectionIndex for consistency\n            try {\n                item.error.collectionIndex = i;\n            }\n            catch { }\n            collection.push(item);\n        }\n        else {\n            try {\n                collection.push(processObject(item, resolvedSchema, defs, i));\n            }\n            catch (error) {\n                // Validation error occurred - convert to ErrorNode and collect the error\n                if (error instanceof Error) {\n                    // Attach boundary context for downstream serializers/UI\n                    error.collectionIndex = i;\n                    const errorNode = new ErrorNode(error, item.getStartPos(), item.getEndPos());\n                    // Add validation error to error collector if provided\n                    if (errorCollector) {\n                        errorCollector.push(error);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    collection.push(errorNode);\n                }\n                else {\n                    // Re-throw non-Error exceptions\n                    throw error;\n                }\n            }\n        }\n    }\n    return collection;\n}\n","import Collection from \"../../core/collection\";\nimport ContainerNode from \"./containers\";\nclass CollectionNode extends ContainerNode {\n    constructor(children = []) {\n        super('collection', children);\n    }\n    toValue(defs) {\n        const value = new Collection();\n        for (const child of this.children) {\n            value.push(child?.toValue(defs));\n        }\n        return value;\n    }\n    getStartPos() {\n        return this.children[0]?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        return this.children[this.children.length - 1]?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    // Utility Methods\n    isEmpty() {\n        return this.children.length === 0 || this.children.every(child => child === undefined);\n    }\n    toDebugString() {\n        const itemStrings = this.children.map((child, index) => {\n            if (!child)\n                return `[${index}]: undefined`;\n            const valueStr = typeof child.toValue === 'function' ?\n                JSON.stringify(child.toValue()) :\n                String(child);\n            return `[${index}]: ${valueStr}`;\n        });\n        return `CollectionNode { ${itemStrings.join(', ')} }`;\n    }\n    size() {\n        return this.children.length;\n    }\n    hasValidItems() {\n        return this.children.some(child => {\n            if (!child)\n                return true; // undefined items are valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true; // Valid item found\n        });\n    }\n    getValidItems() {\n        return this.children.filter((child) => {\n            if (!child)\n                return true; // undefined items are valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true; // Valid item\n        });\n    }\n    isValid() {\n        // A collection is valid if none of its items are ErrorNodes\n        return this.children.every(child => {\n            if (!child)\n                return true; // undefined items are considered valid\n            // Check if the child is an ErrorNode\n            if (child.error !== undefined) {\n                return false;\n            }\n            return true;\n        });\n    }\n}\nexport default CollectionNode;\n","import CollectionNode from '../../parser/nodes/collections';\nimport ObjectNode from '../../parser/nodes/objects';\nimport TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../schema';\nexport class ValidationUtils {\n    static isValidDataNode(data) {\n        return data instanceof ObjectNode || data instanceof CollectionNode;\n    }\n    static isValidSchema(schema) {\n        return schema instanceof Schema || schema instanceof TokenNode;\n    }\n    static validateProcessingInputs(data, schema) {\n        if (!ValidationUtils.isValidDataNode(data)) {\n            const hasCtorName = data?.constructor?.name;\n            const typeName = data === null ? 'null'\n                : data === undefined ? 'undefined'\n                    : hasCtorName === undefined ? 'undefined'\n                        : hasCtorName || 'unknown';\n            throw new Error(`Invalid data node type: ${typeName}`);\n        }\n        if (!ValidationUtils.isValidSchema(schema)) {\n            const hasCtorName = schema?.constructor?.name;\n            const typeName = schema === null ? 'null'\n                : schema === undefined ? 'undefined'\n                    : hasCtorName === undefined ? 'undefined'\n                        : hasCtorName || 'unknown';\n            throw new Error(`Invalid schema type: ${typeName}`);\n        }\n        return { data: data, schema: schema };\n    }\n}\nexport class ProcessingResult {\n    constructor(success, data, error) {\n        this.success = success;\n        this.data = data;\n        this.error = error;\n        Object.freeze(this); // ensure immutability at runtime\n    }\n    static success(data) {\n        return new ProcessingResult(true, data);\n    }\n    static failure(error) {\n        return new ProcessingResult(false, undefined, error);\n    }\n    isSuccess() {\n        return this.success;\n    }\n}\n","import ObjectNode from '../parser/nodes/objects';\nimport processObject from './object-processor';\nimport processCollection from './processing/collection-processor';\nimport { ValidationUtils } from './utils/validation-utils';\nexport default function processSchema(data, schema, defs, errorCollector) {\n    // Early return for null data\n    if (data === null) {\n        return null;\n    }\n    // Validate inputs\n    const { data: validData, schema: validSchema } = ValidationUtils.validateProcessingInputs(data, schema);\n    // Route to appropriate processor\n    if (validData instanceof ObjectNode) {\n        return processObject(validData, validSchema, defs);\n    }\n    // Must be CollectionNode at this point due to validation\n    return processCollection(validData, validSchema, defs, errorCollector);\n}\n","import ErrorCodes from '../../errors/io-error-codes';\nimport InternetObjectValidationError from '../../errors/io-validation-error';\nimport TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\n/**\n * Performs the common validations required before serialization and deserialization\n * @param memberDef The memberDef object\n * @param value The value which needs to be validated\n * @param node The node object, required for tracing line and column when parsing raw internet object code!\n * @param defs Optional definitions for resolving references\n * @param equalityComparator Optional callback for type-specific equality comparison in choices validation\n *\n * @internal\n */\nfunction doCommonTypeCheck(memberDef, value, node, defs, equalityComparator) {\n    const isUndefined = value === undefined || value instanceof TokenNode && value.type === TokenType.UNDEFINED;\n    const isNull = node instanceof TokenNode ? node.value === null : value === null;\n    // Check for undefined\n    if (isUndefined) {\n        if (memberDef.default !== undefined) {\n            // Two-stage dereferencing: defs passed for schema compilation runtime,\n            // but variables already resolved in processObject for data processing runtime\n            return { value: _default(memberDef.default, defs), changed: true };\n        }\n        if (memberDef.optional)\n            return { value: undefined, changed: true };\n        throw new InternetObjectValidationError(..._valueRequired(memberDef, node));\n    }\n    // Check for null\n    if (isNull) {\n        if (memberDef.null)\n            return { value: null, changed: true };\n        const msg = `Null is not allowed for ${memberDef.path}`;\n        throw new InternetObjectValidationError(ErrorCodes.nullNotAllowed, msg, node);\n    }\n    value = (typeof value === 'object' && value.toValue) ? value.toValue(defs) : value;\n    // Validate choices\n    if (memberDef.choices !== undefined) {\n        let val = value instanceof TokenNode ? value.value : value;\n        let found = false;\n        for (let choice of memberDef.choices) {\n            if (typeof choice === 'string' && choice[0] === '@') {\n                choice = defs?.getV(choice);\n                choice = choice instanceof TokenNode ? choice.value : choice;\n            }\n            // Use custom equality comparator if provided, otherwise use simple equality\n            const isEqual = equalityComparator ? equalityComparator(val, choice) : val === choice;\n            if (isEqual) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new InternetObjectValidationError(..._invlalidChoice(memberDef, value, node));\n        }\n    }\n    // If everything is okay, return same data\n    return { value: value, changed: false };\n}\n/**\n * Processes default values with two-stage variable dereferencing:\n * 1. Schema compilation runtime: Resolves variables when validating MemberDef constraints\n * 2. Data processing runtime: Variables already resolved by _resolveMemberDefVariables in processObject\n *\n * Also handles TokenNode unwrapping and string literal conversions (N, T, F).\n */\nfunction _default(value, defs) {\n    // Unwrap TokenNode and resolve variables if present\n    if (value instanceof TokenNode) {\n        // If it's a variable/schema reference, resolve it (schema compilation runtime)\n        if (typeof value.value === 'string' && value.value.startsWith('@') && defs) {\n            value = defs.getV(value);\n            // Unwrap TokenNode if getV returned one\n            value = value instanceof TokenNode ? value.value : value;\n        }\n        else {\n            value = value.value;\n        }\n    }\n    // Resolve variable references in plain strings (data processing runtime fallback)\n    if (typeof value === 'string' && value.startsWith('@') && defs) {\n        value = defs.getV(value);\n        // Unwrap TokenNode if getV returned one\n        value = value instanceof TokenNode ? value.value : value;\n    }\n    // Convert string literals\n    if (typeof value === 'string') {\n        if (value === 'N')\n            return null;\n        if (value === 'T' || value === 'true')\n            return true;\n        if (value === 'F' || value === 'false')\n            return false;\n    }\n    return value;\n}\nfunction _valueRequired(memberDef, node) {\n    const msg = `Value is required for ${memberDef.path}`;\n    return [ErrorCodes.valueRequired, msg, node];\n}\nfunction _nullNotAllowed(memberDef, node) {\n    return [ErrorCodes.nullNotAllowed, `${memberDef.path} does not support null.`, node];\n}\n// Return an invalid choice error parameters\nfunction _invlalidChoice(memberDef, value, node) {\n    if (!memberDef.choices)\n        throw Error('Choices not checked during NumberDef implementation.');\n    value = value.toValue\n        ? value.toValue()\n        : value.toObject\n            ? value.toObject()\n            : value;\n    value = JSON.stringify(value);\n    let msg = `The value of \"${memberDef.path}\" must be one of the [${memberDef.choices.join(', ')}]. Currently it is ${value}.`;\n    if (memberDef.choices.length === 1) {\n        msg = `The value of \"${memberDef.path}\" must be '${memberDef.choices[0]}'. Currently it is ${value}.`;\n    }\n    return [ErrorCodes.invalidChoice, msg, node];\n}\nexport default doCommonTypeCheck;\n","import ErrorCodes from '../../errors/io-error-codes';\nimport InternetObjectError from '../../errors/io-error';\nimport ValidationError from '../../errors/io-validation-error';\nimport MemberNode from '../../parser/nodes/members';\nimport { getMemberDef } from '../../schema/compile-object';\nimport Schema from '../../schema/schema';\nimport TypedefRegistry from '../../schema/typedef-registry';\nimport doCommonTypeCheck from './common-type';\nconst of = { type: \"any\", __memberdef: true };\nconst schema = new Schema(\"any\", { type: { type: \"string\", optional: false, null: false, choices: [\"any\"] } }, { default: { type: \"any\", optional: true, null: true } }, { choices: { type: \"array\", optional: true, null: false } }, { anyOf: { type: \"array\", optional: true, null: false, of } }, { isSchema: { type: \"bool\", optional: true, null: false, default: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nexport default class AnyDef {\n    get type() { return 'any'; }\n    get schema() { return schema; }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        const anyOf = memberDef.anyOf;\n        if (!anyOf) {\n            if (memberDef.__memberdef) { // Convert to memberDef\n                const md = getMemberDef(new MemberNode(node), \"\", defs);\n                return md;\n            }\n            return value;\n        }\n        const errors = [];\n        for (let i = 0; i < anyOf.length; i++) {\n            const def = anyOf[i];\n            def.path = memberDef.path;\n            const typeDef = TypedefRegistry.get(def.type);\n            if (!typeDef) {\n                throw new InternetObjectError(ErrorCodes.invalidType, `Invalid type definition '${def.type}'`);\n            }\n            try {\n                return typeDef.parse(node, def, defs);\n            }\n            catch (e) {\n                errors.push(e);\n                continue;\n            }\n        }\n        // None of the types matched\n        if (errors.length === anyOf.length) {\n            throw new ValidationError(ErrorCodes.invalidValue, `None of the constraints defined for '${memberDef.path}' matched.`, node);\n        }\n        return valueNode;\n    }\n    static get types() { return ['any']; }\n}\n","import assertNever from '../../errors/asserts/asserts';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport ArrayNode from '../../parser/nodes/array';\nimport Schema from '../../schema/schema';\nimport TypedefRegistry from '../../schema/typedef-registry';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"array\", { type: { type: \"string\", optional: false, null: false, choices: [\"array\"] } }, { default: { type: \"array\", optional: true, null: false } }, { of: { type: \"any\", optional: true, null: false, __memberdef: true } }, { len: { type: \"number\", optional: true, null: false, min: 0 } }, { minLen: { type: \"number\", optional: true, null: false, min: 0 } }, { maxLen: { type: \"number\", optional: true, null: false, min: 0 } });\nclass ArrayDef {\n    constructor() {\n        this.parse = (valueNode, memberDef, defs) => {\n            return _processNode(valueNode, memberDef, defs);\n        };\n    }\n    get type() { return 'array'; }\n    get schema() { return schema; }\n    static get types() { return ['array']; }\n}\nfunction _processNode(node, memberDef, defs) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof ArrayNode === false) {\n        throw new ValidationError(ErrorCodes.notAnArray, `Expecting an array value for '${memberDef.path}'`, node);\n    }\n    // Find the right typeDef\n    let typeDef;\n    let arrayMemberDef = {\n        type: 'any'\n    };\n    if (memberDef.of instanceof Schema) {\n        typeDef = TypedefRegistry.get('object');\n        arrayMemberDef.schema = memberDef.of;\n        arrayMemberDef.path = memberDef.path;\n    }\n    else if (memberDef.of?.type) {\n        typeDef = TypedefRegistry.get(memberDef.of.type);\n        if (!typeDef) {\n            throw new ValidationError(ErrorCodes.invalidType, `Invalid type definition '${memberDef.of.type}'`, node);\n        }\n        arrayMemberDef = memberDef.of;\n        arrayMemberDef.path = memberDef.path;\n    }\n    else if (typeof memberDef.of === 'string') {\n        assertNever(memberDef.of);\n    }\n    else {\n        typeDef = TypedefRegistry.get('any');\n    }\n    const array = [];\n    valueNode.children.forEach((item) => {\n        // If it is a definition\n        if (valueNode !== node) {\n            try {\n                array.push(typeDef?.parse(item, arrayMemberDef, defs));\n            }\n            catch (err) {\n                // Before rethrowing the error, change the position of the error to\n                // the original node.\n                if (err instanceof ValidationError) {\n                    err.positionRange = node;\n                }\n                throw err;\n            }\n        }\n        else {\n            array.push(typeDef?.parse(item, arrayMemberDef, defs));\n        }\n    });\n    // Validate length constraints\n    const arrayLength = array.length;\n    if (memberDef.len !== undefined && arrayLength !== memberDef.len) {\n        throw new ValidationError(ErrorCodes.invalidLength, `The \"${memberDef.path || 'array'}\" must have exactly ${memberDef.len} items, but has ${arrayLength}.`, valueNode);\n    }\n    if (memberDef.minLen !== undefined && arrayLength < memberDef.minLen) {\n        throw new ValidationError(ErrorCodes.outOfRange, `The \"${memberDef.path || 'array'}\" must have at least ${memberDef.minLen} items, but has ${arrayLength}.`, valueNode);\n    }\n    if (memberDef.maxLen !== undefined && arrayLength > memberDef.maxLen) {\n        throw new ValidationError(ErrorCodes.outOfRange, `The \"${memberDef.path || 'array'}\" must have at most ${memberDef.maxLen} items, but has ${arrayLength}.`, valueNode);\n    }\n    return array;\n}\nfunction _invlalidChoice(key, token, min) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be greater than or equal to ${min}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nfunction _invlalidLength(key, token, length) {\n    const actualLength = token instanceof ArrayNode ? token.children.length : 0;\n    return [\n        ErrorCodes.invalidLength,\n        `The \"${key}\" must be ${length}, Currently it is ${actualLength}.`,\n        token\n    ];\n}\nfunction _invlalidMinLength(key, token, min) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be greater than or equal to ${min}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nfunction _invlalidMaxLength(key, token, max) {\n    return [\n        ErrorCodes.outOfRange,\n        `The \"${key}\" must be less than or equal to ${max}, Currently it is \"${token.value}\".`,\n        token\n    ];\n}\nexport default ArrayDef;\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BooleanDef_instances, _BooleanDef_validate;\nimport ValidationError from '../../errors/io-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../../schema/schema';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"bool\", { type: { type: \"string\", optional: false, null: false, choices: [\"bool\"] } }, { default: { type: \"bool\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nclass BooleanDef {\n    constructor() {\n        _BooleanDef_instances.add(this);\n    }\n    get type() { return 'bool'; }\n    get schema() { return schema; }\n    parse(node, memberDef, defs) {\n        return __classPrivateFieldGet(this, _BooleanDef_instances, \"m\", _BooleanDef_validate).call(this, node, memberDef, defs);\n    }\n    // Load: JS Value  Validated JS Value\n    load(value, memberDef, defs) {\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value);\n        if (changed)\n            return checkedValue;\n        if (typeof value !== 'boolean') {\n            throw new ValidationError(ErrorCodes.notABool, `Expecting a boolean value for '${memberDef.path}' but found ${JSON.stringify(value)}.`);\n        }\n        return value;\n    }\n    // Stringify with validation\n    stringify(value, memberDef) {\n        this.load(value, memberDef);\n        return value ? 'T' : 'F';\n    }\n    static get types() { return ['bool']; }\n}\n_BooleanDef_instances = new WeakSet(), _BooleanDef_validate = function _BooleanDef_validate(node, memberDef, defs) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof TokenNode === false || valueNode.type !== TokenType.BOOLEAN) {\n        throw new ValidationError(ErrorCodes.notABool, `Expecting a boolean value for '${memberDef.path}' but found ${valueNode.toValue()}.`, node);\n    }\n    return valueNode.value;\n};\nexport default BooleanDef;\n","export const datetimeExp = {\n    // https://regex101.com/r/v1YLhA/2\n    datetime: /^(?<dt>(?<year>\\d{4})(?:\\-(?<month>(?:1[0-2]|0[1-9]))(?:\\-(?<date>[0-2][0-9]|3[0-1]))?)?(T(?<hour>[0-1][0-9]|2[0-3])(?:\\:(?<minute>[0-5][0-9])(?:\\:(?<sec>[0-5][0-9])(?:\\.(?<milisecond>(?:\\d{3})+))?)?)?)?(?<tz>(Z)|((?:\\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:\\:[0-5][0-9])?)))?)$/,\n    // https://regex101.com/r/yXu5MC/2\n    date: /^(?<year>\\d{4})(?:\\-(?<month>(?:1[0-2]|0[1-9]))(?:\\-(?<date>[0-2][0-9]|3[0-1]))?)?$/,\n    // https://regex101.com/r/hbiNMv/4\n    time: /^(?<hour>[0-1][0-9]|2[0-3])(?:\\:(?<minute>[0-5][0-9])(?:\\:(?<second>[0-5][0-9])(?:\\.(?<milisecond>(?:\\d{3})+))?)?)?$/\n};\nexport const datetimePlainExp = {\n    // https://regex101.com/r/0j7nlS/3\n    // Note: Since this expression starts with ^ and does not end with $, it will\n    // ignore any characters after the valid datetime format.\n    // Unlike regular datetime expressions, this won't complain about the invalid\n    // datetime format if the expression finds invalid characters after the\n    // valid datetime format. For example, 20200101000000000Zabc will be\n    // considered as a valid datetime format with 'abc' ignored.\n    // This is required because, putting $ at the end of the expression will\n    // cause it to pick up invalid groups from the datetime string.\n    datetime: /^(?<year>\\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?(?:(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\\d{3})+))?)?)?)?(?<tz>(Z)|((?:\\+|-)(?:(?:[0-1][0-9]|2[0-3])(?:[0-5][0-9])?)))?/,\n    // https://regex101.com/r/VDkmzU/2\n    date: /^(?<year>\\d{4})(?:(?<month>(?:1[0-2]|0[1-9]))(?:(?<date>[0-2][0-9]|3[0-1]))?)?$/,\n    // https://regex101.com/r/X5AA4A/3\n    time: /^(?<hour>[0-1][0-9]|2[0-3])(?:(?<minute>[0-5][0-9])(?:(?<second>[0-5][0-9])(?:(?<milisecond>(?:\\d{3})+))?)?)?$/\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted datetime. Returns null when the invalid datetime\n * is found.\n */\nexport const parseDateTime = (value) => {\n    // If the first 6 characters contain '-', it is regular datetime format.\n    // Otherwise, it is plain datetime format (no separator)\n    const exp = /[\\-\\:]/.test(value.substring(0, 6)) ? datetimeExp.datetime : datetimePlainExp.datetime;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { year, month, date, hour, minute, second, milisecond, tz } = match.groups || {};\n    const utc = tz ? tz : 'Z';\n    const dateStr = `${year}-${month || '01'}-${date || '01'}T${hour || '00'}:${minute || '00'}:${second || '00'}.${milisecond || '000'}${utc}`;\n    return new Date(dateStr);\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted date. Returns null when the invalid date\n * is found.\n */\nexport const parseDate = (value) => {\n    const exp = /\\-/.test(value.substring(0, 5)) ? datetimeExp.date : datetimePlainExp.date;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { year, month, date } = match.groups || {};\n    const dateStr = `${year}-${month || '01'}-${date || '01'}T00:00:00.000Z`;\n    return new Date(dateStr);\n};\n/**\n * Parses the value string and returns the datetime if the string represents\n * the ISO 8601 formatted time. Returns null when the invalid time\n * is found.\n */\nexport const parseTime = (value) => {\n    const exp = /\\:/.test(value.substring(0, 3)) ? datetimeExp.time : datetimePlainExp.time;\n    const match = exp.exec(value);\n    if (!match) {\n        return null;\n    }\n    const { hour, minute, second, milisecond } = match.groups || {};\n    const dateStr = `1900-01-01T${hour || '00'}:${minute || '00'}:${second || '00'}.${milisecond ? milisecond : '000'}Z`;\n    return new Date(dateStr);\n};\nexport const dateToDatetimeString = (date, noSep = false, zuluTime = false) => {\n    if (date === null)\n        return null;\n    return date.toISOString();\n};\nexport const dateToDateString = (date, noSep = false) => {\n    if (date === null)\n        return null;\n    // Convert the date to iso string and return the date part\n    return date.toISOString().split('T')[0];\n};\nexport const dateToTimeString = (date, noSep = false) => {\n    if (date === null)\n        return null;\n    // Convert the date to iso string and return the time part\n    // without the timezone\n    return date.toISOString().split('T')[1].split('.')[0];\n};\nconst _ = (n, pad = 2) => {\n    return n.toLocaleString('en-US', { minimumIntegerDigits: pad, useGrouping: false });\n};\nexport const dateToSmartString = (date, type, noSep = false) => {\n    if (date === null)\n        return null;\n    switch (type) {\n        case \"datetime\":\n            return dateToDatetimeString(date, noSep);\n        case \"date\":\n            return dateToDateString(date, noSep);\n        case \"time\":\n            return dateToTimeString(date, noSep);\n    }\n};\nexport const dateToIOString = (date, type, noSep = false) => {\n    if (date === null)\n        return \"N\";\n    switch (type) {\n        case \"datetime\":\n            return `dt\"${dateToDatetimeString(date, noSep)}\"`;\n        case \"date\":\n            return `d\"${dateToDateString(date, noSep)}\"`;\n        case \"time\":\n            return `t\"${dateToTimeString(date, noSep)}\"`;\n    }\n};\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _DateTimeDef_instances, _DateTimeDef_type, _DateTimeDef_normalizeToDate, _DateTimeDef_dateTimeEqualityComparator, _DateTimeDef_validate;\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport TokenNode from '../../parser/nodes/tokens';\nimport Schema from '../../schema/schema';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport * as dt from '../../utils/datetime';\nimport doCommonTypeCheck from './common-type';\nconst DATETIME_TYPES = ['datetime', 'date', 'time'];\nconst schema = new Schema(\"datetime\", { type: { type: \"string\", optional: false, null: false, choices: DATETIME_TYPES } }, { default: { type: \"datetime\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"datetime\" } } }, { min: { type: \"datetime\", optional: true, null: false } }, { max: { type: \"datetime\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\nclass DateTimeDef {\n    get type() { return __classPrivateFieldGet(this, _DateTimeDef_type, \"f\"); }\n    get schema() { return schema; }\n    constructor(type = 'datetime') {\n        _DateTimeDef_instances.add(this);\n        _DateTimeDef_type.set(this, void 0);\n        _DateTimeDef_normalizeToDate.set(this, (v, defs) => {\n            if (!v)\n                return undefined;\n            // Already a Date instance (min/max from schema are already Date objects)\n            if (v instanceof Date)\n                return v;\n            // Resolve TokenNode to underlying value\n            if (v instanceof TokenNode) {\n                if (v.value instanceof Date)\n                    return v.value;\n                // Try resolving through definitions\n                if (defs) {\n                    const resolved = defs.getV(v);\n                    if (resolved instanceof Date)\n                        return resolved;\n                    if (resolved instanceof TokenNode && resolved.value instanceof Date)\n                        return resolved.value;\n                }\n            }\n            // If wrapper exposes toValue(defs)\n            if (typeof v === 'object' && typeof v.toValue === 'function') {\n                const resolved = v.toValue(defs);\n                return __classPrivateFieldGet(this, _DateTimeDef_normalizeToDate, \"f\").call(this, resolved, defs);\n            }\n            return undefined;\n        });\n        _DateTimeDef_dateTimeEqualityComparator.set(this, (value, choice) => {\n            const valDate = value instanceof Date ? value : undefined;\n            const choiceDate = __classPrivateFieldGet(this, _DateTimeDef_normalizeToDate, \"f\").call(this, choice);\n            if (!valDate || !choiceDate)\n                return false;\n            return valDate.getTime() === choiceDate.getTime();\n        });\n        __classPrivateFieldSet(this, _DateTimeDef_type, type, \"f\");\n    }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs, __classPrivateFieldGet(this, _DateTimeDef_dateTimeEqualityComparator, \"f\"));\n        if (changed)\n            return value;\n        if (valueNode.type !== TokenType.DATETIME) {\n            throw new ValidationError(ErrorCodes.invalidDateTime, `Expecting a ${memberDef.type.toUpperCase()} value for ${memberDef.path}, currently ${valueNode.value}, a ${valueNode.type} value`, node);\n        }\n        // Validate the value\n        __classPrivateFieldGet(this, _DateTimeDef_instances, \"m\", _DateTimeDef_validate).call(this, value, memberDef, node, defs);\n        return value;\n    }\n    load(value, memberDef, defs) {\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value, undefined, defs, __classPrivateFieldGet(this, _DateTimeDef_dateTimeEqualityComparator, \"f\"));\n        if (changed)\n            return checkedValue;\n        // Type validation - must be a Date object\n        if (!(value instanceof Date)) {\n            throw new ValidationError(ErrorCodes.invalidType, `Expecting a Date object for '${memberDef.path}', got ${typeof value}`);\n        }\n        // Validate constraints\n        __classPrivateFieldGet(this, _DateTimeDef_instances, \"m\", _DateTimeDef_validate).call(this, value, memberDef, undefined, defs);\n        return value;\n    }\n    stringify(value) {\n        return dt.dateToIOString(value, __classPrivateFieldGet(this, _DateTimeDef_type, \"f\"));\n    }\n    static get types() { return DATETIME_TYPES; }\n}\n_DateTimeDef_type = new WeakMap(), _DateTimeDef_normalizeToDate = new WeakMap(), _DateTimeDef_dateTimeEqualityComparator = new WeakMap(), _DateTimeDef_instances = new WeakSet(), _DateTimeDef_validate = function _DateTimeDef_validate(value, memberDef, node, defs) {\n    const dateType = memberDef.type;\n    if (memberDef.min) {\n        const min = __classPrivateFieldGet(this, _DateTimeDef_normalizeToDate, \"f\").call(this, memberDef.min, defs);\n        if (min && value < min) {\n            throw new ValidationError(ErrorCodes.outOfRange, `Expecting the value ${memberDef.path ? `for '${memberDef.path}'` : ''} to be greater than or equal to '${dt.dateToSmartString(min, dateType)}'`, node);\n        }\n    }\n    if (memberDef.max) {\n        const max = __classPrivateFieldGet(this, _DateTimeDef_normalizeToDate, \"f\").call(this, memberDef.max, defs);\n        if (max && value > max) {\n            throw new ValidationError(ErrorCodes.outOfRange, `Expecting the value ${memberDef.path ? `for '${memberDef.path}'` : ''} to be less than or equal to '${dt.dateToSmartString(max, dateType)}'`, node);\n        }\n    }\n};\nexport default DateTimeDef;\n","import ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\n/**\n * All supported number types\n */\nexport const NUMBER_TYPES = [\n    'bigint', 'decimal',\n    'int', 'uint', 'float', 'number',\n    'int8', 'int16', 'int32',\n    'uint8', 'uint16', 'uint32', 'uint64',\n    'float32', 'float64' // Floating point number types\n];\n/**\n * Map for quick type lookup\n */\nexport const NUMBER_MAP = NUMBER_TYPES.reduce((acc, type) => {\n    acc[type] = true;\n    return acc;\n}, {});\n/**\n * Helper function for throwing validation errors\n */\nexport function throwError(code, memberPath, value, node) {\n    // Generate appropriate error message based on error code\n    let message;\n    switch (code) {\n        case ErrorCodes.invalidType:\n            message = `The '${memberPath}' has an invalid type. ${value}`;\n            break;\n        case ErrorCodes.invalidRange:\n            message = `The '${memberPath}' must be within the specified range, Currently it is ${value}.`;\n            break;\n        case ErrorCodes.invalidScale:\n            message = `The '${memberPath}' has an invalid scale. ${value}`;\n            break;\n        case ErrorCodes.invalidPrecision:\n            message = `The '${memberPath}' has an invalid precision. ${value}`;\n            break;\n        default:\n            message = `The '${memberPath}' validation failed. ${value}`;\n    }\n    throw new ValidationError(code, message, node);\n}\n/**\n * Get the number of integer digits in a decimal\n */\nexport function getIntegerDigits(decimal) {\n    const valueStr = decimal.toString();\n    return valueStr.split('.')[0].replace('-', '').length;\n}\n","import ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, NUMBER_MAP, throwError } from './common-number';\nconst bigintSchema = new Schema(\"bigint\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"bigint\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"bigint\" } } }, { min: { type: \"bigint\", optional: true, null: false } }, { max: { type: \"bigint\", optional: true, null: false } }, { multipleOf: { type: \"bigint\", optional: true, null: false } }, { format: { type: \"string\", optional: true, null: false, choices: [\"decimal\", \"hex\", \"octal\", \"binary\"], default: \"decimal\" } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * BigInt type definition\n *\n * @internal\n */\nclass BigIntDef {\n    constructor() {\n        this._type = 'bigint';\n    }\n    get type() { return this._type; }\n    get schema() { return bigintSchema; }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        const rawValue = typeof valueNode?.toValue === 'function' ? valueNode.toValue(defs) : valueNode;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        value = this.validate(memberDef, value, node);\n        return value;\n    }\n    load(value, memberDef, defs) {\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value);\n        if (changed)\n            return checkedValue;\n        return this.validate(memberDef, value);\n    }\n    stringify(value, memberDef) {\n        // Validate before stringifying\n        this.validate(memberDef, value);\n        if (memberDef.format === 'hex') {\n            return value.toString(16);\n        }\n        if (memberDef.format === 'octal') {\n            return value.toString(8);\n        }\n        if (memberDef.format === 'binary') {\n            return value.toString(2);\n        }\n        return value.toString();\n    }\n    /**\n     * Validates bigint value\n     */\n    validate(memberDef, value, node) {\n        const valueType = typeof value === \"bigint\" ? \"bigint\" : NUMBER_MAP[typeof value] ? \"number\" : \"\";\n        if (valueType === \"\") {\n            throw new ValidationError(ErrorCodes.invalidType, `Expecting a value of type '${memberDef.type}' for '${memberDef.path}'`, node);\n        }\n        if (valueType !== \"bigint\") {\n            throw new ValidationError(`not-a-${memberDef.type}`, `Invalid value encountered for '${memberDef.path}'`, node);\n        }\n        const { min, max, multipleOf } = memberDef;\n        if ((min !== undefined && min !== null && value < min) ||\n            (max !== undefined && max !== null && value > max)) {\n            throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n        }\n        // Validate multipleOf constraint\n        if (multipleOf !== undefined && multipleOf !== null) {\n            const remainder = value % BigInt(multipleOf);\n            if (remainder !== 0n) {\n                throw new ValidationError(ErrorCodes.invalidValue, `The value ${value} for '${memberDef.path}' must be a multiple of ${multipleOf}`, node);\n            }\n        }\n        return value;\n    }\n}\nexport default BigIntDef;\n","import Decimal from '../../core/decimal';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, throwError, getIntegerDigits } from './common-number';\nconst decimalSchema = new Schema(\"decimal\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"decimal\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"decimal\" } } }, { precision: { type: \"number\", optional: true, null: false } }, { scale: { type: \"number\", optional: true, null: false } }, { min: { type: \"decimal\", optional: true, null: false } }, { max: { type: \"decimal\", optional: true, null: false } }, { multipleOf: { type: \"decimal\", optional: true, null: false } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Decimal type definition with support for 4 validation modes:\n * 1. Natural comparison (no precision/scale)\n * 2. Scale-only validation (exact decimal places)\n * 3. Precision-only validation (max significant digits)\n * 4. Strict validation (exact DECIMAL(precision, scale))\n *\n * @internal\n */\nclass DecimalDef {\n    constructor() {\n        this._type = 'decimal';\n    }\n    get type() { return this._type; }\n    get schema() { return decimalSchema; }\n    parse(node, memberDef, defs) {\n        const valueNode = defs?.getV(node) || node;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        // Type check: reject regular numbers, only accept Decimal instances\n        if (typeof value === 'number') {\n            throwError(ErrorCodes.invalidType, memberDef.path, `Expected decimal value (with 'm' suffix), got number`, node);\n        }\n        value = this.validate(memberDef, value, node);\n        return value;\n    }\n    load(value, memberDef, defs) {\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value);\n        if (changed)\n            return checkedValue;\n        return this.validate(memberDef, value);\n    }\n    stringify(value, memberDef) {\n        // Validate before stringifying\n        this.validate(memberDef, value);\n        return value.toString();\n    }\n    /**\n     * Validates decimal value according to the specified mode\n     */\n    validate(memberDef, value, node) {\n        let { min, max, precision: requiredPrecision, scale: requiredScale } = memberDef;\n        const valD = Decimal.ensureDecimal(value);\n        // Mode check: Determine validation mode based on precision and scale\n        const hasRequiredPrecision = requiredPrecision !== null && requiredPrecision !== undefined;\n        const hasRequiredScale = requiredScale !== null && requiredScale !== undefined;\n        // Validate scale if specified (modes 2 and 4)\n        if (hasRequiredScale) {\n            const actualScale = valD.getScale();\n            if (actualScale !== requiredScale) {\n                throwError(ErrorCodes.invalidScale, memberDef.path, `Value has scale ${actualScale}, expected ${requiredScale}`, node);\n            }\n        }\n        // Validate precision if specified (modes 3 and 4)\n        if (hasRequiredPrecision) {\n            const actualPrecision = valD.getPrecision();\n            if (hasRequiredScale) {\n                // Mode 4: Strict validation (both precision and scale)\n                // Check if value fits within DECIMAL(precision, scale)\n                const intDigits = getIntegerDigits(valD);\n                const maxIntDigits = requiredPrecision - requiredScale;\n                if (intDigits > maxIntDigits) {\n                    throwError(ErrorCodes.invalidPrecision, memberDef.path, `Integer part has ${intDigits} digits, DECIMAL(${requiredPrecision},${requiredScale}) allows ${maxIntDigits}`, node);\n                }\n            }\n            else {\n                // Mode 3: Precision-only validation\n                if (actualPrecision > requiredPrecision) {\n                    throwError(ErrorCodes.invalidPrecision, memberDef.path, `Value has precision ${actualPrecision}, max allowed is ${requiredPrecision}`, node);\n                }\n            }\n        }\n        // Validate min constraint - normalize to same scale for comparison\n        if (min !== null && min !== undefined) {\n            const minD = Decimal.ensureDecimal(min);\n            // Use the larger scale for both\n            const targetScale = Math.max(valD.getScale(), minD.getScale());\n            // Calculate precision needed: max integer digits + target scale\n            const valIntDigits = getIntegerDigits(valD);\n            const minIntDigits = getIntegerDigits(minD);\n            const targetPrecision = Math.max(valIntDigits, minIntDigits) + targetScale;\n            const normalizedVal = valD.convert(targetPrecision, targetScale);\n            const normalizedMin = minD.convert(targetPrecision, targetScale);\n            if (normalizedVal.compareTo(normalizedMin) < 0) {\n                throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n            }\n        }\n        // Validate max constraint - normalize to same scale for comparison\n        if (max !== null && max !== undefined) {\n            const maxD = Decimal.ensureDecimal(max);\n            // Use the larger scale for both\n            const targetScale = Math.max(valD.getScale(), maxD.getScale());\n            // Calculate precision needed: max integer digits + target scale\n            const valIntDigits = getIntegerDigits(valD);\n            const maxIntDigits = getIntegerDigits(maxD);\n            const targetPrecision = Math.max(valIntDigits, maxIntDigits) + targetScale;\n            const normalizedVal = valD.convert(targetPrecision, targetScale);\n            const normalizedMax = maxD.convert(targetPrecision, targetScale);\n            if (normalizedVal.compareTo(normalizedMax) > 0) {\n                throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n            }\n        }\n        // Validate multipleOf constraint\n        if (memberDef.multipleOf !== undefined && memberDef.multipleOf !== null) {\n            const multipleOfD = Decimal.ensureDecimal(memberDef.multipleOf);\n            // For multipleOf check, we need to ensure both values have the same scale\n            const targetScale = Math.max(valD.getScale(), multipleOfD.getScale());\n            const valIntDigits = getIntegerDigits(valD);\n            const multipleIntDigits = getIntegerDigits(multipleOfD);\n            const targetPrecision = Math.max(valIntDigits, multipleIntDigits) + targetScale;\n            const normalizedVal = valD.convert(targetPrecision, targetScale);\n            const normalizedMultiple = multipleOfD.convert(targetPrecision, targetScale);\n            // Check if value is a multiple using modulo operation\n            const remainder = normalizedVal.mod(normalizedMultiple);\n            const zero = new Decimal(0, targetPrecision, targetScale);\n            if (remainder.compareTo(zero) !== 0) {\n                throwError(ErrorCodes.invalidValue, memberDef.path, `Value must be a multiple of ${multipleOfD}`, node);\n            }\n        }\n        // Return the value as-is (don't convert unless necessary)\n        return valD;\n    }\n}\nexport default DecimalDef;\n","import InternetObjectError from '../../errors/io-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ValidationError from '../../errors/io-validation-error';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nimport { NUMBER_TYPES, NUMBER_MAP, throwError } from './common-number';\nimport BigIntDef from './bigint';\nimport DecimalDef from './decimal';\nconst numberSchema = new Schema(\"number\", { type: { type: \"string\", optional: false, null: false, choices: NUMBER_TYPES } }, { default: { type: \"number\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"number\" } } }, { min: { type: \"number\", optional: true, null: false } }, { max: { type: \"number\", optional: true, null: false } }, { multipleOf: { type: \"number\", optional: true, null: false } }, { format: { type: \"string\", optional: true, null: false, choices: [\"decimal\", \"hex\", \"octal\", \"binary\", \"scientific\"] } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the various number related data types in Internet Object.\n * Delegates to specialized types (BigIntDef, DecimalDef) when appropriate.\n *\n * @internal\n */\nclass NumberDef {\n    get type() { return this._type; }\n    get schema() {\n        if (this._delegateTypeDef) {\n            return this._delegateTypeDef.schema;\n        }\n        return numberSchema;\n    }\n    constructor(type = 'number') {\n        this._type = type;\n        // Delegate to specialized type definitions\n        if (type === 'bigint') {\n            this._delegateTypeDef = new BigIntDef();\n        }\n        else if (type === 'decimal') {\n            this._delegateTypeDef = new DecimalDef();\n        }\n    }\n    parse(node, memberDef, defs) {\n        // Delegate to specialized type if available\n        if (this._delegateTypeDef) {\n            return this._delegateTypeDef.parse(node, memberDef, defs);\n        }\n        // Handle standard number types\n        const valueNode = defs?.getV(node) || node;\n        const rawValue = typeof valueNode?.toValue === 'function' ? valueNode.toValue(defs) : valueNode;\n        let { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n        if (changed)\n            return value;\n        value = this.validateInteger(memberDef, value, node);\n        return value;\n    }\n    /** Load: JS Value  Validated JS Value */\n    load(value, memberDef, defs) {\n        // Delegate to specialized type if available\n        if (this._delegateTypeDef && 'load' in this._delegateTypeDef) {\n            return this._delegateTypeDef.load(value, memberDef, defs);\n        }\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value, undefined, defs);\n        if (changed)\n            return checkedValue;\n        const validated = this.validateInteger(memberDef, value);\n        return validated;\n    }\n    stringify(value, memberDef) {\n        // Validate before formatting to ensure consistency\n        this.load(value, memberDef);\n        // Delegate to specialized type if available\n        if (this._delegateTypeDef && 'stringify' in this._delegateTypeDef) {\n            return this._delegateTypeDef.stringify(value, memberDef);\n        }\n        // Handle standard number types\n        if (memberDef.format === 'scientific') {\n            return value.toExponential();\n        }\n        if (memberDef.format === 'hex') {\n            return value.toString(16);\n        }\n        if (memberDef.format === 'octal') {\n            return value.toString(8);\n        }\n        if (memberDef.format === 'binary') {\n            return value.toString(2);\n        }\n        return value.toString();\n    }\n    /**\n     * Validates integer and float types\n     */\n    validateInteger(memberDef, value, node) {\n        const valueType = typeof value === \"bigint\" ? \"bigint\" : NUMBER_MAP[typeof value] ? \"number\" : \"\";\n        if (valueType === \"\") {\n            throw new ValidationError(ErrorCodes.invalidType, `Expecting a value of type '${memberDef.type}' for '${memberDef.path}'`, node);\n        }\n        if (valueType !== \"number\") {\n            throw new ValidationError(`not-a-${memberDef.type}`, `Invalid value encountered for '${memberDef.path}'`, node);\n        }\n        // Get type-specific bounds\n        const { min: typeBoundMin, max: typeBoundMax } = this.getTypeBounds(this._type);\n        // Use memberDef.min/max if available, otherwise use type bounds\n        const effectiveMin = memberDef.min !== undefined && memberDef.min !== null ? memberDef.min : typeBoundMin;\n        const effectiveMax = memberDef.max !== undefined && memberDef.max !== null ? memberDef.max : typeBoundMax;\n        if ((effectiveMin !== null && value < effectiveMin) || (effectiveMax !== null && value > effectiveMax)) {\n            throwError(ErrorCodes.invalidRange, memberDef.path, value, node);\n        }\n        // Validate multipleOf constraint\n        if (memberDef.multipleOf !== undefined && memberDef.multipleOf !== null) {\n            if (value % memberDef.multipleOf !== 0) {\n                throw new ValidationError(ErrorCodes.invalidValue, `The value ${value} for '${memberDef.path}' must be a multiple of ${memberDef.multipleOf}`, node);\n            }\n        }\n        return value;\n    }\n    /**\n     * Get min/max bounds for a specific number type\n     */\n    getTypeBounds(type) {\n        switch (type) {\n            case 'uint':\n                return { min: 0, max: null };\n            case 'int8':\n                return { min: -(2 ** 7), max: 2 ** 7 - 1 };\n            case 'uint8':\n                return { min: 0, max: 2 ** 8 - 1 };\n            case 'int16':\n                return { min: -(2 ** 15), max: 2 ** 15 - 1 };\n            case 'uint16':\n                return { min: 0, max: 2 ** 16 - 1 };\n            case 'int32':\n                return { min: -(2 ** 31), max: 2 ** 31 - 1 };\n            case 'uint32':\n                return { min: 0, max: 2 ** 32 - 1 };\n            case 'uint64':\n            case 'int64':\n            case 'float32':\n            case 'float64':\n                throw new InternetObjectError(ErrorCodes.unsupportedNumberType, `The number type '${type}' is not supported.`);\n            default:\n                return { min: null, max: null };\n        }\n    }\n    static get types() {\n        return NUMBER_TYPES;\n    }\n}\nexport default NumberDef;\n","import ValidationError from '../../errors/io-validation-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport ObjectNode from '../../parser/nodes/objects';\nimport compileObject from '../../schema/compile-object';\nimport processObject from '../../schema/object-processor';\nimport Schema from '../../schema/schema';\nimport doCommonTypeCheck from './common-type';\nconst schema = new Schema(\"object\", { type: { type: \"string\", optional: false, null: false, choices: [\"object\"] } }, { default: { type: \"object\", optional: true, null: false } }, { schema: { type: \"object\", optional: true, null: false, __schema: true } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the ObjectTypeDef which is reponsible for parsing,\n * validating, loading and serializing Objects.\n */\nclass ObjectDef {\n    constructor() {\n        this._names = null;\n        /**\n         * Parses the object in IO format into JavaScript object.\n         */\n        this.parse = (node, memberDef, defs) => {\n            return this._process(node, memberDef, defs);\n        };\n        // Process the parse and load requests\n        this._process = (node, memberDef, defs) => {\n            const valueNode = defs?.getV(node) || node;\n            const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n            if (changed) {\n                return value;\n            }\n            let schema = memberDef.schema;\n            if (valueNode instanceof ObjectNode === false) {\n                throw new ValidationError(ErrorCodes.invalidObject, `Expecting an object value for '${memberDef.path}'`, node);\n            }\n            if (valueNode === node) {\n                if (memberDef.__schema) {\n                    return compileObject(memberDef.path || \"\", valueNode, defs);\n                }\n                if (!schema) {\n                    schema = new Schema(memberDef.path || \"\");\n                    schema.open = true;\n                }\n                return processObject(valueNode, schema, defs);\n            }\n            // valueNode fetched from defs. Hence, in case of an error, replace the\n            // error position with the original node.\n            try {\n                return processObject(valueNode, schema, defs);\n            }\n            catch (err) {\n                if (err instanceof ValidationError) {\n                    err.positionRange = node;\n                }\n                throw err;\n            }\n            return processObject(valueNode, schema, defs);\n        };\n    }\n    /**\n     * Returns the type this instance is going to handle.\n     * Always returns object\n     */\n    get type() { return 'object'; }\n    static get types() { return ['object']; }\n    get schema() { return schema; }\n}\nexport default ObjectDef;\n","const reStructuralChars = /(?<structural>[\\{\\}\\[\\]\\:\\,\\#\\\"\\'\\\\\\\\~])/gm;\nconst escapeChars = /(?<escape>[\\n\\r\\t])/gm;\nconst reNewLine = /(?<newlines>(\\r\\n?)|\\n)/gm;\nexport const toOpenString = (str, escapeLines) => {\n    str = str.replace(reStructuralChars, '\\\\$1');\n    if (escapeLines) {\n        str = str.replace(reNewLine, '\\\\n');\n    }\n    return str;\n};\nexport const toRegularString = (str, escapeLines, encloser = '\"') => {\n    str = str.replace(escapeChars, '\\\\$1');\n    if (escapeLines) {\n        str = str.replace(reNewLine, '\\\\n');\n    }\n    return `${encloser}${str.replace(encloser, `\\\\${encloser}`)}${encloser}`;\n};\nexport const toRawString = (str, encloser = '\"') => {\n    return `r${encloser}${str.replace(encloser, encloser + encloser)}${encloser}`;\n};\nexport const toAutoString = (str, escapeLines, encloser = '\"') => {\n    // If the string contains any of the structural characters, then return as open string\n    if (reStructuralChars.test(str)) {\n        return toOpenString(str, escapeLines);\n    }\n    // If the string contains any of the escape characters, then retrun as raw string\n    if (escapeChars.test(str)) {\n        return toRawString(str, encloser);\n    }\n    // Otherwise, return as regular string\n    return toRegularString(str, escapeLines, encloser);\n};\n","import ValidationError from '../../errors/io-validation-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport Schema from '../../schema/schema';\nimport * as strings from '../../utils/strings';\nimport doCommonTypeCheck from './common-type';\nconst STRING_TYPES = ['string', 'url', 'email'];\n// Reference: RFC 5322 Official Standard\n// http://emailregex.com\nconst emailExp = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/;\n// http://urlregex.com\nconst urlExp = /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[\\-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9\\.\\-]+|(?:www\\.|[\\-;:&=\\+\\$,\\w]+@)[A-Za-z0-9\\.\\-]+)((?:\\/[\\+~%\\/\\.\\w\\-_]*)?\\??(?:[\\-\\+=&;%@\\.\\w_]*)#?(?:[\\.\\!\\/\\\\\\w]*))?)/;\nconst schema = new Schema(\"string\", { type: { type: \"string\", optional: false, null: false, choices: STRING_TYPES } }, { default: { type: \"string\", optional: true, null: false } }, { choices: { type: \"array\", optional: true, null: false, of: { type: \"string\" } } }, { pattern: { type: \"string\", optional: true, null: false } }, { flags: { type: \"string\", optional: true, null: false } }, { len: { type: \"number\", optional: true, null: false, min: 0 } }, { minLen: { type: \"number\", optional: true, null: false, min: 0 } }, { maxLen: { type: \"number\", optional: true, null: false, min: 0 } }, { format: { type: \"string\", optional: true, null: false, choices: [\"auto\", \"open\", \"regular\", \"raw\"], default: \"auto\" } }, { escapeLines: { type: \"bool\", optional: true, null: false, default: false } }, { encloser: { type: \"string\", optional: true, null: false, choices: ['\"', \"'\"], default: '\"' } }, { optional: { type: \"bool\", optional: true } }, { null: { type: \"bool\", optional: true } });\n/**\n * Represents the StringTypeDef which is reponsible for parsing,\n * validating, loading and serializing strings.\n *\n * It performs the following validation\n * - Value is string\n* - Value is optional\n* - Value is null\n* - Value is in choices\n * - Value length <= maxLength\n * - Value length >= minLen\n */\nexport default class StringDef {\n    constructor(type = 'string') {\n        this._type = type;\n    }\n    get type() { return this._type; }\n    static get types() { return STRING_TYPES; }\n    get schema() { return schema; }\n    /**\n     * Parses the string in IO format into JavaScript strings.\n     */\n    parse(valueNode, memberDef, defs) {\n        return _process(valueNode, memberDef, defs);\n    }\n    /** Load: JS Value  Validated JS Value */\n    load(value, memberDef, defs) {\n        const { value: checkedValue, changed } = doCommonTypeCheck(memberDef, value, undefined, defs);\n        if (changed)\n            return checkedValue;\n        // Type check\n        if (typeof value !== 'string') {\n            throw new ValidationError(ErrorCodes.notAString, `Expecting a string value for '${memberDef.path}' but found ${JSON.stringify(value)}.`);\n        }\n        // Shared validations\n        _validatePattern(memberDef, value);\n        // Len checks\n        const len = memberDef.len;\n        if (len !== undefined && typeof len === 'number' && value.length !== len) {\n            throw new ValidationError(ErrorCodes.invalidLength, `Invalid length for ${memberDef.path}.`);\n        }\n        const maxLen = memberDef.maxLen;\n        if (maxLen !== undefined && typeof maxLen === 'number' && value.length > maxLen) {\n            throw new ValidationError(ErrorCodes.invalidMaxLength, `Invalid maxLength for ${memberDef.path}.`);\n        }\n        const minLen = memberDef.minLen;\n        if (minLen !== undefined && typeof minLen === 'number' && value.length < minLen) {\n            throw new ValidationError(ErrorCodes.invalidMinLength, `Invalid minLength for ${memberDef.path}.`);\n        }\n        return value;\n    }\n    stringify(value, memberDef) {\n        // Validate before formatting to ensure consistency\n        this.load(value, memberDef);\n        const format = memberDef.format || 'auto';\n        switch (format) {\n            case 'auto':\n                return strings.toAutoString(value, memberDef.escapeLines, memberDef.encloser);\n            case 'open':\n                return strings.toOpenString(value, memberDef.escapeLines);\n            case 'regular':\n                return strings.toRegularString(value, memberDef.escapeLines, memberDef.encloser);\n            default:\n                return strings.toRawString(value, memberDef.encloser);\n        }\n    }\n}\nfunction _process(node, memberDef, defs) {\n    const valueNode = defs?.getV(node) || node;\n    const { value, changed } = doCommonTypeCheck(memberDef, valueNode, node, defs);\n    if (changed)\n        return value;\n    if (valueNode instanceof TokenNode === false || valueNode.type !== TokenType.STRING) {\n        throw new ValidationError(ErrorCodes.notAString, `Expecting a string value for '${memberDef.path}' but found ${valueNode.toValue()}.`, node);\n    }\n    _validatePattern(memberDef, value, node);\n    // Len check\n    const len = memberDef.len;\n    if (len !== undefined && typeof len === 'number') {\n        if (value.length !== len) {\n            throw new ValidationError(ErrorCodes.invalidLength, `Invalid length for ${memberDef.path}.`, valueNode);\n        }\n    }\n    // Max length check\n    const maxLen = memberDef.maxLen;\n    if (maxLen !== undefined && typeof maxLen === 'number') {\n        if (value.length > maxLen) {\n            throw new ValidationError(ErrorCodes.invalidMaxLength, `Invalid maxLength for ${memberDef.path}.`, valueNode);\n        }\n    }\n    // Max length check\n    const minLen = memberDef.minLen;\n    if (minLen !== undefined && typeof minLen === 'number') {\n        if (value.length < minLen) {\n            throw new ValidationError(ErrorCodes.invalidMinLength, `Invalid minLen for ${memberDef.path}.`, valueNode);\n        }\n    }\n    return value;\n}\nfunction _validatePattern(memberDef, value, node) {\n    const type = memberDef.type;\n    // Validate user defined pattern\n    if (type === 'string' && memberDef.pattern !== undefined) {\n        let re = memberDef.re;\n        if (!re) {\n            let pattern = memberDef.pattern;\n            let flags = memberDef.flags;\n            // Compile the expression and cache it into the memberDef\n            try {\n                if (flags) {\n                    re = memberDef.re = new RegExp(pattern, flags);\n                }\n                else {\n                    re = memberDef.re = new RegExp(pattern);\n                }\n                memberDef.re = re; // Cache the compiled expression\n            }\n            catch {\n                throw new ValidationError(ErrorCodes.invalidPattern, value, node);\n            }\n        }\n        if (!re.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidPattern, `The value '${value}' does not match the pattern '${memberDef.pattern}'.`, node);\n        }\n    }\n    // Validate email\n    else if (type === 'email') {\n        if (!emailExp.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidEmail, `Invalid email address: ${value}`, node);\n        }\n    }\n    // Validate url\n    else if (type === 'url') {\n        if (!urlExp.test(value)) {\n            throw new ValidationError(ErrorCodes.invalidUrl, `Invalid URL: ${value}`, node);\n        }\n    }\n}\n","import TypedefRegistry from '../../schema/typedef-registry';\nimport AnyDef from './any';\nimport ArrayDef from './array';\nimport BooleanDef from './boolean';\nimport DateTimeDef from './datetime';\nimport NumberDef from './number';\nimport ObjectDef from './object';\nimport StringDef from './string';\nlet registered = false;\nexport default function registerTypes() {\n    if (registered)\n        return;\n    TypedefRegistry.register(AnyDef, ArrayDef, BooleanDef, NumberDef, ObjectDef, StringDef, DateTimeDef);\n    registered = true;\n}\n","import SyntaxError from '../../errors/io-syntax-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nexport function createMemberDef(input, opts) {\n    const allowNameless = opts?.allowNameless === true;\n    if (!input || typeof input !== 'object') {\n        throw new SyntaxError(ErrorCodes.invalidMemberDef, 'Invalid member definition input provided.');\n    }\n    const { name, type } = input;\n    if (!type || typeof type !== 'string') {\n        throw new SyntaxError(ErrorCodes.invalidType, 'MemberDef.type must be a non-empty string.');\n    }\n    if (!allowNameless && (!name || typeof name !== 'string' || name.trim() === '')) {\n        throw new SyntaxError(ErrorCodes.invalidMemberDef, 'MemberDef must have a valid name.');\n    }\n    // Basic shape checks for common compound types\n    if (type === 'array') {\n        if (!('of' in input) || typeof input.of !== 'object' || !input.of) {\n            throw new SyntaxError(ErrorCodes.invalidDefinition, \"Array MemberDef must include an 'of' definition.\");\n        }\n    }\n    // Normalize boolean-like flags when provided\n    const out = { ...input };\n    if ('optional' in out && out.optional !== undefined) {\n        out.optional = Boolean(out.optional);\n    }\n    if ('null' in out && out.null !== undefined) {\n        out.null = Boolean(out.null);\n    }\n    return out;\n}\nexport default createMemberDef;\n","import TokenNode from '../../parser/nodes/tokens';\nimport ObjectNode from '../../parser/nodes/objects';\nimport ArrayNode from '../../parser/nodes/array';\nimport TypedefRegistry from '../typedef-registry';\n/**\n * Converts additional property schema node to canonical MemberDef.\n * Supports: string, object, array, MemberDef with constraints, open forms.\n */\nexport function canonicalizeAdditionalProps(node, path = '*') {\n    // Switch on node type\n    if (node instanceof TokenNode) {\n        if (typeof node.value === 'string') {\n            // Built-in types (string, int, bool, etc.)\n            if (TypedefRegistry.isRegisteredType(node.value)) {\n                return { type: node.value, path };\n            }\n            // Open form: *\n            if (node.value === '*') {\n                return { type: 'any', path };\n            }\n        }\n        return { type: 'any', path };\n    }\n    if (node instanceof ObjectNode) {\n        // Open object form: {}\n        if (node.children.length === 0) {\n            return { type: 'object', path, open: true };\n        }\n        // Check if first child is a MemberNode with no key and value is TokenNode (type)\n        const firstChild = node.children[0];\n        if (firstChild && !firstChild.key && firstChild.value instanceof TokenNode) {\n            const typeToken = firstChild.value;\n            if (typeof typeToken.value === 'string' && TypedefRegistry.isRegisteredType(typeToken.value)) {\n                // Collect constraints from other children (MemberNode with key)\n                const memberDef = { type: typeToken.value, path };\n                for (let i = 1; i < node.children.length; i++) {\n                    const child = node.children[i];\n                    if (child && child.key && child.value instanceof TokenNode) {\n                        memberDef[child.key.value] = child.value.value;\n                    }\n                }\n                return memberDef;\n            }\n        }\n        // MemberDef with constraints (fallback)\n        return { type: 'object', path };\n    }\n    if (node instanceof ArrayNode) {\n        // Open array form: []\n        if (node.children.length === 0) {\n            return { type: 'array', path, of: { type: 'any' } };\n        }\n        // Array of type: [string]\n        const child = node.children[0];\n        if (child instanceof TokenNode && typeof child.value === 'string') {\n            return { type: 'array', path, of: { type: child.value } };\n        }\n        return { type: 'array', path };\n    }\n    // Already a MemberDef or unknown node\n    if (typeof node === 'object' && node.type) {\n        return { ...node, path };\n    }\n    return { type: 'any', path };\n}\n","import TokenNode from '../../parser/nodes/tokens';\nimport TokenType from '../../parser/tokenizer/token-types';\nimport Token from '../../parser/tokenizer/tokens';\nimport SyntaxError from '../../errors/io-syntax-error';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport assertNever from '../../errors/asserts/asserts';\n// Normalize a key token: accept Token or TokenNode(STRING) and return a TokenNode(STRING)\nexport function normalizeKeyToken(keyNode) {\n    if (!keyNode) {\n        assertNever('Key node must not be null in schema definition.');\n    }\n    if (keyNode instanceof TokenNode) {\n        if (keyNode.type === TokenType.STRING)\n            return keyNode;\n    }\n    else if (keyNode instanceof Token) {\n        if (keyNode.type === TokenType.STRING)\n            return new TokenNode(keyNode);\n    }\n    throw new SyntaxError(ErrorCodes.invalidKey, 'The key must be a string.', keyNode);\n}\n","import assertNever from '../errors/asserts/asserts';\nimport SyntaxError from '../errors/io-syntax-error';\nimport ErrorCodes from '../errors/io-error-codes';\nimport ArrayNode from '../parser/nodes/array';\nimport MemberNode from '../parser/nodes/members';\nimport ObjectNode from '../parser/nodes/objects';\nimport TokenNode from '../parser/nodes/tokens';\nimport TokenType from '../parser/tokenizer/token-types';\nimport TypedefRegistry from './typedef-registry';\nimport processSchema from './processor';\nimport Schema from './schema';\nimport Token from '../parser/tokenizer/tokens';\nimport registerTypes from './types';\nimport createMemberDef from './types/memberdef-factory';\nimport { canonicalizeAdditionalProps } from './utils/additional-props-canonicalizer';\nimport { normalizeKeyToken } from './utils/member-utils';\n// Register built-in types\nregisterTypes();\nexport default function compileObject(name, node, defs) {\n    // Check if the node is a string token and starts with $. If yes, then\n    // it is a schema variable. In this case, just return the node as it is\n    // to be processed later.\n    if (node instanceof TokenNode &&\n        node.type === TokenType.STRING &&\n        node.value.startsWith('$')) {\n        return node;\n    }\n    if (node instanceof ObjectNode === false) {\n        throw new SyntaxError(ErrorCodes.invalidSchema, \"Schema must be an object.\", node);\n    }\n    const schema = new Schema(name);\n    parseObjectDef(node, schema, \"\", defs);\n    return schema;\n}\nfunction parseObjectOrTypeDef(o, path, defs) {\n    // When the object node is empty object, then the type definition is\n    // object without schema definition. Such objects can accept any object\n    // as value.\n    // For example:\n    // address: {},\n    if (o.children.length === 0) {\n        const schema = new Schema(path);\n        schema.open = true;\n        return {\n            type: 'object',\n            path,\n            schema\n        };\n    }\n    // When the object node is type definition. The type deinition has first\n    // member as the type name\n    // For example:\n    // age: { number, min: 10, max: 20 }\n    const firstNode = o.children[0];\n    if (!firstNode.key) {\n        if (firstNode.value instanceof TokenNode) {\n            const token = firstNode.value;\n            if (token.type === TokenType.STRING) {\n                // Built-in type shorthand: { string, min: ..., max: ... }\n                if (TypedefRegistry.isRegisteredType(token.value)) {\n                    return parseMemberDef(token.value, o, defs);\n                }\n                // Schema variable shorthand: { $Person, ... }\n                if (typeof token.value === 'string' && token.value.startsWith('$')) {\n                    return { type: 'object', schema: token, path };\n                }\n            }\n        }\n    }\n    // When the object node is a member type definition defined using the\n    // object definition syntax. It must hae a type property.\n    // For example:\n    // name: { min: 10, max: 20, type: string }\n    let type = '';\n    let typeNode = null;\n    for (let i = 0; i < o.children.length; i++) {\n        const child = o.children[i];\n        if (child instanceof MemberNode && child.key && child.key.value === 'type') {\n            if (child.value instanceof TokenNode && child.value.type === TokenType.STRING) {\n                type = child.value.value;\n                typeNode = child.value;\n                break;\n            }\n        }\n    }\n    // If type exists, and a valid type, then parse the member definition\n    // name: { minLength: 10, maxLength: 20, type: string }\n    if (type !== '') {\n        // Support type: $SchemaVar\n        if (typeof type === 'string' && type.startsWith('$')) {\n            return { type: 'object', schema: typeNode, path };\n        }\n        if (TypedefRegistry.isRegisteredType(type)) {\n            return parseMemberDef(type, o, defs);\n        }\n        // If the type is not registered, then it is an invalid type\n        // name: { minLength: 10, maxLength: 20, type: xyz }\n        throw new SyntaxError(ErrorCodes.invalidType, `The specified value '${type}' is not a valid type.`, typeNode);\n    }\n    // If the type is not defined, then consider it an object type with\n    // custom schema.\n    return {\n        type: 'object',\n        schema: parseObjectDef(o, new Schema(path), path, defs),\n        path,\n    };\n}\n// field: {array, of:string, minLen:2}         # Array of strings with minimum length of 2\n// field: {array, of:string}                   # Array of strings\n// field: {of:string, type:array, minLen:2}    # Array of strings with minimum length of 2\n// field: {array, of:{ name: string, age: number }} # Array of objects\n// field: {array, of:[string]}                 # Array of arrays of strings\n// field: {array, of:{array, of:{}, minLen: 2 }} # Array of arrays of any type of objects with minimum length of 2\n//\n// Array Objects\n// field: { [], choices:[[a, b, c], [d, e, f]] }\n// Array MemberDefs\n// field: []                                   # Array of any type\n// field: [string]                             # Array of strings\n// field: [ [string] ]                         # Array of arrays of strings\n// field: [ { name: string, age: number } ]    # Array of objects\n// field: [ [ { name: string, age: number } ] ]# Array of arrays of objects\n// field: [ {type:string, len:6, pattern:r'[a-z0-9]+'} ]   # Array of strings with length of 6 and alphanumeric values\nfunction parseArrayOrTypeDef(a, path, defs) {\n    // The length of the array child must be <= 1. If the length is > 1, then\n    // it is an invalid schema.\n    if (a.children.length > 1) {\n        throw new SyntaxError(ErrorCodes.invalidSchema, \"The array definition must have only one child.\", a.children[1]);\n    }\n    // When the array node is empty array, then the type definition is\n    // array without schema definition. Such arrays can accept any type items\n    // in the array.\n    // For example:\n    // tags: []\n    if (a.children.length === 0) {\n        return createMemberDef({\n            type: 'array',\n            of: {\n                type: 'any',\n                path,\n                null: true,\n            },\n            path,\n        }, { allowNameless: true });\n    }\n    // When the array node has one child, then it is a type definition.\n    // For example:\n    // tags: [string], friends: [ { name: string, age: number } ]\n    //\n    const child = a.children[0];\n    if (child instanceof TokenNode) {\n        if (child.type === TokenType.STRING) {\n            const type = child.value;\n            // [string], [number], [boolean], [object], [array] etc.\n            if (TypedefRegistry.isRegisteredType(type)) {\n                return createMemberDef({\n                    type: 'array',\n                    of: {\n                        type: child.value,\n                        path,\n                    },\n                    path,\n                }, { allowNameless: true });\n            }\n            // If the type is a schema variable, then return the schema variable\n            // [$employee], [$address], [$person] etc.\n            else if (!!defs && type.startsWith('$')) {\n                return createMemberDef({\n                    type: 'array',\n                    of: {\n                        type: 'object',\n                        schema: child,\n                        path,\n                    },\n                    path,\n                }, { allowNameless: true });\n            }\n        }\n        // If the type is not registered, then it is an invalid type\n        throw new SyntaxError(ErrorCodes.invalidType, `The specified value (${child.value}) is not a valid type`, child);\n    }\n    // If the child is an object node, then it is a member type definition\n    // For example:\n    // friends: [ { name: string, age: number } ]\n    if (child instanceof ObjectNode) {\n        return createMemberDef({\n            type: 'array',\n            of: parseObjectOrTypeDef(child, path, defs),\n            path,\n        }, { allowNameless: true });\n    }\n    // If the child is an array node, then it is an array type definition\n    // For example:\n    // friends: [ [string] ] or friends: [ [ { name: string, age: number } ] ]\n    if (child instanceof ArrayNode) {\n        return createMemberDef({\n            type: 'array',\n            of: parseArrayOrTypeDef(child, path, defs),\n            path,\n        }, { allowNameless: true });\n    }\n    // Throw an error if the child is not a string or object node\n    throw new SyntaxError(ErrorCodes.invalidSchema, \"The array of type definition must be a string or object.\", child);\n}\n// function parseArrayDef(o: ObjectNode, schema:Schema, path:string, defs?:Definitions): Schema {\n// }\nfunction parseObjectDef(o, schema, path, defs) {\n    // Note: empty-object and no-names cases are handled explicitly below.\n    for (let index = 0; index < o.children.length; index++) {\n        const child = o.children[index];\n        if (child === null) {\n            assertNever(\"Child value must not be null in schema definition.\");\n        }\n        const memberNode = child;\n        if (memberNode.value instanceof TokenNode && memberNode.value.type === TokenType.UNDEFINED) {\n            throw new SyntaxError(ErrorCodes.emptyMemberDef, \"The next member definition is empty.\", memberNode.value);\n        }\n        // Handle additional properties (dynamic fields)\n        if (memberNode.key && memberNode.key.value === '*') {\n            // Use canonicalizer for additional property MemberDef\n            if (memberNode.value) {\n                const additionalDef = canonicalizeAdditionalProps(memberNode.value, '*');\n                schema.defs['*'] = additionalDef;\n                schema.open = additionalDef;\n            }\n            else {\n                schema.open = true;\n            }\n            if (index !== o.children.length - 1) {\n                throw new SyntaxError(ErrorCodes.invalidSchema, \"The * is only allowed at the last position.\", memberNode.value);\n            }\n            continue;\n        }\n        // Regular member\n        if (memberNode.key) {\n            const memberDef = getMemberDef(memberNode, path, defs);\n            addMemberDef(memberDef, schema, path);\n        }\n        else {\n            // If the last index and the value is *, then this is an open schema\n            const open = memberNode.value instanceof TokenNode && memberNode.value.type === TokenType.STRING && memberNode.value.value === '*';\n            if (open) {\n                if (index !== o.children.length - 1) {\n                    throw new SyntaxError(ErrorCodes.invalidSchema, \"The * is only allowed at the last position.\", memberNode.value);\n                }\n                schema.open = true;\n                continue;\n            }\n            // Normalize key token for keyless path to ensure Token | TokenNode(STRING)\n            const keyToken = normalizeKeyToken(memberNode.value);\n            const fieldInfo = parseName(keyToken);\n            // Always infer type as 'any' if not explicitly provided\n            const memberDef = createMemberDef({\n                ...fieldInfo,\n                type: 'any'\n            });\n            addMemberDef(memberDef, schema, path);\n        }\n    }\n    if (schema.names.length === 0) {\n        schema.open = true;\n    }\n    return schema;\n}\n/**\n * Dereferences variable references in an ObjectNode's members before schema validation.\n * This ensures that variables like @defaultQty are resolved to their actual values (1)\n * before type-specific validators (NumberDef, BooleanDef, etc.) process them.\n *\n * Two-stage dereferencing architecture:\n * 1. Schema compilation runtime: Resolves variables during MemberDef validation (here)\n * 2. Data processing runtime: Resolves variables via _resolveMemberDefVariables in processObject\n *\n * Modifies the ObjectNode in place for efficiency during schema compilation.\n */\nfunction dereferenceObjectNodeVariables(o, defs) {\n    if (!defs)\n        return;\n    // Dereference variables in each member's value\n    for (const child of o.children) {\n        if (!(child instanceof MemberNode))\n            continue;\n        const value = child.value;\n        // Dereference variable in TokenNode values (e.g., default: @defaultQty)\n        if (value instanceof TokenNode &&\n            typeof value.value === 'string' &&\n            value.value.startsWith('@')) {\n            const resolved = defs.getV(value.value);\n            // getV returns the TokenNode stored for the variable (e.g., TokenNode with type NUMBER and value 1)\n            // Replace the variable reference TokenNode with the resolved value TokenNode\n            if (resolved instanceof TokenNode) {\n                child.value = resolved;\n            }\n            else {\n                // Fallback: if getV returned a raw value (shouldn't happen but be defensive)\n                value.value = resolved;\n                // Update the token type based on the resolved value\n                if (typeof resolved === 'number') {\n                    value.type = TokenType.NUMBER;\n                }\n                else if (typeof resolved === 'boolean') {\n                    value.type = TokenType.BOOLEAN;\n                }\n            }\n        }\n    }\n}\nfunction parseMemberDef(type, o, defs) {\n    // Dereference variables in the ObjectNode before validation\n    dereferenceObjectNodeVariables(o, defs);\n    const typeDef = TypedefRegistry.get(type);\n    // Pass defs to processSchema so it can resolve variables during validation\n    const memberDef = processSchema(o, typeDef.schema, defs);\n    return memberDef;\n}\nfunction addMemberDef(memberDef, schema, path) {\n    // Duplicate member detection (compile-time)\n    if (schema.defs[memberDef.name]) {\n        throw new SyntaxError(ErrorCodes.duplicateMember, `Member ${memberDef.name} is already defined in schema ${schema.name}.`, schema.defs[memberDef.name]);\n    }\n    memberDef.path = _(path, memberDef.name);\n    schema.names.push(memberDef.name);\n    schema.defs[memberDef.name] = memberDef;\n}\nconst parseName = (keyNode) => {\n    if (!keyNode) {\n        assertNever(\"Key node must not be null in schema definition.\");\n    }\n    if (!(keyNode instanceof Token)) {\n        throw new SyntaxError(ErrorCodes.invalidKey, \"The key must be a string.\", keyNode);\n    }\n    const key = keyNode.value;\n    const optionalExp = /\\?$/;\n    const nullExp = /\\*$/;\n    const optNullExp = /(\\?\\*)|(\\*\\?)$/;\n    if (keyNode.type !== TokenType.STRING) {\n        throw new SyntaxError(ErrorCodes.invalidKey, \"The key must be a string.\", keyNode);\n    }\n    // Optional and null\n    if (key.match(optNullExp)) {\n        return {\n            name: key.substring(0, key.length - 2),\n            optional: true,\n            null: true\n        };\n    }\n    // null\n    if (key.match(nullExp)) {\n        return {\n            name: key.substring(0, key.length - 1),\n            optional: false,\n            null: true\n        };\n    }\n    // Optional\n    if (key.match(optionalExp) !== null) {\n        return {\n            name: key.substring(0, key.length - 1),\n            optional: true,\n            null: false\n        };\n    }\n    return { name: key, optional: false, null: false };\n};\n// moved to utils/member-utils.ts\nexport function getMemberDef(memberDef, path, defs) {\n    const node = memberDef.value;\n    let fieldInfo = { name: \"\" };\n    if (memberDef.key) {\n        fieldInfo = parseName(normalizeKeyToken(memberDef.key));\n    }\n    // If the value token is a string, then ensure that it is a valid type\n    // For example:\n    // name: string, age: number\n    if (node instanceof TokenNode && node.type === TokenType.STRING) {\n        const type = node.value;\n        // If the type string starts with $, then it is a schema variable\n        if (type.startsWith('$')) {\n            return {\n                ...fieldInfo,\n                type: \"object\",\n                schema: node,\n            };\n        }\n        if (TypedefRegistry.isRegisteredType(type) === false) {\n            throw new SyntaxError(ErrorCodes.invalidType, `The type '${type}' is not supported.`, node);\n        }\n        return {\n            ...fieldInfo,\n            type,\n        };\n    }\n    // If the value token is an object, then parse the object definition\n    if (node instanceof ObjectNode) {\n        const objectDef = parseObjectOrTypeDef(node, _(path, fieldInfo.name), defs);\n        return {\n            ...fieldInfo,\n            ...objectDef,\n        };\n    }\n    // If the value token is an array, then parse the array definition\n    if (node instanceof ArrayNode) {\n        const arrayDef = parseArrayOrTypeDef(node, _(path, fieldInfo.name), defs);\n        return {\n            ...fieldInfo,\n            ...arrayDef,\n        };\n    }\n    throw new SyntaxError(ErrorCodes.invalidType, `Found '${node.toValue()}' but expecting a data type definition.`, node);\n}\n// concacts the path and key\nfunction _(path, key) {\n    if (path === \"\") {\n        return key;\n    }\n    return `${path}.${key}`;\n}\n","/**\n * Utility functions for creating proper error ranges across tokenizer, parser, and validator.\n *\n * Industry-standard approach (TypeScript, Roslyn, rust-analyzer):\n * 1. Single-token errors: Highlight the specific problematic token\n * 2. Construct errors: Span entire construct (from opening to expected closing)\n * 3. Validation errors: Highlight the exact value that failed validation\n * 4. Unclosed/unterminated: From start to end of input or boundary\n */\n/**\n * Creates a PositionRange from a single token.\n * Use for: Invalid characters, unexpected tokens, type mismatches.\n *\n * @param token - The token to create range from\n * @returns PositionRange spanning the token\n */\nexport function singleTokenRange(token) {\n    return {\n        getStartPos: () => token.getStartPos(),\n        getEndPos: () => token.getEndPos()\n    };\n}\n/**\n * Creates a PositionRange spanning multiple tokens.\n * Use for: Multi-token expressions, schema definitions.\n *\n * @param startToken - First token of the range\n * @param endToken - Last token of the range\n * @returns PositionRange spanning from start to end\n */\nexport function tokenSpanRange(startToken, endToken) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => endToken.getEndPos()\n    };\n}\n/**\n * Creates a PositionRange for unclosed constructs (strings, arrays, objects).\n * Industry standard: Span from opening delimiter to where closing should be.\n *\n * @param startToken - Opening delimiter token (\", [, {, etc.)\n * @param currentPos - Current position when error detected\n * @returns PositionRange spanning the unclosed construct\n */\nexport function unclosedConstructRange(startToken, currentPos) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => currentPos\n    };\n}\n/**\n * Creates a PositionRange for construct with explicit start and end positions.\n * Use for: Validation errors on specific values, type mismatches.\n *\n * @param startPos - Start position\n * @param endPos - End position\n * @returns PositionRange spanning the positions\n */\nexport function positionSpanRange(startPos, endPos) {\n    return {\n        getStartPos: () => startPos,\n        getEndPos: () => endPos\n    };\n}\n/**\n * Sets the position range on an error object.\n * Automatically updates the error message to include position.\n *\n * @param error - The error to set range on\n * @param range - The position range\n * @returns The error (for chaining)\n */\nexport function setErrorRange(error, range) {\n    error.positionRange = range;\n    return error;\n}\n/**\n * Creates a PositionRange from a start token to end of available content.\n * Use for: Unterminated strings, unclosed brackets at EOF.\n *\n * @param startToken - Opening token\n * @param lastPos - Last valid position in the input\n * @returns PositionRange from start to last position\n */\nexport function toEndOfInputRange(startToken, lastPos) {\n    return {\n        getStartPos: () => startToken.getStartPos(),\n        getEndPos: () => lastPos\n    };\n}\n/**\n * Helper to create a Position object.\n *\n * @param pos - Absolute position\n * @param row - Line number (1-based)\n * @param col - Column number (1-based)\n * @returns Position object\n */\nexport function createPosition(pos, row, col) {\n    return { pos, row, col };\n}\n","/**\n * Enumeration representing special symbols in IO.\n */\nvar Symbols;\n(function (Symbols) {\n    Symbols[\"CURLY_OPEN\"] = \"{\";\n    Symbols[\"CURLY_CLOSE\"] = \"}\";\n    Symbols[\"BRACKET_OPEN\"] = \"[\";\n    Symbols[\"BRACKET_CLOSE\"] = \"]\";\n    Symbols[\"COLON\"] = \":\";\n    Symbols[\"COMMA\"] = \",\";\n    Symbols[\"HASH\"] = \"#\";\n    Symbols[\"DOUBLE_QUOTE\"] = \"\\\"\";\n    Symbols[\"SINGLE_QUOTE\"] = \"'\";\n    Symbols[\"BACKSLASH\"] = \"\\\\\";\n    Symbols[\"TILDE\"] = \"~\";\n    Symbols[\"PLUS\"] = \"+\";\n    Symbols[\"MINUS\"] = \"-\";\n    Symbols[\"DOLLAR\"] = \"$\";\n    Symbols[\"DOT\"] = \".\";\n})(Symbols || (Symbols = {}));\nexport default Symbols;\n","import Symbols from \"./symbols\";\nimport TokenType from \"./token-types\";\nconst reSpaces = /\\s/;\nconst reHSpaces = /[ \\t]+/;\n/**\n  * Check if the given character is a special symbol.\n  * @param {string} char - Character to check.\n  * @returns {boolean} True if the character is a special symbol, else false.\n  */\nexport const isSpecialSymbol = (char) => {\n    // const symbols = ['{', '}', '[', ']', ':', ',', '~'];\n    const symbols = [\n        Symbols.CURLY_OPEN,\n        Symbols.CURLY_CLOSE,\n        Symbols.BRACKET_OPEN,\n        Symbols.BRACKET_CLOSE,\n        Symbols.COLON,\n        Symbols.COMMA,\n        Symbols.TILDE,\n        // TODO: Ensure that the following symbols are good to be included here.\n        Symbols.DOUBLE_QUOTE,\n        Symbols.SINGLE_QUOTE,\n    ];\n    return symbols.includes(char);\n};\n/**\n  * Check if the given character is a digit.\n  * @param char The character to check.\n  * @returns {boolean} True if the character is a digit, else false.\n  */\nexport const isDigit = (char) => {\n    return /[0-9]/.test(char);\n};\n// Pre-computed lookup for specific Unicode whitespace characters\nconst WHITESPACE_LOOKUP = new Set([\n    0x1680,\n    0x2028,\n    0x2029,\n    0x202F,\n    0x205F,\n    0x3000,\n    0xFEFF // BOM/Zero width no-break space\n]);\n/**\n  * Check if the given character represents a whitespace.\n  * @param {string} char - Character to check.\n  * @param {boolean} hspacesOnly - If true, only check for horizontal spaces (space and tab).\n  * @returns {boolean} True if the character is a whitespace, else false.\n  */\nexport const isWhitespace = (char, hspacesOnly = false) => {\n    if (hspacesOnly) {\n        return char === ' ' || char === '\\t';\n    }\n    // Use codePointAt for proper Unicode handling\n    const code = char.codePointAt(0) || 0;\n    // Fast path: ASCII whitespace and control characters (U+0000 to U+0020)\n    if (code <= 0x20) {\n        return true;\n    }\n    // Fast path: Extended ASCII range (U+0021 to U+00FF) - only U+00A0 is whitespace\n    if (code <= 0xFF) {\n        return code === 0x00A0;\n    }\n    // Fast path: Anything above U+FEFF is never whitespace\n    if (code > 0xFEFF) {\n        return false;\n    }\n    // Fast path: Unicode range U+2000-U+200A (various em/en spaces)\n    if (code >= 0x2000 && code <= 0x200A) {\n        return true;\n    }\n    // Lookup table for remaining Unicode whitespace characters\n    return WHITESPACE_LOOKUP.has(code);\n};\n/**\n * Check if the given character is valid newline character. It is valid if it\n * is either a carriage return or a line feed.\n */\nexport const isValidNewline = (char) => {\n    return char === '\\r' || char === '\\n';\n};\n/**\n* Check if the given character is an alphabetic character.\n*/\nexport const isValidOpenStringChar = (char) => {\n    // Define terminators based on IO's spec.\n    // const terminators = [\"{\", \"}\", \"[\", \"]\", \":\", \",\", \"\\\"\", \"'\", \"@\", undefined];\n    const terminators = [\n        Symbols.CURLY_OPEN,\n        Symbols.CURLY_CLOSE,\n        Symbols.BRACKET_OPEN,\n        Symbols.BRACKET_CLOSE,\n        Symbols.COLON,\n        Symbols.COMMA,\n        Symbols.HASH,\n        Symbols.DOUBLE_QUOTE,\n        Symbols.SINGLE_QUOTE,\n        Symbols.TILDE,\n    ];\n    return !terminators.includes(char);\n};\n/**\n  * Determine the token type for a special symbol.\n  * @param {string} char - Special symbol character.\n  * @returns {string} Token type.\n  */\nexport const getSymbolTokenType = (char) => {\n    switch (char) {\n        case '{': return TokenType.CURLY_OPEN;\n        case '}': return TokenType.CURLY_CLOSE;\n        case '[': return TokenType.BRACKET_OPEN;\n        case ']': return TokenType.BRACKET_CLOSE;\n        case ':': return TokenType.COLON;\n        case ',': return TokenType.COMMA;\n        case '~': return TokenType.COLLECTION_START;\n        default: return TokenType.UNKNOWN;\n    }\n};\n/**\n * Check if the given character is a terminator at the character level.\n * Used during tokenization to identify structural boundaries.\n * @param {string} char - The character to check.\n * @returns {boolean} True if the character is a terminator.\n */\nexport const isCharTerminator = (char) => {\n    return char === Symbols.CURLY_OPEN ||\n        char === Symbols.CURLY_CLOSE ||\n        char === Symbols.BRACKET_OPEN ||\n        char === Symbols.BRACKET_CLOSE ||\n        char === Symbols.COLON ||\n        char === Symbols.COMMA ||\n        char === Symbols.TILDE ||\n        char === Symbols.DOUBLE_QUOTE ||\n        char === Symbols.SINGLE_QUOTE ||\n        char === Symbols.HASH; // # starts a comment\n};\n/**\n * Check if the given token type is a terminator (structural boundary character).\n * Terminators are used for error recovery, parsing boundaries, and token validation.\n * Note: String quotes (\", ') are terminators at the character level (see isCharTerminator)\n * but not at the token level since they're consumed into STRING tokens.\n * @param {string} tokenType - The token type to check.\n * @returns {boolean} True if the token type is a terminator.\n */\nexport const isTerminator = (tokenType) => {\n    return tokenType === TokenType.COLLECTION_START || // ~ - collection item boundary\n        tokenType === TokenType.SECTION_SEP || // --- - section boundary\n        tokenType === TokenType.COMMA || // , - element delimiter\n        tokenType === TokenType.COLON || // : - key-value separator\n        tokenType === TokenType.BRACKET_OPEN || // [ - array start\n        tokenType === TokenType.BRACKET_CLOSE || // ] - array end\n        tokenType === TokenType.CURLY_OPEN || // { - object start\n        tokenType === TokenType.CURLY_CLOSE; // } - object end\n};\n","var Literals;\n(function (Literals) {\n    Literals[\"NULL\"] = \"null\";\n    Literals[\"N\"] = \"N\";\n    Literals[\"TRUE\"] = \"true\";\n    Literals[\"T\"] = \"T\";\n    Literals[\"FALSE\"] = \"false\";\n    Literals[\"F\"] = \"F\";\n    Literals[\"Inf\"] = \"Inf\";\n    Literals[\"PositiveInf\"] = \"+Inf\";\n    Literals[\"NegativeInf\"] = \"-Inf\";\n    Literals[\"NaN\"] = \"NaN\";\n})(Literals || (Literals = {}));\nexport default Literals;\n","import Decimal from '../../core/decimal';\nimport assertNever from '../../errors/asserts/asserts';\nimport ErrorCodes from '../../errors/io-error-codes';\nimport SyntaxError from '../../errors/io-syntax-error';\nimport { unclosedConstructRange, createPosition } from '../../errors/error-range-utils';\nimport * as dtParser from '../../utils/datetime';\nimport * as is from './is';\nimport Literals from './literals';\nimport Symbols from './symbols';\nimport TokenType from './token-types';\nimport Token from './tokens';\n// Cached regex patterns for performance optimization\nconst REGEX_CACHE = {\n    hex4: /^[0-9a-fA-F]{4}$/,\n    hex2: /^[0-9a-fA-F]{2}$/,\n    floatDigit: /^[0-9.]+$/,\n    intDigit: /^[0-9]+$/,\n    hex: /^[0-9a-fA-F]+$/,\n    octal: /^[0-7]+$/,\n    binary: /^[01]+$/,\n    sectionSchemaName: /^(?:(?:(?<name>[\\p{L}\\p{M}\\p{N}\\-_]+)(?<sep>[ \\t]*:[ \\t]*)?)(?<schema>\\$[\\p{L}\\p{M}\\p{N}\\-_]+)?|(?<schema2>\\$[\\p{L}\\p{M}\\p{N}\\-_]+))/u,\n    annotatedStrStart: /^(?<name>[a-zA-Z]{1,4})(?<quote>['\"])/,\n    base64: /^[A-Za-z0-9+/]*={0,2}$/\n};\n// Character code constants for ultra-fast character checking\nconst CHAR_CODES = {\n    SPACE: 32,\n    TAB: 9,\n    NEWLINE: 10,\n    CARRIAGE_RETURN: 13,\n    DOUBLE_QUOTE: 34,\n    SINGLE_QUOTE: 39,\n    HASH: 35,\n    PLUS: 43,\n    MINUS: 45,\n    DOT: 46,\n    ZERO: 48,\n    NINE: 57,\n    COLON: 58,\n    COMMA: 44,\n    CURLY_OPEN: 123,\n    CURLY_CLOSE: 125,\n    BRACKET_OPEN: 91,\n    BRACKET_CLOSE: 93,\n    BACKSLASH: 92,\n    TILDE: 126,\n    A_UPPER: 65,\n    F_UPPER: 70,\n    A_LOWER: 97,\n    F_LOWER: 102,\n    X_UPPER: 88,\n    X_LOWER: 120,\n    O_UPPER: 79,\n    O_LOWER: 111,\n    B_UPPER: 66,\n    B_LOWER: 98 // 'b'\n};\n// Fast character checking functions using character codes\nconst isDigitFast = (charCode) => charCode >= CHAR_CODES.ZERO && charCode <= CHAR_CODES.NINE;\nconst isHexDigitFast = (charCode) => isDigitFast(charCode) ||\n    (charCode >= CHAR_CODES.A_UPPER && charCode <= CHAR_CODES.F_UPPER) ||\n    (charCode >= CHAR_CODES.A_LOWER && charCode <= CHAR_CODES.F_LOWER);\n// Pre-computed lookup for specific Unicode whitespace characters (matching is.ts)\nconst WHITESPACE_LOOKUP_FAST = new Set([\n    0x1680,\n    0x2028,\n    0x2029,\n    0x202F,\n    0x205F,\n    0x3000,\n    0xFEFF // BOM/Zero width no-break space\n]);\n/**\n * Fast whitespace checking that matches the specification in is.ts\n */\nconst isWhitespaceFast = (charCode) => {\n    // Fast path: ASCII whitespace and control characters (U+0000 to U+0020)\n    if (charCode <= 0x20) {\n        return true;\n    }\n    // Fast path: Extended ASCII range (U+0021 to U+00FF) - only U+00A0 is whitespace\n    if (charCode <= 0xFF) {\n        return charCode === 0x00A0;\n    }\n    // Fast path: Anything above U+FEFF is never whitespace\n    if (charCode > 0xFEFF) {\n        return false;\n    }\n    // Fast path: Unicode range U+2000-U+200A (various em/en spaces)\n    if (charCode >= 0x2000 && charCode <= 0x200A) {\n        return true;\n    }\n    // Lookup table for remaining Unicode whitespace characters\n    return WHITESPACE_LOOKUP_FAST.has(charCode);\n};\nconst regexHex4 = REGEX_CACHE.hex4;\nconst regexHex2 = REGEX_CACHE.hex2;\nconst reFloatDigit = REGEX_CACHE.floatDigit;\nconst reIntDigit = REGEX_CACHE.intDigit;\nconst reHex = REGEX_CACHE.hex;\nconst reOctal = REGEX_CACHE.octal;\nconst reBinary = REGEX_CACHE.binary;\n// https://regex101.com/r/HOVtCj/1\n// const reSectionSchemaName = /^(?<schema>\\$[\\p{L}\\p{M}\\p{N}\\-_]+)(?:[ \\t]*:[ \\t]*(?<name>[\\p{L}\\p{M}\\p{N}\\-_]+))?/u;\n// https://regex101.com/r/jaWr0V/2\n// Cached constants for performance\nconst NON_DECIMAL_PREFIXES = [\"x\", \"X\", \"o\", \"O\", \"b\", \"B\"];\nconst reSectionSchemaName = REGEX_CACHE.sectionSchemaName;\nconst nonDecimalPrefixes = NON_DECIMAL_PREFIXES;\nconst reAnotatedStrStart = REGEX_CACHE.annotatedStrStart;\n/**\n * Tokenizer for IO format.\n */\nclass Tokenizer {\n    /**\n     * Initialize the tokenizer with an input string.\n     * @param input - String to be tokenized.\n     */\n    constructor(input) {\n        this.pos = 0; // Current position within the input string\n        this.input = \"\"; // Input string to tokenize\n        this.row = 1; // Current row within the input string\n        this.col = 1; // Current column within the input string\n        this.reachedEnd = false; // True if the end of the input string has been reached, else false\n        this.inputLength = 0; // Cache input length for performance\n        this.input = input;\n        this.inputLength = input.length; // Cache length for performance\n    }\n    /**\n     * Fast character checking for special symbols using character codes\n     */\n    isSpecialSymbolFast(charCode) {\n        return charCode === CHAR_CODES.CURLY_OPEN || charCode === CHAR_CODES.CURLY_CLOSE ||\n            charCode === CHAR_CODES.BRACKET_OPEN || charCode === CHAR_CODES.BRACKET_CLOSE ||\n            charCode === CHAR_CODES.COMMA || charCode === CHAR_CODES.COLON ||\n            charCode === CHAR_CODES.TILDE;\n    }\n    /**\n     * Fast token type lookup for special symbols using character codes\n     */\n    getSymbolTokenTypeFast(charCode) {\n        switch (charCode) {\n            case CHAR_CODES.CURLY_OPEN: return TokenType.CURLY_OPEN;\n            case CHAR_CODES.CURLY_CLOSE: return TokenType.CURLY_CLOSE;\n            case CHAR_CODES.BRACKET_OPEN: return TokenType.BRACKET_OPEN;\n            case CHAR_CODES.BRACKET_CLOSE: return TokenType.BRACKET_CLOSE;\n            case CHAR_CODES.COMMA: return TokenType.COMMA;\n            case CHAR_CODES.COLON: return TokenType.COLON;\n            case CHAR_CODES.TILDE: return TokenType.COLLECTION_START;\n            default: return TokenType.UNKNOWN;\n        }\n    }\n    /**\n     * Create an error token for invalid input and continue tokenizing.\n     * @param error - The error that occurred\n     * @param startPos - Starting position of the invalid token\n     * @param startRow - Starting row of the invalid token\n     * @param startCol - Starting column of the invalid token\n     * @param tokenText - The invalid token text\n     */\n    createErrorToken(error, startPos, startRow, startCol, tokenText) {\n        return Token.init(startPos, startRow, startCol, tokenText, {\n            __error: true,\n            message: error.message,\n            originalError: error\n        }, TokenType.ERROR);\n    }\n    /**\n     * Skip to the next valid token boundary after an error.\n     * This helps recover from parsing errors by advancing to a safe position.\n     */\n    skipToNextTokenBoundary() {\n        // Skip characters until we find a delimiter, whitespace, or special symbol\n        while (!this.reachedEnd &&\n            !is.isWhitespace(this.input[this.pos]) &&\n            !is.isSpecialSymbol(this.input[this.pos]) &&\n            this.input[this.pos] !== ',' &&\n            this.input[this.pos] !== '\\n') {\n            this.advance();\n        }\n    }\n    /**\n     * Advance the current position and update the row and column accordingly.\n     */\n    advance(step = 1) {\n        if (this.reachedEnd) {\n            return;\n        }\n        // Optimize for single step (most common case)\n        if (step === 1) {\n            if (this.input.charCodeAt(this.pos) === CHAR_CODES.NEWLINE) {\n                this.row++;\n                this.col = 1;\n            }\n            else {\n                this.col++;\n            }\n            this.pos++;\n            if (this.pos >= this.inputLength) {\n                this.reachedEnd = true;\n            }\n            return;\n        }\n        // Handle multiple steps\n        for (let i = 0; i < step; i++) {\n            if (this.input.charCodeAt(this.pos) === CHAR_CODES.NEWLINE) {\n                this.row++;\n                this.col = 1;\n            }\n            else {\n                this.col++;\n            }\n            this.pos++;\n            if (this.pos >= this.inputLength) {\n                this.reachedEnd = true;\n                break;\n            }\n        }\n    }\n    parseSingleLineComment() {\n        while (!this.reachedEnd && this.input[this.pos] !== \"\\n\") {\n            this.advance();\n        }\n    }\n    parseRegularString(encloser) {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        this.advance(); // Move past the opening quotation mark\n        let value = \"\";\n        let needToNormalize = false;\n        while (!this.reachedEnd && this.input[this.pos] !== encloser) {\n            if (is.isWhitespace(this.input[this.pos])) {\n                value += this.skipWhitespaces();\n                continue;\n            }\n            // Check if current character is a backslash (escape character)\n            if (this.input[this.pos] === Symbols.BACKSLASH) {\n                try {\n                    ({ value, needToNormalize } = this.escapeString(value, needToNormalize));\n                    // escapeString has already advanced the position, so continue to next iteration\n                }\n                catch (error) {\n                    // For invalid escape sequences, treat them as literal characters without the backslash\n                    // Note: escapeString has already advanced past the backslash, so pos is at the escape char\n                    if (!this.reachedEnd) {\n                        const escapeChar = this.input[this.pos];\n                        value += escapeChar; // Add the escape character (u, x, etc.) without backslash\n                        // For \\u and \\x sequences, we need to add the invalid hex digits too\n                        if (escapeChar === 'u') {\n                            // Add the next 4 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 4 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else if (escapeChar === 'x') {\n                            // Add the next 2 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 2 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else {\n                            this.advance();\n                        }\n                    }\n                    continue;\n                }\n            }\n            else {\n                value += this.input[this.pos];\n                this.advance();\n            }\n        }\n        // If we reached the end without finding the closing quote,\n        // create an error token for the unclosed string\n        if (this.reachedEnd) {\n            const tokenText = this.input.substring(start, this.pos);\n            // Create a temporary token for the opening quote to get proper range\n            const openingToken = Token.init(start, startRow, startCol, '\"', '\"', \"STRING\");\n            const currentPos = createPosition(this.pos, this.row, this.col);\n            const error = new SyntaxError(ErrorCodes.stringNotClosed, `Unterminated string literal. Expected closing quote '\"' before end of input.`, unclosedConstructRange(openingToken, currentPos), true);\n            return this.createErrorToken(error, start, startRow, startCol, tokenText);\n        }\n        this.advance(); // Move past the closing quotation mark\n        const tokenText = this.input.substring(start, this.pos);\n        // After building the 'value' string, normalize it:\n        if (needToNormalize) {\n            value = value.normalize(\"NFC\");\n        }\n        return Token.init(start, startRow, startCol, tokenText, value, \"STRING\", \"REGULAR_STRING\");\n    }\n    escapeString(value, needToNormalize) {\n        this.advance(); // Move past the backslash\n        if (this.reachedEnd) {\n            throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid escape sequence at end of input. Expected escape character after backslash.`, this.currentPosition, true);\n        }\n        switch (this.input[this.pos]) {\n            case \"b\":\n                value += \"\\b\";\n                break;\n            case \"f\":\n                value += \"\\f\";\n                break;\n            case \"n\":\n                value += \"\\n\";\n                break;\n            case \"r\":\n                value += \"\\r\";\n                break;\n            case \"t\":\n                value += \"\\t\";\n                break;\n            case \"u\":\n                const hex = this.input.substring(this.pos + 1, this.pos + 5);\n                if (regexHex4.test(hex)) {\n                    // /^[0-9a-fA-F]{4}$/\n                    value += String.fromCharCode(parseInt(hex, 16));\n                    this.advance(4); // Move past the 4 hex digits\n                    needToNormalize = true;\n                }\n                else {\n                    throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid Unicode escape sequence '\\\\u${hex}'. Expected 4 hexadecimal digits (0-9, A-F).`, this.currentPosition);\n                }\n                break;\n            case \"x\":\n                const hexByte = this.input.substring(this.pos + 1, this.pos + 3);\n                if (regexHex2.test(hexByte)) {\n                    // /^[0-9a-fA-F]{2}$/\n                    value += String.fromCharCode(parseInt(hexByte, 16));\n                    this.advance(2); // Move past the 2 hex digits\n                    needToNormalize = true;\n                }\n                else {\n                    throw new SyntaxError(ErrorCodes.invalidEscapeSequence, `Invalid hexadecimal escape sequence '\\\\x${hexByte}'. Expected 2 hexadecimal digits (0-9, A-F).`, this.currentPosition);\n                }\n                break;\n            default:\n                value += this.input[this.pos]; // Treat unrecognized escape sequences as literal characters without backslash\n                this.advance(); // Move past the escape character\n                break;\n        }\n        return { value, needToNormalize };\n    }\n    get currentPosition() {\n        const getPos = () => {\n            return {\n                pos: this.pos,\n                row: this.row,\n                col: this.col\n            };\n        };\n        return {\n            getStartPos: getPos,\n            getEndPos: getPos\n        };\n    }\n    checkIfAnotatedString() {\n        // Annotated strings starts with a letter and can have a maximum of 4 letters\n        // followed by a quotation mark (single or double).\n        const match = reAnotatedStrStart.exec(this.input.substring(this.pos, this.pos + 5));\n        if (!match) {\n            return null;\n        }\n        return match.groups;\n    }\n    parseAnotatedString(annotation) {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        // Skip over the annotation characters\n        for (let i = 0; i < annotation.name.length; i++) {\n            this.advance();\n        }\n        if (this.reachedEnd) {\n            const tokenText = this.input.substring(start, this.pos);\n            // Create a temporary token for the opening annotation to get proper range\n            const openingToken = Token.init(start, startRow, startCol, annotation.name + annotation.quote, annotation.name, \"STRING\");\n            const currentPos = createPosition(this.pos, this.row, this.col);\n            const error = new SyntaxError(ErrorCodes.stringNotClosed, `Unterminated annotated string literal. Expected closing quote '${annotation.quote}' before end of input.`, unclosedConstructRange(openingToken, currentPos), true);\n            return this.createErrorToken(error, start, startRow, startCol, tokenText);\n        }\n        this.advance(); // Move past the opening quotation mark\n        while (!this.reachedEnd && this.input[this.pos] !== annotation.quote) {\n            this.advance();\n        }\n        // If we reached the end without finding the closing quote,\n        // treat it as an annotated string that goes to EOF\n        const tokenText = this.input.substring(start, this.pos);\n        let value;\n        if (this.reachedEnd) {\n            // Extract value from unclosed string (from after opening quote to EOF)\n            value = tokenText.substring(annotation.name.length + 1);\n        }\n        else {\n            this.advance(); // Move past the closing quotation mark\n            const fullTokenText = this.input.substring(start, this.pos);\n            value = fullTokenText.substring(annotation.name.length + 1, fullTokenText.length - 1);\n        }\n        // Prepare the token\n        const token = new Token();\n        token.pos = start;\n        token.row = startRow;\n        token.col = startCol;\n        token.token = this.reachedEnd ? tokenText : this.input.substring(start, this.pos);\n        token.value = value;\n        return token;\n    }\n    parseRawString(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        token.type = TokenType.STRING;\n        token.subType = \"RAW_STRING\";\n        return token;\n    }\n    parseByteString(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        try {\n            // Validate base64 format using cached regex\n            if (!REGEX_CACHE.base64.test(token.value)) {\n                throw new Error(\"Invalid base64 format\");\n            }\n            token.type = TokenType.BINARY;\n            token.subType = \"BINARY_STRING\";\n            // Convert the base64 string to a byte array\n            token.value = Buffer.from(token.value, \"base64\");\n            return token;\n        }\n        catch (error) {\n            return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n        }\n    }\n    parseDateTime(annotation) {\n        const token = this.parseAnotatedString(annotation);\n        // If the annotated string parsing already returned an error token, return it as-is\n        if (token.type === TokenType.ERROR) {\n            return token;\n        }\n        try {\n            let fn = (value) => null;\n            switch (annotation.name) {\n                case \"dt\":\n                    fn = dtParser.parseDateTime;\n                    token.subType = TokenType.DATETIME;\n                    break;\n                case \"d\":\n                    fn = dtParser.parseDate;\n                    token.subType = TokenType.DATE;\n                    break;\n                case \"t\":\n                    fn = dtParser.parseTime;\n                    token.subType = TokenType.TIME;\n                    break;\n                default:\n                    assertNever(annotation);\n            }\n            const dt = fn(token.value);\n            if (!dt) {\n                const error = new SyntaxError(ErrorCodes.invalidDateTime, `Invalid ${annotation.name === 'dt' ? 'datetime' : annotation.name === 'd' ? 'date' : 'time'} format '${token.value}'. Expected valid ISO 8601 format.`, token);\n                return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n            }\n            token.value = dt;\n            token.type = TokenType.DATETIME;\n            return token;\n        }\n        catch (error) {\n            return this.createErrorToken(error, token.pos, token.row, token.col, token.token);\n        }\n    }\n    parseNumber() {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        let rawValue = \"\";\n        let base = 10; // default is decimal\n        let hasDecimal = false;\n        let hasExponent = false;\n        let prefix = \"\";\n        let subType;\n        // Check if current position points to a plus or minus sign.\n        if (this.input[this.pos] === \"+\" || this.input[this.pos] === \"-\") {\n            const sign = this.input[this.pos];\n            // If sign is followed by \"Inf\", handle infinite literal.\n            if (this.input.startsWith(\"Inf\", this.pos + 1)) {\n                const infLiteral = sign + \"Inf\";\n                this.advance(4); // sign + \"Inf\"\n                return Token.init(start, startRow, startCol, infLiteral, sign === \"+\" ? Infinity : -Infinity, TokenType.NUMBER);\n            }\n            // Otherwise, allow sign only if immediately followed by a digit or dot.\n            if (is.isDigit(this.input[this.pos + 1]) || this.input[this.pos + 1] === \".\") {\n                rawValue += sign;\n                this.advance();\n            }\n            else {\n                return null;\n            }\n        }\n        // Also support an Inf literal without a sign.\n        else if (this.input.startsWith(\"Inf\", this.pos)) {\n            const infLiteral = \"Inf\";\n            this.advance(3);\n            return Token.init(start, startRow, startCol, infLiteral, Infinity, TokenType.NUMBER);\n        }\n        if (this.input[this.pos] === \".\") {\n            // If there is a dot, ensure it is followed by a digit.\n            if (!reFloatDigit.test(this.input[this.pos + 1])) {\n                return null;\n            }\n        }\n        // Determine the number format\n        if (this.input[this.pos] === \"0\" && nonDecimalPrefixes.includes(this.input[this.pos + 1])) {\n            switch (this.input[this.pos + 1]) {\n                case \"X\":\n                case \"x\":\n                    base = 16;\n                    subType = \"HEX\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reHex.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                case \"O\":\n                case \"o\":\n                    base = 8;\n                    subType = \"OCTAL\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reOctal.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                case \"B\":\n                case \"b\":\n                    base = 2;\n                    subType = \"BINARY\";\n                    prefix = this.input[this.pos] + this.input[this.pos + 1];\n                    this.advance(2);\n                    while (reBinary.test(this.input[this.pos])) {\n                        rawValue += this.input[this.pos];\n                        this.advance();\n                    }\n                    break;\n                default:\n                    assertNever(this.input[this.pos + 1]);\n            }\n        }\n        else {\n            // Parse whole part\n            while (reIntDigit.test(this.input[this.pos])) {\n                rawValue += this.input[this.pos];\n                this.advance();\n            }\n            // Parse decimal point and fractional part\n            if (this.input[this.pos] === \".\") {\n                hasDecimal = true;\n                rawValue += \".\";\n                this.advance();\n                while (reIntDigit.test(this.input[this.pos])) {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n            }\n            // Parse scientific notation (e.g., e10 or E10)\n            if (this.input[this.pos] === \"e\" || this.input[this.pos] === \"E\") {\n                hasExponent = true;\n                rawValue += this.input[this.pos];\n                this.advance();\n                if (this.input[this.pos] === \"+\" || this.input[this.pos] === \"-\") {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n                while (reIntDigit.test(this.input[this.pos])) {\n                    rawValue += this.input[this.pos];\n                    this.advance();\n                }\n            }\n        }\n        let tokenType = TokenType.NUMBER;\n        let numberValue;\n        // if the next char is 'n', then it is a BigInt literal\n        if (this.input[this.pos] === \"n\") {\n            tokenType = TokenType.BIGINT;\n            numberValue = BigInt(prefix + rawValue);\n            rawValue += \"n\";\n            this.advance();\n        }\n        else if (this.input[this.pos] === \"m\") {\n            // Decimal literal\n            tokenType = TokenType.DECIMAL;\n            numberValue = new Decimal(rawValue);\n            rawValue += \"f\";\n            this.advance();\n        }\n        else {\n            if (base === 10 && (hasDecimal || hasExponent)) {\n                numberValue = parseFloat(rawValue);\n            }\n            else {\n                numberValue = parseInt(rawValue, base);\n                if (isNaN(numberValue)) {\n                    assertNever(\"Expected a number but got NaN\", this.currentPosition.getStartPos());\n                }\n            }\n        }\n        return Token.init(start, startRow, startCol, prefix + rawValue, numberValue, tokenType, subType);\n    }\n    parseLiteralOrOpenString() {\n        const start = this.pos;\n        const startRow = this.row;\n        const startCol = this.col;\n        let value = \"\";\n        let normalizeString = false;\n        while (!this.reachedEnd && is.isValidOpenStringChar(this.input[this.pos])) {\n            let char = this.input[this.pos];\n            if (is.isWhitespace(char)) {\n                value += this.skipWhitespaces();\n                continue;\n            }\n            if (char === Symbols.MINUS) {\n                // if the next two chars are -- that means it is a\n                // section seperator.\n                if (this.input.substring(this.pos, this.pos + 3) === \"---\") {\n                    break;\n                }\n            }\n            if (char === Symbols.BACKSLASH) {\n                try {\n                    ({ value, needToNormalize: normalizeString } = this.escapeString(value, normalizeString));\n                    // escapeString has already advanced the position, so continue to next iteration\n                    continue;\n                }\n                catch (error) {\n                    // For open strings, preserve the backslash and the escape character\n                    // Note: escapeString has already advanced past the backslash, so pos is at the escape char\n                    value += \"\\\\\";\n                    if (!this.reachedEnd) {\n                        const escapeChar = this.input[this.pos];\n                        value += escapeChar; // Add the escape character (u, x, etc.)\n                        // For \\u and \\x sequences, we need to add the invalid hex digits too\n                        if (escapeChar === 'u') {\n                            // Add the next 4 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 4 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else if (escapeChar === 'x') {\n                            // Add the next 2 characters (or until end of input)\n                            this.advance();\n                            for (let i = 0; i < 2 && !this.reachedEnd; i++) {\n                                value += this.input[this.pos];\n                                this.advance();\n                            }\n                            continue;\n                        }\n                        else {\n                            this.advance();\n                        }\n                    }\n                    continue;\n                }\n            }\n            else {\n                value += char;\n                this.advance();\n            }\n        }\n        value = value.trimEnd();\n        if (normalizeString) {\n            value = value.normalize(\"NFC\");\n        }\n        if (value === \"\") {\n            return null;\n            // assertNever(this.input[this.pos])\n        }\n        switch (value) {\n            case Literals.TRUE:\n            case Literals.T:\n                return Token.init(start, startRow, startCol, value, true, TokenType.BOOLEAN);\n            case Literals.FALSE:\n            case Literals.F:\n                return Token.init(start, startRow, startCol, value, false, TokenType.BOOLEAN);\n            case Literals.NULL:\n            case Literals.N:\n                return Token.init(start, startRow, startCol, value, null, TokenType.NULL);\n            case Literals.Inf:\n            case Literals.NaN:\n                return Token.init(start, startRow, startCol, value, value === Literals.Inf ? Infinity : NaN, TokenType.NUMBER);\n            default:\n                return Token.init(start, startRow, startCol, value, value, TokenType.STRING, \"OPEN_STRING\");\n        }\n    }\n    /**\n     * Merges the two tokens into one token. This is used to merge the\n     * tokens detected by various tokenizer functions.\n     */\n    mergeTokens(first, second) {\n        const token = new Token();\n        token.pos = first.pos;\n        token.row = first.row;\n        token.col = first.col;\n        token.token = first.token + second.token;\n        token.value = first.token + second.value.toString();\n        token.type = second.type;\n        token.subType = second.subType;\n        return token;\n    }\n    /**\n     * Skip over any whitespaces and return them as a string.\n     * @returns {string} The skipped whitespaces.\n     */\n    skipWhitespaces(hspacesOnly = false) {\n        const startPos = this.pos;\n        while (!this.reachedEnd && is.isWhitespace(this.input[this.pos], hspacesOnly)) {\n            const space = this.input[this.pos];\n            // replace \\r\\n or \\r with \\n. This behavior is configurable\n            // with the normalizeNewline option\n            if (space === '\\r') {\n                if (this.input[this.pos + 1] === '\\n') {\n                    this.advance();\n                }\n                this.advance();\n            }\n            else {\n                this.advance();\n            }\n        }\n        // Optimize: use substring instead of character-by-character concatenation\n        if (startPos === this.pos) {\n            return '';\n        }\n        let spaces = this.input.substring(startPos, this.pos);\n        // Only normalize if we found \\r characters\n        if (spaces.includes('\\r')) {\n            spaces = spaces.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n        }\n        return spaces;\n    }\n    /**\n     * Tokenize the input string.\n     * @returns {Token[]} Array of parsed tokens.\n     */\n    tokenize() {\n        // Pre-allocate array with estimated size for better performance\n        const estimatedTokens = Math.max(10, Math.floor(this.inputLength / 8));\n        const tokens = new Array(estimatedTokens);\n        let tokenIndex = 0;\n        while (this.pos < this.inputLength) {\n            const charCode = this.input.charCodeAt(this.pos);\n            // Whitespaces - use fast character code checking\n            if (isWhitespaceFast(charCode)) {\n                // Skip over the whitespace\n                this.advance();\n                continue;\n            }\n            // Single-line comments\n            else if (charCode === CHAR_CODES.HASH) {\n                this.parseSingleLineComment();\n            }\n            // Regular strings\n            else if (charCode === CHAR_CODES.DOUBLE_QUOTE || charCode === CHAR_CODES.SINGLE_QUOTE) {\n                tokens[tokenIndex++] = this.parseRegularString(this.input[this.pos]);\n            }\n            // Special symbols (e.g., curly braces, brackets, etc.) - use fast character code checking\n            else if (this.isSpecialSymbolFast(charCode)) {\n                const startRow = this.row;\n                const startCol = this.col;\n                const ch = this.input[this.pos];\n                tokens[tokenIndex++] = Token.init(this.pos, startRow, startCol, ch, ch, this.getSymbolTokenTypeFast(charCode));\n                this.advance();\n            }\n            // Numbers\n            else if (charCode === CHAR_CODES.PLUS || charCode === CHAR_CODES.MINUS || charCode === CHAR_CODES.DOT || isDigitFast(charCode)) {\n                // Check if it is a SECTION_SEP ---\n                if (charCode === CHAR_CODES.MINUS) {\n                    // If the next two chars are -- that means it is a\n                    // data seperator.\n                    if (this.input.substring(this.pos, this.pos + 3) === \"---\") {\n                        tokenIndex = this.parseSectionSeparator(tokens, tokenIndex);\n                        continue;\n                    }\n                }\n                const token = this.parseNumber();\n                if (token) {\n                    const spaces = this.skipWhitespaces();\n                    if (!this.reachedEnd) {\n                        // If the next character (2abc) is not a symbol or whitespace, then\n                        // it must be a literal or open string. Parse it and merge it\n                        // with the number token.\n                        if (!is.isSpecialSymbol(this.input[this.pos]) &&\n                            !is.isWhitespace(this.input[this.pos])) {\n                            const nextToken = this.parseLiteralOrOpenString();\n                            if (nextToken) {\n                                nextToken.type = TokenType.STRING;\n                                nextToken.subType = \"OPEN_STRING\";\n                                if (spaces.length > 0) {\n                                    nextToken.token = spaces + nextToken.token;\n                                    nextToken.value = spaces + nextToken.value;\n                                }\n                                tokens[tokenIndex++] = this.mergeTokens(token, nextToken);\n                            }\n                            else {\n                                tokens[tokenIndex++] = token;\n                            }\n                        }\n                        else {\n                            tokens[tokenIndex++] = token;\n                        }\n                    }\n                    else {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n                else {\n                    // It wasn't a number, so it must be a literal or open string\n                    const token = this.parseLiteralOrOpenString();\n                    if (token) {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n            }\n            // Literals or open strings\n            else {\n                const annotation = this.checkIfAnotatedString();\n                if (annotation) {\n                    switch (annotation.name) {\n                        case \"r\":\n                            tokens[tokenIndex++] = this.parseRawString(annotation);\n                            break;\n                        case \"b\":\n                            tokens[tokenIndex++] = this.parseByteString(annotation);\n                            break;\n                        case \"d\":\n                        case \"dt\":\n                        case \"t\":\n                            tokens[tokenIndex++] = this.parseDateTime(annotation);\n                            break;\n                        default:\n                            const error = new SyntaxError(ErrorCodes.unsupportedAnnotation, `Unsupported annotation '${annotation.name}'. Supported annotations are: 'r' (raw string), 'b' (binary), 'dt' (datetime), 'd' (date), 't' (time).`, this.currentPosition);\n                            const tokenText = this.input.substring(this.pos, this.pos + annotation.name.length + 1);\n                            tokens[tokenIndex++] = this.createErrorToken(error, this.pos, this.row, this.col, tokenText);\n                            this.skipToNextTokenBoundary();\n                    }\n                }\n                else {\n                    const token = this.parseLiteralOrOpenString();\n                    if (token) {\n                        tokens[tokenIndex++] = token;\n                    }\n                }\n            }\n        }\n        // Return properly sized array\n        tokens.length = tokenIndex;\n        return tokens;\n    }\n    parseSectionSeparator(tokens, tokenIndex) {\n        tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, \"---\", \"---\", TokenType.SECTION_SEP);\n        this.advance(3); // Advance past the \"---\"\n        this.skipWhitespaces(true);\n        const match = reSectionSchemaName.exec(this.input.substring(this.pos));\n        if (match) {\n            let schema;\n            let name;\n            let sep = match.groups?.sep;\n            let schema2;\n            if (match.groups) {\n                schema = match.groups.schema;\n                name = match.groups.name;\n                schema2 = match.groups.schema2;\n            }\n            // When only a schema is provided, the schema is the name\n            if (schema2) {\n                tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, schema2, schema2, TokenType.STRING, TokenType.SECTION_SCHEMA);\n                this.advance(schema2.length);\n                this.skipWhitespaces(true);\n            }\n            else if (name) {\n                tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, name, name, TokenType.STRING, TokenType.SECTION_NAME);\n                this.advance(name.length);\n                this.skipWhitespaces(true);\n                if (sep) {\n                    // skip over the separator when it is present\n                    this.advance(sep.length);\n                    this.skipWhitespaces(true);\n                    // Once the sep is detected, the schema must be present\n                    if (!schema) {\n                        const error = new SyntaxError(ErrorCodes.schemaMissing, `Missing schema definition after section separator. Expected schema name starting with '$' (e.g., '$mySchema').`, this.currentPosition);\n                        tokens[tokenIndex++] = this.createErrorToken(error, this.pos, this.row, this.col, \"\");\n                        return tokenIndex;\n                    }\n                    tokens[tokenIndex++] = Token.init(this.pos, this.row, this.col, schema, schema, TokenType.STRING, TokenType.SECTION_SCHEMA);\n                    this.advance(schema.length);\n                    this.skipWhitespaces(true);\n                }\n            }\n        }\n        return tokenIndex;\n    }\n}\nexport default Tokenizer;\n","import Document from '../../core/document';\nimport SectionCollection from '../../core/section-collection';\nclass DocumentNode {\n    constructor(header, children = [], errors = []) {\n        this.header = null;\n        this.children = [];\n        this.errors = []; // Accumulated errors during parsing\n        this.header = header;\n        this.children = children;\n        this.errors = errors;\n    }\n    get firstChild() {\n        return this.children.length > 0 ? this.children[0] : null;\n    }\n    /**\n     * Returns all errors accumulated during parsing.\n     * This enables IDEs and tools to show all diagnostics in one pass.\n     */\n    getErrors() {\n        return this.errors;\n    }\n    toValue(defs) {\n        const header = this.header?.toValue(defs) ?? null;\n        const sections = new SectionCollection();\n        for (let i = 0; i < this.children.length; i++) {\n            sections.push(this.children[i].toValue(defs));\n        }\n        return new Document(header, sections);\n    }\n    getStartPos() {\n        if (this.header) {\n            return this.header.getStartPos();\n        }\n        if (this.children.length > 0) {\n            return this.children[0].getStartPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        if (this.children.length > 0) {\n            return this.children[this.children.length - 1].getEndPos();\n        }\n        if (this.header) {\n            return this.header.getEndPos();\n        }\n        return { row: 0, col: 0, pos: 0 };\n    }\n}\nexport default DocumentNode;\n","import Section from \"../../core/section\";\nimport CollectionNode from \"./collections\";\nimport ObjectNode from \"./objects\";\nclass SectionNode {\n    constructor(child, nameNode, schemaNode) {\n        this.type = 'section';\n        this.child = child;\n        this.nameNode = nameNode;\n        this.schemaNode = schemaNode;\n    }\n    get name() {\n        return this.nameNode?.value || this.schemaNode?.value.toString().substring(1) || 'unnamed';\n    }\n    get schemaName() {\n        return this.schemaNode?.value || \"$schema\";\n    }\n    get firstChild() {\n        return this.child;\n    }\n    get firstChildObject() {\n        if (this.child instanceof ObjectNode) {\n            return this.child;\n        }\n        if (this.child instanceof CollectionNode && this.child.children.length > 0) {\n            return this.child.children[0];\n        }\n        return null;\n    }\n    getStartPos() {\n        return this.child?.getStartPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    getEndPos() {\n        return this.child?.getEndPos() ?? { row: 0, col: 0, pos: 0 };\n    }\n    toValue(defs) {\n        let data = null;\n        if (this.child) {\n            data = this.child.toValue(defs);\n        }\n        return new Section(data, this.name, this.schemaName);\n    }\n}\nexport default SectionNode;\n","import assertNever from '../errors/asserts/asserts';\nimport ErrorCodes from '../errors/io-error-codes';\nimport SyntaxError from '../errors/io-syntax-error';\nimport { tokenSpanRange } from '../errors/error-range-utils';\nimport TokenType from './tokenizer/token-types';\nimport { isTerminator } from './tokenizer/is';\nimport ArrayNode from './nodes/array';\nimport CollectionNode from './nodes/collections';\nimport DocumentNode from './nodes/document';\nimport ErrorNode from './nodes/error';\nimport MemberNode from './nodes/members';\nimport ObjectNode from './nodes/objects';\nimport SectionNode from './nodes/section';\nimport TokenNode from './nodes/tokens';\nclass ASTParser {\n    constructor(tokens) {\n        this.sectionNames = {};\n        this.errors = []; // Accumulated errors during parsing\n        this.tokens = tokens;\n        this.current = 0;\n    }\n    parse() {\n        return this.processDocument();\n    }\n    /**\n     * Creates a syntax error with proper range spanning the entire construct.\n     * Industry standard: Error should highlight from start token to end token.\n     *\n     * @param errorCode - The error code\n     * @param message - Error message\n     * @param startToken - Opening token of the construct (e.g., '{' or '[')\n     * @param members - Array of parsed members/elements (to find last token) - can include undefined\n     * @returns SyntaxError with range spanning the entire construct\n     */\n    createUnclosedConstructError(errorCode, message, startToken, members) {\n        // Find the end position by looking backwards from current, skipping boundary tokens\n        let errorEndToken = null;\n        // Start from the token before current position\n        let checkIndex = this.current - 1;\n        // Skip backwards over any boundary tokens (~ or ---)\n        while (checkIndex >= 0) {\n            const token = this.tokens[checkIndex];\n            if (token &&\n                token.type !== TokenType.COLLECTION_START &&\n                token.type !== TokenType.SECTION_SEP) {\n                errorEndToken = token;\n                break;\n            }\n            checkIndex--;\n        }\n        // Create the error with proper range spanning the entire construct\n        if (startToken && errorEndToken) {\n            const range = tokenSpanRange(startToken, errorEndToken);\n            return new SyntaxError(errorCode, message, range, false);\n        }\n        else if (startToken) {\n            // Fallback: use start token only\n            return new SyntaxError(errorCode, message, startToken, false);\n        }\n        else {\n            // No tokens available - create error without position\n            return new SyntaxError(errorCode, message, undefined, true);\n        }\n    }\n    processDocument() {\n        const sections = new Array();\n        let header = null;\n        let token = this.peek();\n        let first = true;\n        while (true) {\n            if (first) {\n                // When the first token is a section separator, it means that\n                // header section is not present. Just skip the section separator\n                if (token?.type === TokenType.SECTION_SEP) {\n                    first = false;\n                }\n            }\n            const section = this.processSection(first);\n            token = this.peek();\n            if (!token) {\n                sections.push(section);\n                break;\n            }\n            if (first) {\n                header = section;\n            }\n            else {\n                sections.push(section);\n            }\n            if (first)\n                first = false;\n            // If the next token is not a section separator, it means that\n            // the current section is not closed properly. Add error and stop\n            if (token.type !== TokenType.SECTION_SEP) {\n                const error = new SyntaxError(ErrorCodes.unexpectedToken, `Expected section separator '---' but found '${token.token}'. Each section must be properly closed before starting a new one.`, token);\n                this.errors.push(error);\n                break; // Stop parsing but return partial document\n            }\n            // Move to the next token and check if it is a section separator\n            // or the end of file\n            this.advance();\n        }\n        // If there are more than one sections, and the document does not start\n        // with --- then the first one is the header.\n        // section. Remove it from the sections array and return it as the header\n        // if (sections.length > 1 && this.tokens[0].type !== TokenType.SECTION_SEP) {\n        //   const header = sections.shift();\n        //   return new DocumentNode(header ?? null, sections);\n        // }\n        return new DocumentNode(header, sections, this.errors);\n    }\n    processSection(first) {\n        let token = this.peek();\n        // Consume the section separator if present\n        if (token?.type === TokenType.SECTION_SEP) {\n            this.advance();\n        }\n        // If the first token is a section separator, it means that\n        // the section has started without a section name. A header\n        // section does not have a name.\n        const [schemaNode, nameNode] = this.parseSectionAndSchemaNames();\n        let name = nameNode?.value || schemaNode?.value.toString().substring(1) || 'unnamed';\n        const originalName = name;\n        // Check if the section name is already used - implement auto-rename for error recovery\n        if (name && this.sectionNames[name]) {\n            const error = new SyntaxError(ErrorCodes.unexpectedToken, `Duplicate section name '${name}'. Each section must have a unique name within the document.`, void 0, false);\n            this.errors.push(error); // Accumulate error\n            // Auto-rename: users -> users_2, users_3, etc.\n            let suffix = 2;\n            while (this.sectionNames[`${originalName}_${suffix}`]) {\n                suffix++;\n            }\n            name = `${originalName}_${suffix}`;\n            // Update the nameNode with the renamed value\n            if (nameNode) {\n                nameNode.value = name;\n            }\n        }\n        if (!first || (first && name !== 'unnamed' && this.peek()?.type !== TokenType.SECTION_SEP)) {\n            this.sectionNames[name] = true;\n        }\n        const section = this.parseSectionContent();\n        return new SectionNode(section, nameNode, schemaNode);\n    }\n    parseSectionAndSchemaNames() {\n        let schemaNode = null;\n        let nameNode = null;\n        let token = this.peek();\n        if (token?.subType === TokenType.SECTION_NAME) {\n            nameNode = token;\n            // Consume the section name\n            this.advance();\n            token = this.peek();\n            if (token?.subType === TokenType.SECTION_SCHEMA) {\n                schemaNode = token;\n                // Consume the section name\n                this.advance();\n            }\n        }\n        else if (token?.subType === TokenType.SECTION_SCHEMA) {\n            schemaNode = token;\n            // Consume the section name\n            this.advance();\n            token = this.peek();\n        }\n        return [schemaNode, nameNode];\n    }\n    parseSectionContent() {\n        const token = this.peek();\n        if (!token)\n            return null;\n        if (token.type === TokenType.SECTION_SEP) {\n            return null;\n        }\n        // Parse the collection ~\n        if (token.type === TokenType.COLLECTION_START) {\n            return this.processCollection();\n        }\n        // Parse the single object {}\n        return this.processObject(false);\n    }\n    processCollection() {\n        const objects = [];\n        while (this.match(ASTParser.COLLECTION_START_ARRAY)) {\n            // Consume the COLLECTION_START token\n            this.advance();\n            // Remember the position before parsing the item (for fallback)\n            const itemStartPos = this.current;\n            // Check if the first token of this collection item is an ERROR token\n            // If so, treat the entire item as an ErrorNode\n            const firstToken = this.peek();\n            if (firstToken && firstToken.type === TokenType.ERROR) {\n                const errorValue = firstToken.value;\n                const errorNode = new ErrorNode(errorValue.originalError, firstToken);\n                this.errors.push(errorValue.originalError);\n                objects.push(errorNode);\n                this.advance(); // Consume the error token\n                this.skipToNextCollectionItem();\n                continue;\n            }\n            try {\n                // Parse the object and add to the collection\n                objects.push(this.processObject(true));\n            }\n            catch (error) {\n                // Accumulate error for Phase 2\n                this.errors.push(error);\n                // Create error node with actual error position\n                let position = { pos: -1, row: -1, col: -1 };\n                let endPosition = undefined;\n                // Extract position from IOError if available\n                if (error && typeof error === 'object' && 'positionRange' in error) {\n                    const posRange = error.positionRange;\n                    if (posRange && posRange.getStartPos) {\n                        position = posRange.getStartPos();\n                        endPosition = posRange.getEndPos ? posRange.getEndPos() : undefined;\n                    }\n                }\n                // Fallback: if no position in error, use the last valid token position\n                if (position.pos === -1 && this.current > 0 && this.current <= this.tokens.length) {\n                    const lastToken = this.tokens[this.current - 1];\n                    if (lastToken) {\n                        position = lastToken.getEndPos(); // Use end position of last token\n                        endPosition = position; // Point to same location\n                    }\n                }\n                objects.push(new ErrorNode(error, position, endPosition));\n                this.skipToNextCollectionItem();\n            }\n            // No explicit delimiter check is required since the `~`\n            // itself acts as both a delimiter and an indicator for\n            // the next object.\n        }\n        return new CollectionNode(objects);\n    }\n    /**\n     * Skips tokens until the next collection item (COLLECTION_START token) or section end.\n     * This is used for error recovery in collection parsing.\n     */\n    skipToNextCollectionItem() {\n        // Skip tokens until we find next `~` (COLLECTION_START) or section end\n        while (this.peek() &&\n            !this.match(ASTParser.COLLECTION_OR_SECTION_ARRAY)) {\n            this.advance();\n        }\n    }\n    /**\n     * Skips tokens to the next synchronization point after an error.\n     * Synchronization points are terminator tokens (structural boundaries).\n     * This enables error recovery by finding a safe place to resume parsing.\n     */\n    skipToNextSyncPoint() {\n        while (this.peek()) {\n            const token = this.peek();\n            if (!token)\n                break;\n            // Check if we've reached a terminator token (structural boundary at token level)\n            // Note: We check token.type (e.g., \"COMMA\", \"COLON\") not raw characters\n            // because we're in the parser working with tokens, not the tokenizer working with chars.\n            // Use isTerminator() for token types, not isCharTerminator() for characters.\n            if (isTerminator(token.type)) {\n                break; // Found a synchronization point, stop here\n            }\n            this.advance();\n        }\n    }\n    processObject(isCollectionContext) {\n        const obj = this.parseObject(true);\n        // Even after parsing the object, if there is still a token\n        // left, it means that the object is not closed properly.\n        const token = this.peek();\n        this.checkForPendingTokens(token, isCollectionContext);\n        // If there is only one member in the object, and it has no key,\n        // then the object is not an open object. In this case, we need\n        // unwrap the object\n        // For example. { {} } should be unwrapped to {}\n        // {} should be unwrapped to []\n        // 'a' should be unwrapped to [a]\n        // 'a', 'b', 'c' should be unwrapped to [a, b, c]\n        // {}, 'b', 'c' should be unwrapped to [{}, b, c]\n        // {{}} should be unwrapped to [{}]\n        if (obj.children.length === 1) {\n            const firstMember = obj.children[0];\n            if (firstMember && !firstMember.key && firstMember.value) {\n                if (firstMember.value instanceof ObjectNode) {\n                    return firstMember.value;\n                }\n            }\n        }\n        return obj;\n    }\n    checkForPendingTokens(token, isCollectionContext) {\n        if (!token)\n            return;\n        if (token.type === TokenType.SECTION_SEP)\n            return;\n        if (isCollectionContext && token.type === TokenType.COLLECTION_START)\n            return;\n        throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected token '${token.value}'. Expected end of section or start of new collection item '~'.`, token, false);\n    }\n    parseObject(isOpenObject) {\n        const members = [];\n        let openBracket = this.peek();\n        if (isOpenObject) {\n            openBracket = null;\n        }\n        if (!isOpenObject && !this.advanceIfMatch(ASTParser.CURLY_OPEN_ARRAY)) {\n            assertNever(\"The caller must ensure that this function is called \" +\n                \"only when the next token is {\");\n        }\n        let index = 0;\n        let done = false;\n        let expectingValueAfterComma = true; // After '{', we're expecting the first value (or empty position)\n        while (!done) {\n            const nextToken = this.peek();\n            // DEBUG\n            const DEBUG_PARSE_OBJECT = false; // Set to true to debug\n            if (DEBUG_PARSE_OBJECT && members.length < 3) {\n                const prevToken = this.tokens[this.current - 1];\n                console.log(`  loop: current=${this.current}, next=${nextToken?.type}, prev=${prevToken?.type}, expecting=${expectingValueAfterComma}, members=${members.length}`);\n            }\n            if (!nextToken || this.match([TokenType.CURLY_CLOSE, TokenType.COLLECTION_START, TokenType.SECTION_SEP])) {\n                // If we were expecting a value after a comma but hit end/close, that position is empty\n                if (expectingValueAfterComma) {\n                    const prevToken = this.tokens[this.current - 1];\n                    if (prevToken && prevToken.type === TokenType.COMMA) {\n                        this.pushUndefinedMember(members, prevToken);\n                    }\n                }\n                done = true;\n                break;\n            }\n            else if (nextToken.type === TokenType.COMMA) {\n                // If we're expecting a value but got a comma, the current position is empty\n                if (expectingValueAfterComma) {\n                    // Use the comma token itself for position tracking\n                    this.pushUndefinedMember(members, nextToken);\n                }\n                // Consume the comma and mark that we're now expecting a value\n                this.advance();\n                expectingValueAfterComma = true;\n                continue;\n            }\n            else {\n                // We found a value\n                // The member must be preceded by a comma, open bracket, or\n                // the beginning of the object. Otherwise it is invalid\n                // For example, { a: 1, b: 2 } is valid, but { a: 1 b: 2 } is not\n                if (index > 0) {\n                    if (!this.matchPrev([TokenType.COMMA, TokenType.CURLY_OPEN])) {\n                        throw new SyntaxError(ErrorCodes.unexpectedToken, `Missing comma before '${nextToken.value}'. Object members must be separated by commas.`, nextToken, false);\n                    }\n                }\n                const member = this.parseMember();\n                members.push(member);\n                index++;\n                expectingValueAfterComma = false; // We got the value\n            }\n        }\n        // Now, expect a closing bracket if not open object\n        if (!isOpenObject) {\n            if (!this.match(ASTParser.CURLY_CLOSE_ARRAY)) {\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing brace '}'. Object must be properly closed.`, openBracket, members);\n            }\n            let closeBracket = this.peek();\n            this.advance();\n            return new ObjectNode(members, openBracket, closeBracket);\n        }\n        else {\n            return new ObjectNode(members);\n        }\n    }\n    parseMember() {\n        const leftToken = this.peek();\n        if (!leftToken) {\n            assertNever(\"The caller must ensure that this function is called \" +\n                \"only when the member has at least one token\");\n        }\n        if (this.matchNext(ASTParser.COLON_ARRAY)) {\n            const isValidKey = ASTParser.VALID_KEY_TYPES.includes(leftToken.type);\n            if (isValidKey) {\n                // Consume the key and colon\n                this.advance(2);\n                // Parse the value and return the key-value pair\n                const value = this.parseValue();\n                return new MemberNode(value, leftToken);\n            }\n            else {\n                throw new SyntaxError(ErrorCodes.invalidKey, `Invalid key '${leftToken.token}'. Object keys must be strings, numbers, booleans, or null.`, leftToken, false);\n            }\n        }\n        // If the next token is not a colon, that means it is\n        // a value without a key. In this case the key is\n        // the index of the value\n        return new MemberNode(this.parseValue());\n    }\n    parseArray() {\n        const arr = [];\n        const openBracket = this.peek();\n        if (!openBracket || openBracket.type !== TokenType.BRACKET_OPEN) {\n            throw new SyntaxError(ErrorCodes.expectingBracket, `Expected opening bracket '[' to start array but found '${openBracket?.token || 'end of input'}'.`, openBracket === null ? void 0 : openBracket, openBracket === null);\n        }\n        // Consume the opening bracket\n        this.advance();\n        while (true) {\n            const currentToken = this.peek();\n            if (!currentToken) {\n                // Unexpected end of input\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Unexpected end of input while parsing array. Expected closing bracket ']'.`, openBracket, arr);\n            }\n            if (currentToken.type === TokenType.BRACKET_CLOSE) {\n                break;\n            }\n            else if (currentToken.type === TokenType.COLLECTION_START ||\n                currentToken.type === TokenType.SECTION_SEP) {\n                // Reached a synchronization boundary without closing the array\n                throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing bracket ']'. Array must be properly closed.`, openBracket, arr);\n            }\n            else if (currentToken.type === TokenType.COMMA) {\n                // If the next token is a comma or a closing bracket, it implies an undefined\n                // element in the array, which is not allowed. Throw an error.\n                if (this.matchNext([TokenType.COMMA, TokenType.BRACKET_CLOSE])) {\n                    const nextToken = this.tokens[this.current + 1];\n                    throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected comma. Array elements cannot be empty - remove the extra comma or add a value.`, nextToken, false);\n                }\n                // consume the current comma\n                this.advance();\n                continue;\n            }\n            const member = this.parseMember();\n            if (member.key) {\n                arr.push(new ObjectNode([member]));\n            }\n            else {\n                arr.push(member.value);\n            }\n        }\n        // Now, expect a closing bracket\n        if (!this.match(ASTParser.BRACKET_CLOSE_ARRAY)) {\n            throw this.createUnclosedConstructError(ErrorCodes.expectingBracket, `Missing closing bracket ']'. Array must be properly closed.`, openBracket, arr);\n        }\n        const closeBracket = this.peek();\n        this.advance();\n        // Both openBracket and closeBracket are guaranteed to be Token (not null) here\n        return new ArrayNode(arr, openBracket, closeBracket);\n    }\n    parseValue() {\n        const token = this.peek();\n        if (!token) {\n            throw new SyntaxError(ErrorCodes.valueRequired, `Unexpected end of input. Expected a value (string, number, boolean, null, array, or object).`, void 0, true);\n        }\n        switch (token.type) {\n            case TokenType.STRING:\n            case TokenType.NUMBER:\n            case TokenType.BIGINT:\n            case TokenType.DECIMAL:\n            case TokenType.BOOLEAN:\n            case TokenType.NULL:\n            case TokenType.DATETIME: {\n                const node = new TokenNode(token);\n                this.advance();\n                return node;\n            }\n            case TokenType.BRACKET_OPEN:\n                return this.parseArray();\n            case TokenType.CURLY_OPEN:\n                return this.parseObject(false);\n            case TokenType.ERROR: {\n                // Handle error tokens from tokenizer (e.g., unterminated strings)\n                // The current node becomes invalid, so we create an ErrorNode and skip to next sync point\n                const errorValue = token.value;\n                const errorNode = new ErrorNode(errorValue.originalError, token);\n                this.errors.push(errorValue.originalError); // Add to error collection\n                this.advance(); // Move past the error token\n                // Skip to next synchronization boundary (collection/section delimiter or comma)\n                // This helps recover from the error and continue parsing the next valid item\n                this.skipToNextSyncPoint();\n                return errorNode;\n            }\n            default:\n                throw new SyntaxError(ErrorCodes.unexpectedToken, `Unexpected token '${token.value}'. Expected a valid value (string, number, boolean, null, array, or object).`, token, token === null);\n        }\n    }\n    pushUndefinedMember(members, curerntCommaToken) {\n        const valueNode = curerntCommaToken.clone();\n        valueNode.type = TokenType.UNDEFINED;\n        valueNode.value = void 0;\n        const member = new MemberNode(new TokenNode(valueNode));\n        members.push(member);\n    }\n    /**\n     * Type guard to check if a token is valid (not null)\n     */\n    isValidToken(token) {\n        return token !== null;\n    }\n    /**\n     * Returns the current token without advancing the current index\n     * @returns {Token} the current token or null if eof is reached\n     */\n    peek() {\n        return this.current < this.tokens.length ? this.tokens[this.current] : null;\n    }\n    /**\n     * Advances the current token index by the given number of steps\n     */\n    advance(steps = 1) {\n        this.current += steps;\n    }\n    /**\n     * Checks if the current token matches any of the given types.\n     * If a current token is not available, returns false.\n     * @param types - Array of token types to match against\n     * @returns true if current token matches any of the given types\n     */\n    match(types) {\n        const currentToken = this.peek();\n        if (this.isValidToken(currentToken) && types.includes(currentToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    matchPrev(types) {\n        const prevToken = this.tokens[this.current - 1];\n        if (this.isValidToken(prevToken) && types.includes(prevToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Match the next token in the stream without advancing the current index.\n     * If the next token matches any of the given types, returns true, otherwise returns false.\n     * If the next token is not available, returns false.\n     * @param types - Array of token types to match against\n     * @returns true if next token matches any of the given types\n     */\n    matchNext(types) {\n        if (this.current + 1 >= this.tokens.length) {\n            return false;\n        }\n        const nextToken = this.tokens[this.current + 1];\n        if (this.isValidToken(nextToken) && types.includes(nextToken.type)) {\n            return true;\n        }\n        return false;\n    }\n    advanceIfMatch(types) {\n        if (this.match(types)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n}\n// Cached arrays for performance optimization\nASTParser.CURLY_OPEN_ARRAY = [TokenType.CURLY_OPEN];\nASTParser.CURLY_CLOSE_ARRAY = [TokenType.CURLY_CLOSE];\nASTParser.BRACKET_OPEN_ARRAY = [TokenType.BRACKET_OPEN];\nASTParser.BRACKET_CLOSE_ARRAY = [TokenType.BRACKET_CLOSE];\nASTParser.COLLECTION_START_ARRAY = [TokenType.COLLECTION_START];\nASTParser.SECTION_SEP_ARRAY = [TokenType.SECTION_SEP];\nASTParser.COMMA_ARRAY = [TokenType.COMMA];\nASTParser.COLON_ARRAY = [TokenType.COLON];\nASTParser.COLLECTION_OR_SECTION_ARRAY = [TokenType.COLLECTION_START, TokenType.SECTION_SEP];\nASTParser.VALID_KEY_TYPES = [\n    TokenType.STRING,\n    TokenType.NUMBER,\n    TokenType.BOOLEAN,\n    TokenType.NULL,\n];\nexport default ASTParser;\n","import Document from '../core/document';\nimport Header from '../core/header';\nimport Section from '../core/section';\nimport SectionCollection from '../core/section-collection';\nimport assertNever from '../errors/asserts/asserts';\nimport InternetObjectError from '../errors/io-error';\nimport ErrorCodes from '../errors/io-error-codes';\nimport compileObject from '../schema/compile-object';\nimport processSchema from '../schema/processor';\nimport Schema from '../schema/schema';\nimport Tokenizer from './tokenizer';\nimport TokenType from './tokenizer/token-types';\nimport ASTParser from './ast-parser';\nimport CollectionNode from './nodes/collections';\nimport ObjectNode from './nodes/objects';\nimport ErrorNode from './nodes/error';\nexport default function parse(source, externalDefs, o = {}) {\n    // Tokenize the source\n    const tokenizer = new Tokenizer(source);\n    const tokens = tokenizer.tokenize();\n    // If the source is empty, then return empty document\n    if (tokens.length === 0) {\n        return new Document(new Header(), new SectionCollection());\n    }\n    // Parse the tokens into AST - optimize for simple cases\n    const parser = new ASTParser(tokens);\n    const docNode = parser.parse();\n    // Extract errors from docNode for transfer to Document\n    const errors = docNode.getErrors();\n    // Create document with optimized initialization\n    const doc = new Document(new Header(), new SectionCollection(), errors);\n    // If the docNode contains header, then parse it\n    if (docNode.header) {\n        if (docNode.header.child) {\n            // If ObjectNode, it is a default schema\n            //\n            // name, age, address  # <-- This is a schema\n            // ---\n            if (docNode.header.child instanceof ObjectNode) {\n                const schema = compileObject(\"schema\", docNode.header.child);\n                if (schema instanceof Schema) {\n                    doc.header.definitions?.push(\"$schema\", schema, true);\n                    doc.header.schema = schema; // Set as the default schema\n                }\n                else {\n                    assertNever(schema);\n                }\n            }\n            // If CollectionNode, it's always definitions (may include $schema, @variables, or regular key-values)\n            // Example: ~ $schema: {...}, ~ @x: 10, ~ success: T\n            else if (docNode.header.child instanceof CollectionNode) {\n                parseDefs(doc, docNode.header.child);\n            }\n            // Unexpected node\n            else {\n                assertNever(docNode.header.child);\n            }\n            if (externalDefs) {\n                doc.header.definitions.merge(externalDefs, false);\n            }\n        }\n        else {\n            if (externalDefs) {\n                doc.header.definitions.merge(externalDefs, false);\n            }\n        }\n        parseDataWithSchema(docNode, doc);\n    }\n    else {\n        if (externalDefs) {\n            doc.header.definitions.merge(externalDefs, false);\n        }\n        parseDataWithSchema(docNode, doc);\n    }\n    return doc;\n}\nfunction parseData(docNode, doc) {\n    for (let i = 0; i < docNode.children.length; i++) {\n        const sectionNode = docNode.children[i];\n        doc.sections?.push(new Section(sectionNode.child?.toValue(doc.header.definitions || undefined), sectionNode.name));\n    }\n}\nfunction parseDataWithSchema(docNode, doc) {\n    const sectionsLen = docNode.children.length;\n    // Early return if no sections\n    if (sectionsLen === 0) {\n        return;\n    }\n    // Create error collector for validation errors\n    const validationErrors = [];\n    for (let i = 0; i < sectionsLen; i++) {\n        const sectionNode = docNode.children[i];\n        const schemaName = sectionNode.schemaName;\n        // If no explicit schema name, fall back to document's default schema\n        const schema = schemaName\n            ? (schemaName === \"$schema\" ? doc.header.schema : doc.header.definitions?.getV(sectionNode.schemaNode))\n            : doc.header.schema;\n        if (!schema) {\n            // No schema for this section, just parse without validation\n            doc.sections?.push(new Section(sectionNode.child?.toValue(doc.header.definitions || undefined), sectionNode.name));\n            continue;\n        }\n        const result = processSchema(sectionNode.child, schema, doc.header.definitions || undefined, validationErrors);\n        doc.sections?.push(new Section(result, sectionNode.name, schemaName));\n    }\n    // Append validation errors to document (parser errors are already there from constructor)\n    if (validationErrors.length > 0) {\n        doc.addErrors(validationErrors);\n    }\n}\nfunction parseDefs(doc, cols) {\n    const defs = doc.header.definitions;\n    if (!defs) {\n        throw new Error(\"Document header definitions not initialized. This is an internal error - please report this issue.\");\n    }\n    const schemaDefs = [];\n    for (let i = 0; i < cols.children.length; i++) {\n        const child = cols.children[i];\n        // If child is null or undefined then skip\n        if (!child) {\n            continue;\n        }\n        if (child instanceof ErrorNode) {\n            throw new InternetObjectError(ErrorCodes.invalidDefinition, `Invalid definition: ${child.error.message}`, child);\n        }\n        // Must be an object node\n        if (!(child instanceof ObjectNode)) {\n            assertNever(\"Invalid definition, must be object\");\n        }\n        // Type assertion after instance check - TypeScript now knows child is ObjectNode\n        const objectNode = child;\n        // Must not be null\n        if (objectNode.children[0] === null) {\n            assertNever(\"Invalid definition\");\n        }\n        // Must have only one child\n        if (objectNode.children.length !== 1) {\n            // throw new InternetObjectError(ErrorCodes.invalidDefinition, objectNode.children?.[1], objectNode.children?[1])\n        }\n        const memberNode = objectNode.children[0];\n        // Must have a key\n        if (!memberNode.key) {\n            throw new InternetObjectError(ErrorCodes.invalidDefinition, `Invalid definition: missing key. Each definition must have a key (e.g., '$schema: {...}' or '@variable: value').`, memberNode.value);\n        }\n        const keyToken = memberNode.key;\n        // Key must be a string\n        if (keyToken.type !== TokenType.STRING) {\n            throw new Error(\"Invalid typedef definition: key must be a string.\");\n        }\n        let key = keyToken.value;\n        // If key starts with $, then it is a schema. Dont compile it now,\n        // just keep it as it is. After all the definitions are parsed, compile\n        // the variable schemas.\n        if (key.startsWith('$')) {\n            defs.push(key, memberNode.value, true);\n            schemaDefs.push({ key, schemaDef: memberNode.value });\n            continue;\n        }\n        // If key starts with @, then it is a variable. Keep it as it is\n        if (key.startsWith('@')) {\n            defs.push(key, memberNode.value, false, true);\n            continue;\n        }\n        let value = objectNode.children[0].value;\n        defs.push(key, value.toValue(doc.header.definitions || undefined));\n    }\n    // Compile the schema definitions\n    for (let i = 0; i < schemaDefs.length; i++) {\n        const { key, schemaDef } = schemaDefs[i];\n        const def = compileObject(key, schemaDef, defs);\n        defs.set(key, def);\n    }\n}\n","import parse from \".\";\nexport default function parseDefinitions(source, externalDefs, options) {\n    source = source.trim();\n    if (!source) {\n        return null;\n    }\n    if (!source.endsWith(\"---\")) {\n        source += \"\\n---\";\n    }\n    // If the definition does not start with ~, then it must be\n    // a default schema. So, add \"~ $schema: \" in the beginning to make it a\n    // definition.\n    // if (!source.startsWith(\"~\")) {\n    //   source = \"~ $schema: \" + source\n    // }\n    const doc = parse(source, externalDefs, options);\n    return doc.header.definitions;\n}\n","/**\r\n * Error types and interfaces for the IO Playground.\r\n * Provides structured error objects to replace string-based error messages.\r\n */\r\n\r\n/**\r\n * Error category determines UI treatment (color, severity, icon).\r\n */\r\nexport type ErrorCategory = 'syntax' | 'validation' | 'runtime';\r\n\r\n/**\r\n * Precise range in source text (1-indexed lines and columns).\r\n */\r\nexport interface ErrorRange {\r\n  startLine: number;\r\n  startColumn: number;\r\n  endLine: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Structured error item with all metadata.\r\n * Replaces string-based error messages for better type safety and features.\r\n */\r\nexport interface ErrorItem {\r\n  /** Stable unique ID for de-duplication and focus management */\r\n  id: string;\r\n\r\n  /** Machine-readable error code (e.g., \"invalid-range\", \"missing-bracket\") */\r\n  code?: string;\r\n\r\n  /** Error category for UI styling and severity */\r\n  category: ErrorCategory;\r\n\r\n  /** User-facing error message */\r\n  message: string;\r\n\r\n  /** Source position range */\r\n  range: ErrorRange;\r\n\r\n  /** Which editor the error is from */\r\n  source: 'doc' | 'defs';\r\n}\r\n\r\n/**\r\n * Editor marker for Monaco.\r\n * Subset of monaco.editor.IMarkerData with our extensions.\r\n */\r\nexport interface EditorMarker {\r\n  /** Monaco severity: 8 = Error, 4 = Warning, 2 = Info, 1 = Hint */\r\n  severity: 1 | 2 | 4 | 8;\r\n\r\n  /** Error message displayed in hover */\r\n  message: string;\r\n\r\n  /** 1-indexed line number where error starts */\r\n  startLineNumber: number;\r\n\r\n  /** 1-indexed column where error starts */\r\n  startColumn: number;\r\n\r\n  /** 1-indexed line number where error ends */\r\n  endLineNumber: number;\r\n\r\n  /** 1-indexed column where error ends */\r\n  endColumn: number;\r\n\r\n  /** Optional: stable ID matching ErrorItem.id */\r\n  id?: string;\r\n\r\n  /** Optional: error category for filtering/grouping */\r\n  category?: ErrorCategory;\r\n}\r\n\r\n/**\r\n * Monaco severity constants (match monaco.MarkerSeverity enum).\r\n */\r\nexport const MonacoSeverity = {\r\n  Hint: 1,\r\n  Info: 2,\r\n  Warning: 4,\r\n  Error: 8,\r\n} as const;\r\n\r\n/**\r\n * Map error category to Monaco severity.\r\n */\r\nexport function categoryToSeverity(category: ErrorCategory): number {\r\n  switch (category) {\r\n    case 'syntax':\r\n      return MonacoSeverity.Error; // Red squiggles\r\n    case 'validation':\r\n      return MonacoSeverity.Warning; // Orange squiggles\r\n    case 'runtime':\r\n      return MonacoSeverity.Error; // Red squiggles\r\n    default:\r\n      return MonacoSeverity.Error;\r\n  }\r\n}\r\n\r\n/**\r\n * JSON decoration metadata for highlighting error objects in output.\r\n * Emitted by the parser alongside the JSON output to avoid brace-scanning.\r\n */\r\nexport interface JsonDecoration {\r\n  /** Error category for styling (syntax, validation, runtime) */\r\n  category: ErrorCategory;\r\n\r\n  /** Character offset in JSON string where error object starts */\r\n  startOffset: number;\r\n\r\n  /** Character offset in JSON string where error object ends (exclusive) */\r\n  endOffset: number;\r\n\r\n  /** Optional: matching ErrorItem.id for correlation */\r\n  errorId?: string;\r\n}\r\n\r\n/**\r\n * Generate stable error ID from range and message.\r\n */\r\nexport function generateErrorId(range: ErrorRange, message: string): string {\r\n  return `${range.startLine}:${range.startColumn}-${range.endLine}:${range.endColumn}:${message.substring(0, 20)}`;\r\n}\r\n","/**\r\n * Web Worker for parsing Internet Object documents.\r\n * Offloads parsing to prevent UI blocking on large documents.\r\n */\r\n\r\nimport type { IODefinitions } from 'internet-object';\r\nimport { parse, parseDefinitions } from 'internet-object';\r\nimport { IOError, IOSyntaxError, IOValidationError } from 'internet-object';\r\nimport { Decimal } from 'internet-object';\r\nimport type { ErrorItem, EditorMarker, ErrorRange, ErrorCategory } from '../types/errors';\r\nimport { categoryToSeverity, generateErrorId } from '../types/errors';\r\n\r\nexport interface ParseRequest {\r\n  type: 'parse';\r\n  id: string;\r\n  documentText: string;\r\n  schemaText: string | null;\r\n  skipErrors: boolean;\r\n  minifiedOutput: boolean;\r\n}\r\n\r\nexport interface ParseResponse {\r\n  type: 'result' | 'error';\r\n  id: string;\r\n  result?: {\r\n    errorMessages: string[];\r\n    errorItems: ErrorItem[];\r\n    docMarkers: EditorMarker[];\r\n    defsMarkers: EditorMarker[];\r\n    jsonText: string;\r\n    error: boolean;\r\n  };\r\n  error?: string;\r\n}\r\n\r\n// Type guard for ParseRequest\r\nfunction isParseRequest(data: any): data is ParseRequest {\r\n  return data && data.type === 'parse' && typeof data.id === 'string';\r\n}\r\n\r\n// Worker message handler\r\nself.addEventListener('message', (event: MessageEvent) => {\r\n  const data = event.data;\r\n\r\n  if (!isParseRequest(data)) {\r\n    console.error('Invalid message received by parser worker:', data);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const result = parseIO(\r\n      data.documentText,\r\n      data.schemaText,\r\n      data.skipErrors,\r\n      data.minifiedOutput\r\n    );\r\n\r\n    const response: ParseResponse = {\r\n      type: 'result',\r\n      id: data.id,\r\n      result,\r\n    };\r\n\r\n    self.postMessage(response);\r\n  } catch (error: any) {\r\n    const response: ParseResponse = {\r\n      type: 'error',\r\n      id: data.id,\r\n      error: error?.message || String(error),\r\n    };\r\n\r\n    self.postMessage(response);\r\n  }\r\n});\r\n\r\n// Parsing logic (same as compiler.ts but returns serializable result)\r\nfunction parseIO(\r\n  document: string,\r\n  defs: string | null,\r\n  skipErrors: boolean,\r\n  minifiedOutput: boolean\r\n): NonNullable<ParseResponse['result']> {\r\n  if (!defs) {\r\n    return parseDoc(document, null, skipErrors, minifiedOutput);\r\n  }\r\n\r\n  const defsResult = tryParse(defs, parseDefinitions, true, skipErrors);\r\n  if (defsResult.errorMessages.length > 0) {\r\n    return {\r\n      ...defsResult,\r\n      jsonText: '',\r\n      error: true,\r\n    };\r\n  }\r\n\r\n  return parseDoc(document, defsResult.defs, skipErrors, minifiedOutput);\r\n}\r\n\r\ninterface ParseIntermediateResult {\r\n  errorMessages: string[];\r\n  errorItems: ErrorItem[];\r\n  defs: IODefinitions | null;\r\n  output: any | null;\r\n  defsMarkers: EditorMarker[];\r\n  docMarkers: EditorMarker[];\r\n}\r\n\r\nfunction tryParse<T>(\r\n  input: string,\r\n  fn: (input: string, defs?: any) => T,\r\n  isDefs = false,\r\n  skipErrors = false\r\n): ParseIntermediateResult {\r\n  try {\r\n    const result = fn(input, null);\r\n\r\n    let accumulatedErrors: Error[] = [];\r\n    if (result && typeof (result as any).getErrors === 'function') {\r\n      accumulatedErrors = (result as any).getErrors();\r\n    }\r\n\r\n    const output = isDefs ? null : (result as any).toJSON({ skipErrors });\r\n    const defs = isDefs ? (result as IODefinitions) : null;\r\n\r\n    if (accumulatedErrors.length > 0) {\r\n      const source = isDefs ? 'defs' : 'doc';\r\n      const errorItems = accumulatedErrors\r\n        .map((e) => errorToErrorItem(e, source))\r\n        .filter((item): item is ErrorItem => item !== null);\r\n\r\n      return {\r\n        errorMessages: accumulatedErrors.map((e) => getErrorMessage(e)),\r\n        errorItems,\r\n        defs,\r\n        output,\r\n        defsMarkers: isDefs ? accumulatedErrors.flatMap(getErrorMarkers) : [],\r\n        docMarkers: isDefs ? [] : accumulatedErrors.flatMap(getErrorMarkers),\r\n      };\r\n    }\r\n\r\n    return {\r\n      errorMessages: [],\r\n      errorItems: [],\r\n      defs,\r\n      output,\r\n      defsMarkers: [],\r\n      docMarkers: [],\r\n    };\r\n  } catch (e: any) {\r\n    const source = isDefs ? 'defs' : 'doc';\r\n    const errorItem = errorToErrorItem(e, source);\r\n\r\n    return {\r\n      errorMessages: [getErrorMessage(e)],\r\n      errorItems: errorItem ? [errorItem] : [],\r\n      defs: null,\r\n      output: null,\r\n      defsMarkers: isDefs ? getErrorMarkers(e) : [],\r\n      docMarkers: isDefs ? [] : getErrorMarkers(e),\r\n    };\r\n  }\r\n}\r\n\r\nfunction parseDoc(\r\n  doc: string,\r\n  defs: IODefinitions | null,\r\n  skipErrors: boolean,\r\n  minifiedOutput: boolean\r\n): NonNullable<ParseResponse['result']> {\r\n  const intermediate = tryParse(doc, (d) => parse(d, defs), false, skipErrors);\r\n\r\n  const hasErrors = intermediate.errorMessages.length > 0;\r\n  let jsonText = '';\r\n  let error = false;\r\n\r\n  if (intermediate.output) {\r\n    jsonText = JSON.stringify(\r\n      intermediate.output,\r\n      function (k, v: any) {\r\n        if (typeof v === 'bigint') return `io:big:${v.toString()}`;\r\n        if (typeof v === 'number' && isNaN(v)) return 'io:number:NaN';\r\n        if (v instanceof Decimal) return `io:decimal:${v.toString()}`;\r\n        if (v === Infinity) return 'io:number:Inf';\r\n        if (v === -Infinity) return 'io:number:-Inf';\r\n        if (typeof v === 'undefined') return 'io:undefined';\r\n        return v;\r\n      },\r\n      minifiedOutput ? 0 : 2\r\n    );\r\n    error = hasErrors;\r\n  } else if (hasErrors) {\r\n    jsonText = '';\r\n    error = true;\r\n  }\r\n\r\n  return {\r\n    errorMessages: intermediate.errorMessages,\r\n    errorItems: intermediate.errorItems,\r\n    docMarkers: intermediate.docMarkers,\r\n    defsMarkers: intermediate.defsMarkers,\r\n    jsonText,\r\n    error,\r\n  };\r\n}\r\n\r\n// Helper functions\r\nfunction getErrorMessage(e: any): string {\r\n  if (e instanceof IOSyntaxError) return 'SYNTAX_ERROR: ' + (e?.message || String(e));\r\n  if (e instanceof IOValidationError) return 'VALIDATION_ERROR: ' + (e?.message || String(e));\r\n  return 'ERROR: ' + (e?.message || String(e));\r\n}\r\n\r\nfunction getErrorCategory(e: any): ErrorCategory {\r\n  if (e instanceof IOSyntaxError) return 'syntax';\r\n  if (e instanceof IOValidationError) return 'validation';\r\n  return 'runtime';\r\n}\r\n\r\nfunction errorToRange(e: any): ErrorRange | null {\r\n  if (!(e instanceof IOError)) return null;\r\n  const startPos: any = e.positionRange?.getStartPos();\r\n  const endPos: any = e.positionRange?.getEndPos();\r\n  if (!startPos || !endPos) return null;\r\n\r\n  return {\r\n    startLine: startPos.row,\r\n    startColumn: startPos.col,\r\n    endLine: endPos.row,\r\n    endColumn: endPos.col,\r\n  };\r\n}\r\n\r\nfunction errorToErrorItem(e: any, source: 'doc' | 'defs'): ErrorItem | null {\r\n  const range = errorToRange(e);\r\n  if (!range) return null;\r\n\r\n  const category = getErrorCategory(e);\r\n  const message = e?.message || String(e);\r\n\r\n  return {\r\n    id: generateErrorId(range, message),\r\n    code: (e as any).code,\r\n    category,\r\n    message,\r\n    range,\r\n    source,\r\n  };\r\n}\r\n\r\nfunction getErrorMarkers(e: any): EditorMarker[] {\r\n  if (!(e instanceof IOError)) return [];\r\n  const range = errorToRange(e);\r\n  if (!range) return [];\r\n\r\n  const category = getErrorCategory(e);\r\n  const severity = categoryToSeverity(category) as 1 | 2 | 4 | 8;\r\n  const message = e?.message || String(e);\r\n\r\n  const marker: EditorMarker = {\r\n    message,\r\n    severity,\r\n    startLineNumber: range.startLine,\r\n    startColumn: range.startColumn,\r\n    endLineNumber: range.endLine,\r\n    endColumn: range.endColumn,\r\n    id: generateErrorId(range, message),\r\n    category,\r\n  };\r\n  return [marker];\r\n}\r\n\r\n// Export empty object to satisfy TypeScript module requirements\r\nexport {};\r\n"],"names":["IODocument","header","sections","errors","options","_a","_b","_c","sectionsLen","data","i","section","headerObject","GeneralErrorCodes","TokenizationErrorCodes","ParsingErrorCodes","ValidationErrorCodes","ErrorCodes","__classPrivateFieldGet","receiver","state","kind","f","__classPrivateFieldSet","value","_IOError_positionRange","IOError","errorCode","fact","positionRange","isEof","ssf","errorMsg","pr","startPos","IOValidationError","InternetObjectError","posRange","TokenType","Token","pos","row","col","token","type","subType","t","text","lines","lastLine","TokenNode","defs","valueFound","Schema","name","o","item","key","SchemaBuilder","memberObjects","def","open","schema","n","IODefinitions","index","keys","k","positionParam","ValidationError","v","dv","isSchema","isVariable","other","override","obj","keysCount","IOHeader","assertNever","x","message","IOObject","items","entry","array","io","newItems","newKeyMap","callbackfn","thisArg","selector","predicate","result","IOCollection","callback","mappedItems","filteredItems","initialValue","skipErrors","getAbsoluteValue","coefficient","POW10_CACHE","getPow10","exponent","scaleUp","scaleFactor","roundHalfUp","currentScale","targetScale","scaleDiff","divisor","quotient","remainder","halfDivisor","ceilRound","floorRound","formatBigIntAsDecimal","scale","precision","sign","coeffStr","integerPart","fractionalPart","validatePrecisionScale","alignOperands","aCoefficient","aScale","bCoefficient","bScale","maxScale","roundingMode","aAdjustment","bAdjustment","adjustedA","adjustedB","DecimalError","calculateAdditionResultPrecisionScale","precision1","scale1","precision2","scale2","resultScale","integerDigits1","integerDigits2","calculateMultiplicationResultPrecisionScale","calculateDivisionResultPrecisionScale","minScale","calculatedScale","validateAndAdjustPrecisionScale","maxPrecision","effectiveMaxScale","adjustedPrecision","adjustedScale","calculateRdbmsArithmeticResult","operation","Decimal","decimalInit","regex","match","adjustedInteger","adjustedFractional","rounded","normalizedInteger","combinedNormalized","roundedCombined","coeff","fromScale","fromCoefficient","targetIntegerDigits","actualIntegerDigits","scaleDifference","newCoefficient","roundedCoefficient","_precision","intRaw","fracRaw","adjusted","formatted","str","trimmed","mantissa","exponentPart","integerPartRaw","fractionalPartRaw","absExp","absCoeffStr","numberStr","numberValue","targetPrecision","error","roundedCoeff","decimalStr","ceiledCoeff","flooredCoeff","aCoeff","bCoeff","q","remainderCoeff","digits","finalPrecision","resultStr","calcPrecision","calcScale","sumCoeff","diffCoeff","resultCoeff","intermediateScale","adjustedCoeff","resultDigits","exponentAdjustment","numerator","down","denominator","absDen","isNegative","IOSection","_schemaName","IOSectionCollection","proxy","nameOrIndex","target","property","IOSyntaxError","ContainerNode","children","child","ArrayNode","openBracket","closeBracket","MemberNode","ObjectNode","InternetObject","member","keyStr","valueStr","TypedefRegistry","enable","typeDefConstructors","Constructor","typeDef","typeName","processMember","memberDef","valueNode","_resolveMemberDefVariables","resolved","choice","processObject","collectionIndex","schemaName","_processObject","positional","processedNames","firstMember","val","SyntaxError","m","err","memberNode","ErrorNode","position","endPosition","errorName","base","anyErr","SchemaResolver","processCollection","errorCollector","resolvedSchema","collection","Collection","length","errorNode","CollectionNode","ValidationUtils","hasCtorName","processSchema","validData","validSchema","doCommonTypeCheck","node","equalityComparator","isUndefined","isNull","_default","InternetObjectValidationError","_valueRequired","msg","found","_invlalidChoice","of","AnyDef","changed","anyOf","getMemberDef","e","ArrayDef","_processNode","arrayMemberDef","arrayLength","_BooleanDef_instances","_BooleanDef_validate","BooleanDef","checkedValue","datetimeExp","datetimePlainExp","parseDateTime","year","month","date","hour","minute","second","milisecond","tz","dateStr","parseDate","parseTime","dateToDatetimeString","noSep","zuluTime","dateToDateString","dateToTimeString","dateToSmartString","dateToIOString","_DateTimeDef_instances","_DateTimeDef_type","_DateTimeDef_normalizeToDate","_DateTimeDef_dateTimeEqualityComparator","_DateTimeDef_validate","DATETIME_TYPES","DateTimeDef","valDate","choiceDate","dt.dateToIOString","dateType","min","dt.dateToSmartString","max","NUMBER_TYPES","NUMBER_MAP","acc","throwError","code","memberPath","getIntegerDigits","decimal","bigintSchema","BigIntDef","valueType","multipleOf","decimalSchema","DecimalDef","requiredPrecision","requiredScale","valD","hasRequiredPrecision","hasRequiredScale","actualScale","actualPrecision","intDigits","maxIntDigits","minD","valIntDigits","minIntDigits","normalizedVal","normalizedMin","maxD","normalizedMax","multipleOfD","multipleIntDigits","normalizedMultiple","zero","numberSchema","NumberDef","typeBoundMin","typeBoundMax","effectiveMin","effectiveMax","ObjectDef","compileObject","reStructuralChars","escapeChars","reNewLine","toOpenString","escapeLines","toRegularString","encloser","toRawString","toAutoString","STRING_TYPES","emailExp","urlExp","StringDef","_process","_validatePattern","len","maxLen","minLen","strings.toAutoString","strings.toOpenString","strings.toRegularString","strings.toRawString","re","pattern","flags","registered","registerTypes","createMemberDef","input","opts","allowNameless","out","canonicalizeAdditionalProps","path","firstChild","typeToken","normalizeKeyToken","keyNode","parseObjectDef","parseObjectOrTypeDef","firstNode","parseMemberDef","typeNode","parseArrayOrTypeDef","a","additionalDef","addMemberDef","keyToken","fieldInfo","parseName","dereferenceObjectNodeVariables","_","optionalExp","nullExp","optNullExp","objectDef","arrayDef","tokenSpanRange","startToken","endToken","unclosedConstructRange","currentPos","createPosition","Symbols","isSpecialSymbol","char","isDigit","WHITESPACE_LOOKUP","isWhitespace","hspacesOnly","isValidOpenStringChar","isTerminator","tokenType","Literals","REGEX_CACHE","CHAR_CODES","isDigitFast","charCode","WHITESPACE_LOOKUP_FAST","isWhitespaceFast","regexHex4","regexHex2","reFloatDigit","reIntDigit","reHex","reOctal","reBinary","NON_DECIMAL_PREFIXES","reSectionSchemaName","nonDecimalPrefixes","reAnotatedStrStart","Tokenizer","startRow","startCol","tokenText","is.isWhitespace","is.isSpecialSymbol","step","start","needToNormalize","escapeChar","openingToken","hex","hexByte","getPos","annotation","fullTokenText","fn","dtParser.parseDateTime","dtParser.parseDate","dtParser.parseTime","dt","rawValue","hasDecimal","hasExponent","prefix","infLiteral","is.isDigit","normalizeString","is.isValidOpenStringChar","first","spaces","estimatedTokens","tokens","tokenIndex","ch","nextToken","sep","schema2","DocumentNode","SectionCollection","Document","SectionNode","nameNode","schemaNode","Section","ASTParser","members","errorEndToken","checkIndex","range","originalName","suffix","objects","firstToken","errorValue","lastToken","isCollectionContext","isOpenObject","done","expectingValueAfterComma","prevToken","leftToken","arr","currentToken","curerntCommaToken","steps","types","parse","source","externalDefs","Header","docNode","doc","parseDefs","parseDataWithSchema","_d","validationErrors","sectionNode","cols","schemaDefs","objectNode","schemaDef","parseDefinitions","MonacoSeverity","categoryToSeverity","category","generateErrorId","isParseRequest","event","parseIO","response","document","minifiedOutput","parseDoc","defsResult","tryParse","isDefs","accumulatedErrors","output","errorItems","errorToErrorItem","getErrorMessage","getErrorMarkers","errorItem","intermediate","d","hasErrors","jsonText","getErrorCategory","errorToRange","endPos","severity"],"mappings":"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"}